<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Liminal Archive</title>
    <!-- SoundCloud Widget API & System -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="assets/js/SoundCloudURLs.js"></script>

    <!-- Shared Game Systems -->
    <script src="assets/js/SharedAudioPlayer.js"></script>
    <script src="assets/js/GameState.js"></script>
    <script src="assets/js/PlayerStateManager.js"></script>
    <script src="assets/js/ChapterAutoplayIntent.js"></script>
    <script src="assets/js/AudioVisibilityManager.js"></script>
    <script src="assets/js/SCAudioAdapter.js"></script>
    <script src="assets/js/GlobalVisualDimmer.js"></script>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/liminal.css">
    <style>
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
        }

        .subtitle-current {
            font-weight: 500 !important;
        }

        #subtitleRecenterBtn {
            position: fixed;
            top: -9999px;
            left: -9999px;
            display: none;
            pointer-events: auto;
            opacity: 0.92;
            z-index: 2600;
        }

        #subtitleRecenterBtn svg {
            width: 22px;
            height: 22px;
        }
    </style>
</head>

<body>

    <div id="loading">
        <h1>ARCHIVE_ERROR_LOG_2025</h1>
        <p>[KLICKEN ZUM STARTEN]</p>
        <p style="font-size: 0.8em; color: #444;">WASD = Bewegen | MAUS = Schauen</p>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>



    <div id="ui-layer">
        <!-- Next Chapter Button -->
        <button id="nextChapterBtn">Weiter</button>
        <div id="noise"></div>
    </div>

    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING LIMINAL ARCHIVE...</p>
    </div>

    <!-- AUDIO PLAYER UI -->
    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer" class="reader-layout-timestamps"></div>
        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" aria-label="Inhalt">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAf8AAAGWCAYAAAB2CoosAAAgAElEQVR4Xuy9B3Rc5Zn/b6tZkiX33k1J2CSbXQIhmARiFoK7jSEYMGBCbwFCdje7e3LOBhKSAEtvSyih/wPJb0MNWUhxLxCITTEQwAYb23Kvkoss2//v5+W+2uvxSJrRzEh35j5zzj3Tbn3e932+T386drCXUcAoYBQwChgFjAKxokDHWD2tPaxRwChgFDAKGAWMAh0M/G0SGAWMAkYBo4BRIGYUMPCP2YDb4xoFjAJGAaOAUcDA3+aAUcAoYBQwChgFYkYBA/+YDbg9rlHAKGAUMAoYBQz8bQ4YBYwCRgGjgFEgZhQw8I/ZgNvjGgWMAkYBo4BRwMDf5oBRwChgFDAKGAViRgED/5gNuD2uUcAoYBQwChgFDPxtDhgFjAJGAaOAUSBmFDDwj9mA2+MaBYwCRgGjgFHAwN/mgFHAKGAUMAoYBWJGAQP/mA24Pa5RwChgFDAKGAUM/G0OGAWMAkYBo4BRIGYUMPCP2YDb4xoFjAJGAaOAUcDA3+aAUcAoYBQwChgFYkYBA/+YDbg9rlHAKGAUMAoYBQz8bQ4YBYwCRgGjgFEgZhQw8I/ZgNvjGgWMAkYBo4BRwMDf5oBRwChgFDAKGAViRgED/5gNuD2uUcAoYBQwChgFDPxtDhgFjAJGAaOAUSBmFDDwj9mA2+MaBYwCRgGjgFHAwN/mgFHAKGAUMAoYBWJGAQP/mA24Pa5RwChgFDAKGAUM/G0OGAWMAkYBo4BRIGYUMPCP2YDb4xoFjAJGAaOAUcDA3+aAUcAoYBQwChgFYkYBA/+YDbg9rlHAKGAUMAoYBQz8bQ4YBYwCRgGjgFEgZhQw8I/ZgNvjGgWMAkYBo4BRwMDf5oBRwChgFDAKGAViRgED/5gNuD2uUcAoYBQwChgFDPxtDhgFjAJGAaOAUSBmFDDwj9mA2+MaBYwCRgGjgFHAwN/mgFHAKGAUMAoYBWJGAQP/mA24Pa5RwChgFDAKGAUM/G0OGAWMAkYBo4BRIGYUMPCP2YDb4xoFjAJGAaOAUcDA3+aAUcAoYBQwChgFYkYBA/+YDbg9rlHAKGAUMAoYBQz8bQ4YBYwCRgGjgFEgZhQw8I/ZgNvjGgWMAkYBo4BRwMDf5oBRwChgFDAKxI0CHfft23fAM1933XUHYOKPfvQjt2PHjh0PPCCPqWbgn8eDZ7duFDAKGAWMAqlTQIAP5rntjTfeKDriiCMcrn/00UcdV6xY0XHYsGEdSkpKOq5Zs8ZhY9++ffc1NDTs27Bhw54jjzxyd+pXiv6eBv5ZGKNrr722Sqep3L17d8WePXscTTVhOjKJysvL3efwZfS7m1C86/+9fC4tLXVSpc7hPldVVe3lM1uXLl32FhcXu03/7S0rK9tbUVGxd8eOHW6/Tz/9dG/37t33TpkyZU8WHsdOYRQwChgFIkMBD9gzZswoWrduXVHv3r2Lamtri/bu3Vu8a9euoq1btxZv3769WN+LtG/jJv5YBP8VD+0ID4Y3d+rUqUifi/W5WLy0SP8V6QV/5nwd+cym8zqerf336fM+8d5d4rmb9d+murq6HeL5eyNDoFbeiIF/KwnHYUxKTcji559/fogm4KBt27b108Qq8ROI//Uq0iTroInlzUb79D8Th22PJhXbXu27F7MSn/lfn/f4TROwQZ93S1ho0Gekzwbt36DvuzW5GzSRNYd3u985rybpPgQD7rFz5877NFndOPPZP64ECn7fJ6Fhn+57X79+/fZpUe3V4nL7nHbaaX7fgjR5ZTDsdqhRwCjQAgUCwGavjr/5zW86ird0/OCDDzqK33QU3ynatGlTR/HMjv379+/Ae+Lp4Fk6poNAHvN8kRSeYvG0UvG8UvHHUrG70vr6+jLxvlL9XqZ9Sv0mHsznYu1TEoB6Ee8AvfgrQkKJ30e/872Y/+HV3Dcb/NrdvHiyNnjttq5du67Q9v7Xv/711WPHjt2V75PAwD+DEfzFL35Rqslcrcl9lEDziC1btvy9Jg1WgDIEAE1MN3n0mXe0crcF4A+gO4BHANBvfHaCQSAQ8H+Dvu+W8FCv43YJ+Hfp8y6kUL3v1ILYqUlZLwGAd36vF8Czf4Pug2vt1X/7kGh5TJ2Lz27jGrIaIDwg+u6urq7erftt4Dv/6fteJN6RI0eyChAAuJ+C8nllMPR2qFHAKNAEBQBP8cSigw46qKhnz57FK1euLF21alXpzp07SwBoaekAdykgDLDDmrzF1L/zu14OwMWHHLDrcycdV659OkkoKNdx5frNfdc+nQTo4a1Uv5dwDfEtB/DB5s7F78H1uQe2YrZAWHDxANoAfvjydvHetRJG3hs+fPj0E044YfEpp5yyId8ngIF/BiP461//ukwSao8nn3zyJIH/yI0bNx6hyVitOVOOFOmlR0AXINZvTsPnM1ug4bvfA2B17/53BAUmn747zZ93ATMa/m6+Ixzwzm/B53osAsH+XsjY7wmD6zCp6wNT1g5NbCb3DlkMdlRWVu7U8bskWCBUOAGFl85br//qtZ9717ZL/yNs7NKi2C0hwQkvGZDTDjUKGAUiToHp06eXiNeVouCsXr26TFo3gNwJDVzvJQJ2p20HmncpgKzfKwBtAXaFQLpSW2dtuEjR2L0A4CypKE2BlRRN3GnpwT6ANdf14M270/i5tn53ggWfOUbfHZizBRq9cwd4Ld//FwgfPg4AQUS7d+RevLUWnlwnXlcj6+g7igl44cQTT3ztggsuWBXxoWrx9gz8WyRR0zvceeednQSYvR9++OHJChAZpaCQIzXJqzXBOgULwGvcnMRr0ACk2wKTEv+FTezuc0hgYD8nLPCOYIAAERybKEgA0t5dgAWhEYxZUFggeAXH1staAPDvENBvZ9MEdwKAPu/QsVgTnPUBAUOHYW3YoX3qdJ5a7VOrfWv5rN+36/ycb4+e38cv7O3Tp49zaXTr1s0JEBIU9nrXwrvvvruPKFoTGDKYgHaoUSADCgC2sAPvS8ccj1m8pqamSKDutGC5BDG5A4hF69evL5LQD9BXat131j5VAvFq7Vctrb5CQF8eALQDaoCYOCjAH7BnH21V+t5ZWyX743vnHgK+5N4/U7iFwLp+wEcBcSdQeL8+gkEA5gC62y9hc+4C/4ycj8/+e+h9PwpyWQ/+/g89K3xxtVwUb3/uc5/79be+9a3Zl1xyyfIMSB+JQw38MxgGgX65JnGfhx566HQtmLGSiL8SBP0hiSZ9MbE8CId38JKm/+2zud8oFLR0l/v558Pn4LyJr+D6WBHQ5LEcNGiBN2iC7+Zdm3MtAPwha0O9fq8D9LVtYdP+W8UMtmhzggPuCSwPeic+AauAEybkQtiuGIMdWui75Cap17ZbvzcsXrx4jwUptjS09r9RIDcUkOWy+PDDDy/58MMPMaMD6uUC+wq5L8sF1uUC93K0aXzsaOn6r5N+qwTA9X9XHdNN793E87p6MNf+nbymDvhjksfEj1VA+5bwOfDXd0JACDTxJnllwAedbMAGP0vG0xL4ZtI0vkCwSJmYXhCAB4pfrR84cOA7hx122JOTJk2acd55532S8okiuqOBfwYD48H/wQcfnCrNf5zA//DAJ4WpyU3S0ORtnLTh3/zlm5vQ4Vv0x6a6f7LHC87RaEnAyoCVgOwDbd4NgRXBWR0CywPBhLgedmkf5xrQ77zXEzMQWAg4BmsEgsUuCQXbEBAkBGxWfMEWBcsgLNTp+3asDlgYEBokGNQppWaHrAI7iWvQy9wIGcxLO9QoEOIrRdLsyzZv3ly+du3aCpnlAXcyk8r5rHc08Epp/V21TzcBfFdtXfRfNeZ5QN+byrVmnQle3/kN8K7QhvbOuze9F+OsD7RsZ2rX/86n79/R1L22HmjgTQ5YIq9sLd9rLc9FUdKxe8THNgwaNOidz3/+80+MHz9+xkUXXfRxvs8yA/8MRhDwF8j1ufvuu8+W/2ucFheaPxGo+Ksawd9/TjZxk03KVG4plUXQnKAQ/i+Y4E5QaeJ+vKsinIUQjlvYz4WBsEAcArEEWjTbBPaA/lY+4yrATaBrOiuC9tsmnrJZv2/R51rRrg6hAqtEsOhcMGKvXr12yX2wWwIEgsUeuRT2KkcXF0fep9ykMt62j1EgkQIBcBYpuK542bJlLhL+k08+QXou0RopCaLdS/W5s/YFzLtq6y4FpZsAv0pbZ4Afj5w0+i7augr0u0gQqJJ27/zyQZAcII7F0pvOHajrfhoD6YLvju/BT8KWTK+te57VHB9Mha+1NBNS5alNXSt8fPA8ZFBtRPOX2f/xyZMn/9k0/5ZGocD/B/wFYH3vuOOOsxXNOj4w+yMZJwX/sNnJT7DmJqoXGpJZB1KduC3tl/h/Cia1/UY1bN0ImckcA6AmAUGDbLgE/IZVQNt27Q/410pI2IQbQfttI6aA7AUyGcho0OdaXAsC/fWyEGyWy6BWVoSdovEuMbddih1wKTehKlyOzAU+9ezx4keBRlO2r0KndNwSFafppFijcoF1tXzy3cWDevIZQGfTGsG/XgWwC8x7aOuFAKD/AH+i5VFWykibY+M7wgNpcVpjjddknWv/Rqp712UY2D3v8OCfjrKTrkUz8dyJgB2eHv4eU50yYbdsAP770PwHDBiA5v/Y6NGjp1922WWfpHq+qO5nmn8GIxMC/7MAfy0+NH/8WI3gz+mbA/FUpdSw4BC+5WyZxZKRoSUBJSzJh/cNWxBwI2AtJPAPayDf+azruSwGvSMUoOn7jRgE50pASJBgAPhvlta/lk1CwCasBwgPEhAQFrAs1Pbo0WO7BAPcBvVidLvHjBmDK8KsAhnMbzu0/Sngo+sl8Dq/uyyM5cqRx1zfWfnxLuBOoN1Fpvq++r2fMo76knFEkB0+fNLjvIkeLT/Q9AnMox6JD6gjB96Z5fU/myuI47OVPBX892QWwjDANsXTcqnVNycM+P/S4bXhkYd/iQdtkOZPwN9jMvtPv/DCC5e1/+zI7A4M/DOgH+CvRdL3/vvvPwuzP7n+Qf7qfuDf3CXSmZCpLJ5U9knnkcOg3tS5ky0uL/B4M2DYKiDgdreg41xMARkMmPgRBoLP/IZJ3wUfCuy3y/S/SSAP8G8N4gVwH2zVtlmAvwHLAYU4dMo6nZ+4gjoJBLVKzdmBgKGc44YXX3xxTyFU5kpn/Gzf/KAAwXe602LN75J33nmnk8Dcgbzmc6V+d5uA3gXaicd0FViTQlMN0Ausq2Wu76kAvJ4y2XfHXB9o9K6SnY51qW/67HLbMeWzZhO1d8Ddb8m05bAS05LS0dL/mYxKMi2/JYBPZllojleGz0c8lPgJPv+3Dj300McN/DMZvQI51oP/Aw88cKai/fH5k+rnIlgTtX3/yCEQdJqwvrPxdzhC1ae+eJD0KTAuDSa8MMNmN3eSz87V+ErH9OYPSkWACF+nqf29+S8Aend6Lwy0dN+eTgJ1SmwScEPdAawEZBKQLUB2Qa0+k3mwXp838VkLFYFgizSlDQoirJGlYB2WAwQCbTskoNUrZWefxmvfF77whX2WclggizFPHoP1i9lec6+j5h4V7iglW6Q5Xi4QrxB4d1ZAXndp8L31jhYP0Hdhw1eP6V7vPQB/tHg0e3LpBf6Y/omsx2zvtffGNRcGP9ZeMjBMJGEiL/E8LRX+0NRwtGQVaO7/sCIStj4En30lUsduPK8JjnHfw5bKQMjZz7Xh7znRbQH4o/kPHjz4zUMOOeTxcePGTbdUvzxZcLm6TW/2v+uuu85QFSvAnyI/mNk+U21DYOwXHBML0Bc41QFgmLgxKxFME0jkLpc1ECBcVKyOde++JnXwfwdJ8k5S9++JgJrKczclpKRybHPMojkGkXjNZIKE/w0rAYuPfge8YxmAfoEbgSqGxBPs0G9sZB84oUC03aTqYsul/a/Q+xoyDiQ8uPRE4giIG5CbgDoHO0kvECNuMKtAa0bdjkmVAqxjH3mvedpJrsIKafeV+OQF+t3kruouEMdvP1jgP1DR94A/vnly6LECYGkkQA9Bgeh6zx864qPHbI9w4U32iWb7ME8Kr8FMwDzVZ0/kh2EwbomPJFoN4aHwheC9sSQ6gcBYEnU+51rks/+ud1fxFBkA+hAMKUsJ7pFOuDzCNAgLRnwOwH+9NP83ZUF8fMKECTMM/NMd+QLbP2T2P0MLmTz/I5OBPxOIhchkpRAOhXUESssESis1sTahzWofFi1CA2k0WA9c6ow2PvNbmRY8ATlI+q6mNSa8wEfnJH0CdIIgHT+ZOa2TQQLSNxa9gBEFvzcWwwh+2y+PNrwowpKzX7xhgcMv0mQmw+aGvjktxFsK/LnD71640m+4C1yJZIQB0ZSyxdsJEhTIr8NkJ5pvxjogK8Em/bdZ40C9gm3athJISCaCxgR3wU4x4vorr7zSYgYKbL225eMAwpS4FbiTP99J71S4oxgOaXRd9ZuLrMeMr8+Y6p02z3eZ/HvLn9+TtDtiiDDXs+n+nWtA58aE32gdZE0QjAeP8bzGr89w8Fp4XTa35poD6mTad1h4D/8fOo/XxH1xMlfxFCAONgR6d8vBmvaaeuN3wBwQDmKG9lCATN/dWscSGChRZAg1ph7zn87n0pCDd/gDTX7IiOgiZe0gjUkf6hagQIVfiWZ/af6N4K8iPzOuvvpqK/LTlgsqatcKFfk5A7M/4I8kmaj5+wWJtEoeu/zXaxU88pqkyDcFTp8S8KbJRqc/B/76CNBzHkCfQhtI/Jj1XMAOwTyBNuCidfXd+fMCy4DTBhACmOjBywX28LtnHjAQhAf/HhI4EqtgOabCuQLhwp3bbywaNm/Z8BpFePFkS7NIZFhh7SXMgGAkZBoIyHEVuPLFgL024gW26vtW7eOKFWlRb0RA0JiskbCwRoKAExRUc6AWhkEHRV+ZcObMmXvNOhC1Vdj+9xMC+iLfuIYytwIYyn93lwbfQyDTW1s/gXpv/dZL67Zn4LvvqnXr/Pek3rG2Ka5DsxptgL5bf+H15PlJWBAO7xOmiI+v8cJAMgHA/5dIybAwHxYIvMYdssI1ViwNXJm+iZk7NXqNNgDeFQ1jY235WB99dqXI2bxAEDwvbNH3OtlDATKAngJi8FHceGzwT2qPoFTxWeegIJkvVOYEgkBBoOdJCQKYxqL/e++9N0JB2n+n8RiA8uR5WCKNEjV/A//2X3PtfgeAvxZ570cffTQM/kTS7mf294uV7n5Eqkvj/0gNIl486qijZit/HQlyhyYjoie+PwDaVcNCu+dzYAVwdbT1OxW0XAUuMRD3jgnQp+xgzgLQAXld12n6eiEc+PKYvgY2woIv1uH8jZgUdS0ndOg4ru3LanKs2z+wPiBwYC6jpSaStBcQDqheGAboxAFryUKQqEWELQ8woGTaS1jQYNF685+u3dhJUc/nGiyJYVCZcAuAjxVGMQLLJAB8KuCvUR2BDWQRUIgI4UH/1UlIqFUPA4obWSphu6++aNwA64t1+/vf/76z1nCl/PQV0tgrxRc6UyhH5vvBCgYeKsVgGKZ8/d8DzR8tn3UdWPvcWvUCOudkCwR496AemPgc1u7996aEb/9/snOEBeZkazGZ0K414wRrKoPS/4P0Xf0G0LpKoQG4U4J8D+tM310PEb2zDxk9OwjY5TeO0e9Oc2c9IiCwtgB8vVw8FJ+DfQB0ny68Cwud/qMHiW941qj9EyMk+jqrgHgTllZcg+78xGSR9qht8J///OdJGpsREs4OCfjmZ/XPA3p72gXgT8DfIqL9J06cOOP888//NBozsPV3YdH+raddB2mB5QKK/cAfQPbgH16wXAYtkuAz5Ysuktb/P+SLakKtEIA2CFj2qkpgR03qjhIQOi5fvtz58DRxXQqOJmCxpFS6XLktKJUJIJOy0wjoWAFgJCHgd5o65wgYjNP4mewB83F5voEfESGA+3e/cU32DSwEAD+aCX4yFk93bUQZE4WMaZN9O6Jp8B4wRd59tyzu0TfQaKR6ItMJM5xE+iUuyuYEizCza2I/36qTbIIdxAQE7gEXPKjnwDVAASIKFG3S+GyUdaBG6YbrJRhsHjp0KK6bXUopRKswYSCDdZRPhzKHld1TIg2/k4CDanlVcvn1IDhPG9p9T62FLlorXfRepbXQS5om2j5bV+rbYxHAFRBaJweQIKx1h9dEMoE3fHBT1rCwEOAF54S157Jrgs1n4TT2IfkMD/fBw6jDsU3rgSwb4mi24j4LgB1Ady447Y92z/kQDjDFN3YkRVhgQ1DwGjngrBcxPfjkGzddg99EzgaXDaRrudbmWntUE3Wgruvs5bu3Hkih2quxcYK/1uw+3eNe2pdLgN+n8SnSf2RN9P2f//kfyrKfIKHsy1hbwnzb0xx6Gvjn0wpto3tNBfz9omMSYbbSZFwv4Fggzf83ags544wzzqjJBDwCQPXNMYpWrFiBoOCEOmkbHbVQ3Gd+Y2Pya6IXEREsE2SxpF7X8lK/u7rbWiS03sSS4AQL3Am6Rqn2KRPQV6G1SLPpiflSx/TQO0FKpBxhLaArl3c7APrEJWCpoFJYpd7LdCvOdxkwPhfYiGASCCiNWQ1hoPfDmaipJBvmdPbx+7K4xURcWiHmQ/0OY+KdWgIECQL+a2UhWC6mv1zy3qeyFGzSWG7WM1G10PVEEE33HHfccQ1WebCNFmAbXIYUPIFFiUDICdzUwA9y6BGAe5JbL6F8qN4HC/z7sy60broy37U5l53WBs1tnKUMXz0merZkczzML7yG35wQ3BwJ/PwOBIn9AuMARrRzNGudA+B3wbL6neqbaOtOKwdgAVe0Zt07le5IuV1PFg0WM22bKMJF0C2auT5zjEvVFeiSpUOlT2cR0H8N2r+B73p3rcyV7bBHdKXhlwN8KUNOkFalQrfJ0tYYF8B9IIRkwi8590svvdSJUsZqyX5W0JPlq+J7BFLCmw5ws4TB/+CDD35MFf5M82+DtRfpSySCP6l+gebszP5h6RFpG1OZAGOdgH+uBIDfyHQ086STTlqX6WQOrpWSFcdXB1NFPEdbBSW540g78sSWJtNR1omOWqDFMD0BYrEWsrMUUGQEhibG11lCQLWYHWlILBy0GawOrhgJPQ5EC0qKOkuB3p2PE98m7gViGthHG41CqDmO0OHKiDYF6l4b8rT1+zZ1TFOTJ3wev49Ta/QKxsIzGLQOzI3b6VMgeqwheyAA/zUSBIgV2ChGiNVgi6wCW0W3rTpN7fHHH4/v0V55TAGE2eeffx6B181zzMUCjZ5sAvpemv9E5A+R5jiE37RPV22dA2tZY0At0yoQ0h01EsG8ufnr56rX6MP7pmIR4Di0abRlrWHacLt+GsxpzO++1HZg6UKbJwCZjBiCYWsRhHXLaO8Nuh5AXqfPdZr3dfjYKazFJlqghTfo+V3knHiIW09aD+6dtFo/FVSZcJ/4kPvqK3O2NE2ywSP9NWjFrmeoVln2qUGg9tES6siqQNFx49OU5g/4y2I744orrjCzf0uDVsj/JwN/zP6aOE2BP5r/WgH/PBWf+c1ZZ501U/6jtdmc2Nmkd8CwXMtP3XdHCTdFWA5kUSgWaJeIGZaK6ZWiEWFJ0HM4TV5MQ3ygtBP1wUUPV15Ux+HnBPhZZOQnow3BUHvpv15iGt2oKa5rYimgV7e3CPDZWR/CoI8wxQsNKrxYkz0/+7Kxn98/bCHgmESLgV/8gSnRMTYYJsGCMMjAJbBNvyMUEDRIZsFaCQarxQxrZHpcp1KgxHdQeXDXF7/4xfpsjo2dK/sUYL6/8cYbJTTAkUZYJY2+q4Tdgfo+UPOzvwCuH9YurF8ItZrH3fHdY+Inxx6LGQCiO2v0HXsNP/Fuk1momhJu/e+JQkJof2caZ9N1vNnda/TMXcplUylzHcGt5KyT8QLwE/dCTIvOVUeKrAd9ncvVxdB6xTSPFo+/fB9auwTdBs3pBq3dPZjb//7v/36PeMI+gbrz2Wd/ZLJ7RsBfFokut95661RZSsdqnAF/+hw4zd/zGc8Xwpq/8vwfJdVPjX1WZPeu2v5sKWmLbX9b+XHFO++8s5MmUe9wkR/v8/eSetj0Ro17NP8hQ4Y48NdimaltTT4smFRHJBAYirWoSt9///0ymUPLpCU5/yiafihIkcAoXAi9tE8fAqG0ddPxCAD438hwwJpAGo7biEXA+qCNeAiX4cB7OFI32eJlDIJYhP1Men7fMNMNm1rD/wd+Us9kMYvCZF2wk8CfEsMECFKCuEZjvFzvKwX8pBluxDcqsECboqXxbgUN1cuciak18owy1XHPx/0kvBd985vfLFq4cCEtZ8uwQOk50PSJzu+rbYDm5nDNy8H6PFBztQ8CKv5h3FxYr7ygmhj0GtbUw1pk+HNTc9WDT5J9nS+euceGNo5pPgiIqwOw0cp1/I5AY3cuLECexllYroIS2ev5TuVM/UfwnDPza97SPKu+X79+HFNfqPEsmP011l3Fv89UfRZStAH/RrO/gX8+ruY2vudE8FfAXqPZPwz+XgAA/LUA1wn45yvg7zeSHmcIBAoK/JsZAmf6lGZVrEYkUkTKSqVNdZLJ1EVH0yecTUyYbmJs1VqQ5ET30e99xXR570l+Lv5TWRywJnQm/RFfKjEDYQ3JWwP8b01pYMnu149XMk0rpA00FhnBt6nnIdUI7QqfKCmDVBekF8FqMdTVEgRWi9muI2BQplDKFG+Xa+D/OqW08dy1y3Xo8Prrr5cuXbq0knkmkO+ledmPtC+t40GaX4M1P9kGUDqX+YhwQECttv3K4CYTGJNp+p4nJIJ+U2ORwENcyhxgjeldGjxdMhEo3ab5t0Fzj7iU1fq+ET980CgLEz9R8fXS0l3mCgWutN8uvddrDoYT3GMhjHrwv/fee53mL8uOA39SpZMJXqb5G7c4gAKAv37s/eSTT1LkZ3wi+Ic1Rz4HgS5o/g78L7300jiBvyNHYBkokhBQhBsBzV3vxQQfoslLe2lMZ2PmJJoAACAASURBVCQeAMaMywBJnWhpmDAug8D86iKpydslE0EAT2ChK3fKRhYCQgHAr2P2G79E354H9TCDTuZTTbQWsL+0LYKpXJEhmCwR0aR0UjhIDNgFSGER0PsqMd1VpBXqfS0MWp/rlPK5XeZEKyqUYx6j8XQV9qTpVWrrLLDH6tQXgNdnp90L6PtrnmHapwMeRXcABYprYR3wfekb75Q5Etbyk5nz/dwKa5TheYRVKrAsuXMFuewu+JRAOv2PVr9Nx1CnYov4iKtNgaAZ9Lpwc40NK5T2q9Vc2671tFP7uYA9Nv22R+6oPXqOPbJA7c0XM322p0Ui+Itvj5ACQqpzY1n2ZD5/1WZZKJ//oyrvO0Nd/VZm+77a+nxm9s+A4h78n3jiCVfbvynw94ufgD80f9WIXqBJFEvwb4nc+PfVprRYGlkJQYBalDBrUgnLpY2heZEqRX2F7lRBE/D3ojQqftdg86mIrlwqAgQm3SDS2qcu+myD/fokNMekk2lr3qoQdu3AyBEEMMkGgoBrS0xcgJjzWjHgGjHkVfq8Iigs5CoQykJAwaHtcgns0vPunjJlyv4lx1oinP2flAKK6CZWpFTzhYI75N4zb5gzfTW3Bun7QMz7+oyG31tzpZveXXR+UNfC59zvV0Y7POaJAWJhYSCZUBn6jYh3Z8InZQ3TO5v4BFo71SiZM64qpX7fpPPip99MujCR9pozxJ9g0ieQj54VxJW4qnZsF198Mf76WGjz6Uz/MPgrpRrNf4TmgIF/OkSM+76p+Pw9jZDstUBdtL/SWV5VxP+vFTEaO80/kzlD2pWAs0SMsISsg0AQoKAKWxXZB2ht5FSTdhWkX/VDi8NagNCAJodA4GMHsEQE1oEDKnz5oMJkAYWJzL8prY6iKGLQaF0IA1gEthAHIAa+Usx7FRvpg8QI6H2NGPhG3eMWzZPt1nSodbOFMQ2yWopUk4GME0rp9pDwOECCFZH5QyUADAP8EQKwKElQJPcbwKfRzn696xlr5kJiel6y+ZHoekoQEH0jL9ejAq0eHz0bIK5tGwGlmuMIhsSMrMBCREaJ5gdNq6hHsVP8Y4csh0TYY7Y311Ga02Tx4sVly5Yt66qAv7M8+GsOOPD3Gn9Tmr+6+j1mAX9pErwQd/fg/+CDD2L2d139goA/cuf3q5EfAv/1Mvu7PH+l+s0YNWrUapPOU5sdnqnTEU3AXiQwxf9aJGZeTHqB6OgyDBRHQBZBNwkArs0pn8XUq/QfZtzuWAs0TggEWAZwKRBvgJsA18MBqT7+7jwj53uyrIHEGAFvysUaQFU0LAJBoCDaHWZagq5IFVwl5v4p1QXF7FdICFitgiTEBmzRpWqVQbDTmHzLc8RH63/66aedtRa7yBrHHOgnk7734Q/DxK85QT13xp6IfYL3XKW9oN5Eoz/fj3HYIpTsLpqKwve/+/HXmO/UeDsBUIBPMam1bPp/HRp9UFNiGyWnSR8F8IMCOvjqSblzxWwQJuNstm95JjS/RwL4w7ePbgr8g0whuvqtx+wfgP9Mi/bPdBTy/Pgw+FMsQmb/ryYDfw8agea/Xmb/VyW5/9rAP3sTwGcZzJ8/v1RBPGVi+J30XoEwQDxAEEQI0HfThkDQm2BCfSaqu08QQ0CjFeIEEN5cgaOwVcDfLUw9DAyJTxEWEsKWn/Dv+HVxCwAIQXVBXAKr9X1FEBtAyiD9BggY3KDPWzRvdioC22IDQgRn3Km4R4yHhEDa4ZIySrU90vIGaHwH6jvbAG1YgTDr+6qUpJCSntoo8IWBPNkYh8fQ7xv21wdWAlctT7fpovHJCCHAk1RQMkKkya/W2K/SRtwH4L9R4A/Q12msd+q3HdqnXmBDb4rd8s1jvv+sKpC9MqZACPzPluYP+H8tBc2fxj5/paWvNH8D/4xHIc9P4MFfzIcykaSMAP4Ene2n+ScDfzT/Cy64YLpp/rmdBDB31V13vQ+ou66tM+laAUhQX6A/pmAKteg3Ar666pgq3ZXLPOA44gUELq7cMhXawtaBRAtPYhxAIoCEA8IADdwCZIFQMAWTr0CAHGzysckYWCVN7xNp/stkCfiUWgLUF1Aq1k79tjefcquzOModlaLn6umzyU1Cbnal1p8bS43jUOVtD9NYDhX4D0K40zi6LBGi9bVRqa+xGRX3lRjYmajJh+/duwD8cT7gM7DsuOY0QZU88uSdSR//PeZ7xpIqkRSKIu1OAL9Fwh2a/nbd007d+25rHJXFmdLEqbzP/5577jlbViIP/qQWO7N/4nwg2l9CG+5aB/7jx4+fZZp/7scp0lcA/LV4e2kSTQnM/l+lgI2Bf6SGzfnyg/aqrqyxmGyxmC8xA84VoO+9tdFxDSsAUd4UJKKAC1UJ+wbVCauDdESKGjltkRfM3wsDiSCRCCyYf3mxvz82ABPnA9ZnV69c+1E/gKqClE/9VNrgxwL8jyQALBfYrRHwb9JvtQKRbRJW6qQZYg2IRWDX9OnTKUPdSeBO05xquX/c+Gn9DZO15xBpcYdRNyIIBqVbHmWnffdK1+gqWWldL7SFfft+jPw4JnPraKzw3dcTXR+k3mG+X63f1kmY26BxJCJ/PeCBFUcWnI3y5W/W/dEzYjflbc2E37b8AvCnOJP499mk+slii9nf9SdpAvzpyQL4v6FA7SfGjh07y6L923bMInc1wF+Luqc0fwf+mkRHpQP+Z5999gxV+Muotn/kiJInN0TwoEC09IMPPgBIXEU3SnxShRBfMNUHAX9t/QT6/ak1oP0AFQrAuHRD3AJon+HgwUTAD38PB4glWgw82YLUMYQB0gZ3ENkNcOAKEIjUYBUAUIJ6AjUCj0+14Uraes4551DUpeCyBLDeKPixRC6dKtV77ymLR3+N12DcNhLEemmsSPlkjDDt49MnhoPy0hThcaQNB3CFae0/hwM4w1o9n73fF7kN4Qwa6zf6QZCKR4En+jysBtzJ5tAYAf4U0tmk/UnPY59aCXC1GqddROUXagGdfFj+gL/mSHfxbTR/wB+zfyP4J84XBDwydQT+r8td+6R6ssyS1XZVPjxrc/doqX4ZjCDgr1cPVfg7XRMI8PeaP8FnB/Tg9j5/Av5U6Of/GfhnQPwsHxrEDBQJYMrw+1N8iLasEup6CWz6ypQ8UIAzRNrlAP3XV+BCwKBrViQhoAs1BoLUMCoQNrZjTQY+iRHhyczM3rxMChhFWvSOGXmrNjoNumJC0v6XCkjeFVPCKrBSDGqDott3KJe7QZ/35HMVQarv6dmKxZRxodEHoopgPVVkQ7v/O71/Xgy8n37vQQ8JjQWCG64aAvj2s64kC8hL/C3R1OsBIIjKxy2DNYZa966CHtq+xoW0u7Wi9ypacytA81MB/Ep93ixtfpuCw+qk5e/SWscyU3BCWZaXYJudLgT+5ySAv+st4nm3/xyA/xrFYAD+T0yaNGn2JZdcUtNmN5yjCxn4Z0BYakQLGHo8/PDDZ5Dnj88/0PybA3+X6keef1Db3zT/DMYg24cGQoDrZzBz5swi+fjKBTb0JOgu0KehC53cegD+BI9RCEaA4yrDKfWK9MJe+h2Xgqvv7rV9DyaJGmhz/mWOCQQFXzOddxdIRvS3XAIrBfZ/kzb5gUDmEwEPTYfWyx2wSUCEaXlLPhZyYQxE/05aT920ddfm3DJaYwdp+zt9P4wqfLSUDsz6vl21i8lIpukngntiUKY39/Lu3TMS4mgHu4tUOzIwBPSfaqsR6K8jB58eD/pvg2hPdP4W7UNjnC26h93Uu5fwlZUudNme43E/XwL4O4ttoPnv11gsDP4a9zVaZ3+R4va4NP/Z8vmvyXc6GvhnMIKAv8CguwqJnKm88/ECiRZ9/hT5EfgvkAT5/wz8MyB+Gx3qawsIfDoJeMrFJMr5LAYP8OAaQADoS00B/X6QGMnn9bk3eeP6v1TgjxBA1gC+5wNSBJMJA01ZAgLTtP6WHVwxAgQI4k+m2hvlXfWdVqsrJQCsID5Ac+xjCQKbxbBqFViKxhrpF/58gWnnuXPndpV5v59A/mD5ZIcSiCl69hOtMe/jhumDVSZI0XNCljfbJ9Pyww+dSO9QgKYrn0u/Bu3POzXz62nBLRoulZD1niwtyyjMJIFgg/7bTECfaL9dv+8SvV2Rnddee42gPd+GNtL0juvNefAX355GbX/x7gPAPzxP0PzJ0hD4vy4rzqNo/gb+cZ09wXN7n/999903VcAA+B8RtPQ9INrf5/kT9Qv4K9r/fwz883cCwUAE+hW0cJXG300pQ/3ESIYKtL6Ei4D6AqQY6gkrxEgwSRNAiB+aMrHEChygoQJEibnlXvtoAuBc3QCZozFJu9bDAqOaIDtgiSwB7+n7SvzQuuZaAdguaaT4m32AYLsGCaLhqxhPseo2lC5ZsqScUs4SZvrK1TJIQtTBEqa+qHVFYx1K7nZHy6fSY1iQSqy30BL4J1gFXN9537ER/z2V9HQOyulupxOegL9GdPtQlRfflTWlRh05N2urE22tJHOeLl/Wrsa4++233z6NaH/NsaOoAEk2j7cA+UdjTRLtT55/EPD3uAL+ZlrAX54OfrZuWxK+5kTlQGmHUyU9jhH4/wPMXQypsUa0Z9oG/tmiemTO47IIAHFlEpQIOCqVZ95Nc6AXrgEJBLgFuuu9tywBFJk5SGDGe28JDFgNiCz25zhAc/U+/7A5OvzkoQC1z25C0f4AGWlj0k43ywKwRuboj6WVLtdnUgU/kc9ypUCLltKbRowYsUvHtGvuOJq+aFGhOIreEp5ItxwqWg0V8B9ENz39h9bfnRxsCjD5WIrEJk2JMRRNzRDWoBcOAvM+efT0psdHv0zbUtHroyDNkpRLTPnb+F8a3yadt1aBhw30oPdWmMjMRruRlCmgeUelz+633XbbNFX6G5sI/gkConPdUYxLlp23FcfxxOjRo6dfddVVS1K+YER3NLN/mgMT+COLFSXeWZOmt7bPzZs3b5KY/nFi7IdKuyP629E1bIrkMwF/aP5BhT/T/NOkfVR393NCmmuZNAkiiZ1VANcA4KWNTIGhAbgNQpOVJt496EWAewCLQDGBauHWsIkZAYl+az/HQiZKItDpvQ6okXq2iboBeqeV6wppsAQGfoxLQButFbfKElB3xBFHtFkNeDwW6t1Q+vbbb1d9/PHHPSU099e6wbyPu+Rg0Y34id5o+hRo0vcyOunhyw+DftgsG7aOhD9DnyBS32lvel7SKGmUU6uNlDzXb4HYCcBfWv5yva8SzcjL30b5XQlODRKidss6Ud+WdIrqXC+E+2oJ/P0c8uuPd5omaf18LMH5ea2Z2Z///Of/JqGwVsLA9kCQzjtXj4F/C7MZZnXXXXeR211CUAjBXDAl2nxKqxssxnXYhx9+eKze/54KYjDwcA64lyI9+GvCAP509futmf0LgZUc+AxeGNBYl0lIrJQm20XCIRYAuscNDIoJDcCPjf+aVDXNp2rmluZZKfXlAbtEsA+bJL1gGZ5fXgMOigftDdwBtBpGe6VK4Cdot8FGOWHXT0AWAVrC7sxxvYCOMreWyaTfmUA+CUIDBfwU4zlY6+hQ0Yf3gUTuB62dKcy0X+vcpgA/cQTCaXuiAWb93RKGqJxHQB7xETVi5qv03aXniQYr6boo5r5e5n264u3QVm/NlQpzfWL21xrpccsttxDtn9TsH7YmQQUybgjslNA8j2I/BNkiOAZ1HKjOuEMWI4JDqflAVUYfpBtZIhr4Nz80HRXJj3+oWn5cyoIS6d2HVC+BPRrLYDFzzLmHiHFRDIZAsANyimFagdm/nh7vYrYE/Bn4R3ZZZPfGCBoUwyAzpIvmiusqp8/9BHiDqCyoOYR/eyhzCr+3hEuqChZhBUgEvLBJMnyXRKjDsPz8CwWy0VcAd8BuMSeaClFe9lOlo30kZvaB5uKH8mWv0Pe1MmtuzlV6IKl7Atbe0vAHiuEStf9FUva0ng6RAECmBF0YsZY0PkOi/94/b1gjCwN9oiUEbZ+GOXrmLQJ3iux8KKD/UDERSwT0K6Tpr5OGj5a/VfdQK1Mu9fPtVeAU8AF/StFu0uefGEBK227SZ6nSqLnzCdYzYmk0r3CvrcFVRHdO/bcRt5rmeeSFRwP/YKLDnFS2sfj999+nBGwlBbjEoOn2RR14ar+7VC5yi7X1ogocPebx66K10TGOErDJmLNnxJo89Zj9DfwLnLskPB6WACoM0pFQc6dUoIcFyQmT+o4g6RvPDCSXXfOsj6xIzLsudC6UIEDteucS8NUBE+dZ2BIQtgbwmYI0Yl5UoqN17A7M/RQOIh5AoL9EjOwDGJqYGJ3k8G1vUTvYHcQRZDpSzz33XDUd1PSMPQnew00mYecwfUdgHkD1RNaOnhXrmiuB6C0cySL4E3/z3xF+KJWs58O8T5c8miZtoDgSHfIQeLT2KK+7Ss+6huqJlOEVM98lgaABX76V1s10tPPj+JbAPxkPR3ljbgUtlGs1r7bRdEkWpc2kggbzjLnGVkMLb/px6PM2CZ11UWzOFVvwx5xPoJYAHo2MwiDU/aZYSDeCtWj+AhOmshslXqkRLmaNeba7fiPNiBKRZRR20XtHTLWJvsewpsLkoVCIj/ZH81dFtlkSOFZlg8nmx7Kzu/QUwO+oeVepeVWld+oH9BEg9tM2ENeAhICBmn80oqEBEc2IqFqHENAYKMh8S9Y7IAyeYf9l4P8mwn23gJGGQvSEp6UwgYFLAUfayNJSVgLqOoHkdt1v2hoMgXzEPkj7qZRmP1BWDdxjWDYOxUqmZx0WdNajq14ZMTKJgk14piS6P8JWDbT7oMQunRLpmldLJUQ920rq6FMemU6JAnmYMi2TtyjTZjvFkMyHH8/1mC74h+ebd6kJ+J07iTlHkC1CgOYdlThX6zPpoKuJteE3fV6PhUnn2SYhYAfNmyQQ17d3SmicwL8xOlvpRUUCX6q4VQHmYra9gs5ulAjtjQlfv7P1QwigkAsBXPqMvx8NJWk9d292TKaVefCns5cihzH7P4PP38A/ngzIPzVWAVUVLBdQ0k++K5kCsgz0C+IDBsnddDDAGZjGsTBRSZAWtLgFHGgmSw8Mm8DDAoC/rhgXmgxdBUkP3IB2TB57kNP+N8WlLJVFoEbn3wjDkma8rwXNuLHhjgCW7nq4NgZJCHBFeTDvaz0RwU+JZFouu0qIHthZH96cHwb7RNN/QgCfC+IT8wX0t1DvIAD8D/QcH8md8YmY8RpMscQ1aI3XmR8/3uuNp08X/JPNTSxNQatm1hExASh3u7TRyInYkjXaVjH/SL8lpgSrE8WCtO963cZGBGsFku5hbQUZJBlb2tIZ3ViAPwz2jTfeKBFTraDut3KxqwX4mFvRSkgxGhj4W9H0u4hJwZzo7OZzisnLJtXIRfInpholC8QK+2q95EgL1yDgb4GiRH87depU0/zTma0Fui9WKM3P4qVLl5YoCI6AP3oL0EOgr4BzsIBziACTd1xOWAP64iPXu0uBSwRLD/YwraZ60gdz0qUHYgmgkRBtZYkJkCuAOID3pSG/T1CgPq/90pe+tEnBi3Uqa7o72TAoNsY1SpK7opsCHAdIszlIwX1fkpn/82Q6UIdfx9FeuZM21yrZCyjJ1lPiNcLBjIGmvwtffgD4K8RUYbSfCvRJ2aPIERX51pP1oHNR3yCvyx0X6NRvl8cKF/kh4I8iP+L3SfP8w9bb5ixQgYDg6kZo8825cLFRipv+HBTjolMnGSXLqMWhbY1igTZrfdVpfbd5kGlBgz+DLKCvFCMi5Qr/Kmb73rzTCETMyjUDCXq7u9QibaRpYcqnRC/0aZJGYf9jGOzDmn/YZITZH82fVD8D/3ZZ93lx0ddff71UBYPKxZSqBKQ9BPTMW/oL9Nc8JlXQt63tC9hSSVDzD026JDHgtDnBNEwMKgYGhYLoJU8U/Aq9fyzGRftZgpyWSigAXDdhNieameNVhrf41Vdf7aw11k/3hYBykO53iNYYpv1DJFjTbKc7sQu6huuqlyyLIdFaFma6rKHAvL9L90ifA4L4MKV+LEa6RK6KZUTvc98IL7rXrRTiOeyww8y0nxczvm1vMgn4fw1LVLIiP629M+9i03zFNbALITSIE1iLW0rbSlwD+m8tFSM1l9eTkUNfCJUU387cPfLII5MK2q29pwME6mydqL3PA1OBEUlTogNYkbT8EklU3dGWYEpE5aM9kWaFWZ/a7JhZpYVUaSPK2KVY+aYgHrT9cyVqJ+HnDQsByQKS+I3JgObv8/zN7N/eMyY/ro8ggLtJ869KloEegCwlb5Ur/yXNcfzngzVnaUFMqeEqqgcSeIpmnWhGZw56kE3MIuA/X9OeeUrQHI1rSGcSUyI6/k2tp3dk0qe98BqtJcrgdsANoW2AhGzq7X9Z6+8fJaj0p9ue7qMH6bEELIbjYZoC+sQ1FYD+XqoYBi4K6ulTxnidmCT38Y4Y5Xtyo9XIrL9JDHObzKh1FkOTH3O7ve4yXNtfxaXGS8hOCv6pBJyGhdSm5nUQiAr/Zy7TFIq1tY3eEMxlLAJY2HC7aV4v07yu0fpdp/Nt1YaQvRf3gFxWrldEtuhWMJo/A0qFNQE72hIpVV2pqCZtyeUS4zel2hrBUzQEIdDIt2QVMRs1klQ1JT8AiVXDmopG9ql+gL9yRM3nn60ZXODn8ZkCEhaLZs2aVSLtoTMxKnQYDNIDsQQQKDhUmvaQIDOF2AAC6fYDez9XkwWmemE3+I8KdpgwG3AJ4KeUifIDmdIXa/ubtOpl1AXQq4j2xlpjB0kw+YKEkS/oPv6O5lY6D64yLBFo+gcUvWpq2MLmfZimtKJt9C+gEI8Y5BIJIstosIMVQsySbnq4KcjN360MhT3cd4FPCXu8DCkAVhDYrfot05oDfy7jBWj/2fN3vocVwvDviYJ1eE5zWLC2nLuNdaT5XYdrIKi7gQCwBNeA3lfLqkXGQK3et06ePHlzcHxWBIC8Bn/ypyU5VaqZRjcxIHz4wwPTaF9M+2ge2uj3TSEVNP3OeidCHzPpAXWcEzUP/70pk76fEGGJrylpkd+p8EeeP7X91dXP5flbwF+GKzlmhxNJT3aK3ALVAltcVT017/tK4B1OUB3V8oiwJ1UQU7t3B1By2s/jZODvrQIwND+Hg3eqBmKypNztKjEqopk3aL/dWMr0Xq4h6EMaLEWucKHp/I0pe2Gm2JRmFLqe61oYaPq7KJyi6y6j5K4sD6QjLiUwUYLAGrkfYIrU2N8pjQjzaFYYYsymUywftyXwb2qehvl94j5NKX3NzXksVEH8iuvSSW8Jqk5qW01QoH7bKKvARoIFaRktd9vHEsI3ym28dcKECcSyZPTKO/BHi1C0fqk0eNfjWwTrT9CeQB//ItoHwVGUCO2JZh+0/OwkJoVPFHPoAQRLjChOBur85qM+fa51c0AftiD484lxUt53HZq/wN+V9zXwz2j+xvpgtGu5uMpVm6KbyuUOULncYbIIHCpBACFgsICYEsLdtHWR4It7i0A7bP+f2f+DF3M1PLfDLi9vCYBJ6fedWm8wqd1aA3uD+AL9VYxA7VJf6Vng57sXMhLdD+FrwwCJN8DKIE1/p861ReffikmUgD0Jy+8L4N+Xef8DmT5X633TiSeeWKtzRL6CWqwnZ4QfPgz+QYW/o8M+/5aAPdmjpYMFCfO/ce0FcxprG4GCLo2QwlyyAlCP40O53N6lOieWL63vNbLCUZSKlEHafKf9yjvwl2mvVGbHXoA8zVIoryuwPyRoAtJPGgiR+tQEJ6qYgiH4PhtNj4lm/fCgJdOIPEXZz2tHML3wcU199kzQMz8P/mj+YmIG/mlPVzsgAbQRhDt+85vfLJLZneJUFAVy1QPlGuhPnQCtk4OCKpQHyRpGympnCQCNLoFEISCRwl4QCOYwQI22ss9XH+R3fXfrK7H+vj822ZoLWdPoTEhpVIqlrJJG/yFpegL95UGxFCrzUZAI03+9hJs9VozH1kEmFGgJ/MPKoBeKuZ7n+8m0/PAxTSmTiUJweH2EZXHWGBtVBQX0e7Q2XFEu6m8I/D+gSiWBrloTH2tN1PzHf/wHhbnSfuUV+BP89Morr3RTLf0viAkcIWb3ZaKKgx7fFOahaAo1wdH4i8LV0MJaTqLkFZb0wszO/461wOcXMyj6fbcYVr223Qy0rlepa7nSvskmhoF/2vPSDkiTArjAggqC5bIAdCZllap6Av/BsooNR1AmOFAWsf5aI7jBSCekuBUprI1XSwTsxPmczPoVZmqJAnSy42FqQbVBF1SobRUZBRQaklnzQ/k3P6XnAJXTBPw7dc5d11xzTbt3IUxzSGz3iFIgHfAPK33MbWnjpMWCAQSHu5RV1o9PqU0G/GEFMoxDyZRGrzDyzlqjhgDXxApAoCBZLRIEEIxxhf1VVrG3Lr/88g9lFfNtulOmel6B/wsvvFD5zjvvDJCP/1hFPH9TZv4jyYUWE3MV94hy9rXBoUAyE38y80yYWp65hfbbqwF1+ZukbWD21Lsr7chnYgco/SuG2oN4gmTSnQ+0Crr6rTPNP+X5aTu2ggKUqj7qqKNK5fuvJENAlgC6ChL8OlxrZrgsAqTjDaJipYQBqlr6GJj9+EHY/+8/+3Xh15b/nkyATowfCLSZBq2DXdJoqCkAI1smoeUjNH4xso/lElshwN+sz7Xy5ZP7bC+jQFYpEAJ/GvuMlyK5n9k/DOAe/Jm7+tygubkxqB3RUVa0SuJqtLnaFSiczbmVk62VZIKBX0v+2gS++t4d1A3Q9bECLBOOzFYGzky5j//SmgJWeQX+TzzxRJe//e1vQ9VCd4xSi/5JzOzwwLffGGAUJmaiFOaJ6c2QyaS0cOAT5k0ds1u/OamLyk1iWpRwXKmNKk4EPdHa98sEWuleeviBCwcJJoK/+fyzupbtZE1QIIiP6ShfIUF5XTVP+2obKjfAIRIIvqj3z0koXwBTGwAAIABJREFUGCJBgMBBelPsVyfAax9ekG5JcPa3EV5D3mIWVENroPyutBbM+OTnv0WPdGkwfF4jwKdG+rZ86Ihmky5/KQD405fl3nvvpbFPs+Af0sDRvrfJz/6OBNUara0GgT/VYIkvoxJsNwkBLl080QUQdnulYhlI3McrpEFsDlUtqcpJgaAZ2v737LPPniGL2abjjz8+Ld9/3oG/ApyGqRraGJk2TxT4HyHik6vvIvfDwA+jCmsnYXNkMi0l8F1iZiGgCbB3Fc8kdW3QtkbMi3KNFGhYK8JTrYn9Sqn7L4Hkn8RIuZehYRMQ1/FmVD57zV/gPx+fv1X4y18Gkk93jnXqkUceKVONAMpTkw5LwaDhdBMMWuoO1+8Dgz4CWNFcih5WNC+4hrX45hhY4pynBjqavjYqna3WuqG5zodE8AvwKRyECXO9QH8HPv2mKgjmE73tXqNNgVTB31txWQPUvdCcXQngStt+V3iwSeBPG+5eFIrT50Ha6OzaU+uHSpbluIJp0S2McPVjwq6BMC6EhYNES0CiGy1If92ltbJBtS3+LCz5/RlnnPFnWfk2pLt28g780fzl+x8jRnaStJcjFeiH2XI/c4snbBj8wyaXkF/flTfFnEO0MZo8ncDIKxazWqvvpDVhmlwpnOczQUebJfnhe2EwqWE+ZM6cOZMUYT0yyHF2PqCw5u+vDfhT3hfwt5a+0WYQhXp3ig0oE/B3Jk1Q5XcHUC1QjONQqvFpLZEuSMVLsgMwaTp3gPdrJvooEwVuL1STGUA8DD3QydNHWCaYT2tnqdbOB/j1tS2X1r9e62hbtjoIFuqY2XNllwIe/O++++5pSpkdJ2vYiMQKf+G5jtUKq6/m7Pvi2899+ctffk1zuwYhGQFAmj8CwGAJAoP0GRcw/WCwptHxlc6wxKKRnUYVwcbGXGErcaK7IFk8AOuNGADdC8XitkgQ+aPS/n5/yimn/EkVY9elWxEwr8Cf9qAC/mELFy4cLc1/lDSXr4p5UdXsgOA+L7V5TQSJKQz6mPT1G+lFtC7djg9fIE9v7yXy6yyVVrIE0JdmQoET1xhEA7vDS1cwxRtvvLFagzn0mWeemaIqUaPFVP8xiDs4oIQp16a8r6/tb+Cf3QVtZ0ufAo899hiBgbTaHaTtIM3hQ/X+hSAugLx9yvKSxueCAsMMyVsEvADgTZPsh+VMWv5WovS10SyINKX3yNOX2XSlKvKt1ffN6Zop039CO8IocCAFPPjfc8895yh2DLP/AeDvcYP5DfijEGrO/lUp2r866aST5hx++OErRo4c2aBKm8WKQ6sA5HWeXlIAe0uIpuZMv6AzJ8W4KMRFm27XojtIQXdKorewhRXGxDsOrztwLMga2yol8k/K/X9JFuQ/ah2vU4yMq7qZ6iufwX+0NH/AHzPlAYEWieAfmPVd0B4+E0lPW5Hm0PDFrNbpt7UUDyEASZHGlFpch2lHg7LjK1/5Sr0YVsPMmTP3htKMOv7Xf/1XpcB8gEyqp2sSjRX4HxlET7s86kTtP2jpi68Gs/8zmP0nTpxYo3uzAiWpzljbL2sUIENAJyvT3K0Q8PcOggIPpmywLAAHyz2AJWCgGEs3nx4YBvuwuRLw13ohbW8nKXoCfdoE0xjoIwnQSyU8f8pa0/daMaxd8uunHZ2ctQe3E8WaAqmCvycS4C9hdq3m8ALN3f9PPHvOpZdeWgOL19bx/vvvLxZmlCi4tkyAX661UMWakTWNvhyUlyctfZC+9xY+sFGAC6tAlSwCBAwSK+DwItEFkOgeCMz+DVpjgP+fhUsvCfT/ICFibSzA/8033xyzZMkSwP9IERX/ygFmfw++AfEI3Nsj8K0VuG/EBKnBXBlsq6ivTN9lApHEnGiusE29vrdrAHc11wL01ltvrdC+/f77v//7DDHQcWKaX/WFVLzwEWaWmGvoKa5Bmwf4n3nmmbMN/GPNhyLx8AQGioFVSHjtqq2X3AHOFSBG9gW51/5R7wfJjNkj3DQomeZP0x0a7mhNLJKGv1DWszeJShaDWq3vW9RZb7tp+5EY8ljfRBLwJ9q/ya5+Qb49lVlx1z556qmnzjnvvPNWJyMia0lxaaWyCHSSdbpS66lKuNBLAgCl5WkoR1xAPwH+AK2r/kFBuj76nSJcxayxxNTb8HUCsz/gv033M11m/5cU7f+KzrcmduAf1vzDfv0w+Ac+yDr6KYsJfSQJ7h1FFv+NJiX6TpvFLfpcO2bMmDodl3LlMMBf2k3/Bx54AM1/nPz+R/rSwTDHsCmH7wQ+YV3A5y/zkYF/rFlQ9B4exvWb3/ymSGuql7Jphsoa8CVl1ozS+1exAjQF/l47wXUmE/9Sgf3/CuhnyTf6Nrn655xzznazbkVvvON6R4sXLyb4testt9wyDb6t+T1CwNwk+AtwKbbjNH8pbU/KajVHcxrNP6WX1lXxW2+9Va41VUU1TgE+nWUHKtPAudkkHHxJwvZw3QPF6fZzGSdeAPCXotogHKlV4OF0zP6B5l8TC/BftGjRWJlYnOYvQlKv3/lPkr0AXUluVElaLcb0tiSlV1Uh8HVpJZ8I+DH118pkQ4rEnnRTjMLgrwYRYwF/ygnrXLrsgeCvQXPgr0k0TwEazyhKc45p/imtH9upjSgQWAFKxJSIWv6ctKTT9Jlg1sO0zvD9O1dhWPMPUvuI6t9EJLQY0m+PPvroP9MMSEJ2Q3PWszZ6LLuMUaCRAi2Bv1cceUew9eCvufwqmv+kSZNmK/YrHfB3QrVOVyxho1gAX67zVmtdDZMQ8mVZ2o5S4OExBNtKAKjw1w37+r0FGfCn6h/uM6/5C7deEe7EA/wlRY31Zn9pKUQlJy2uABEJ7KNOMjWRNXizvvSlL/1BDGqRGNS6z33uc3WZmCEBf2k2/R588EGn+UuCc+BPMGBiqiHfA81/NeYjA3/jRlGmAMGA0k4GPfroo2eLOY2SoP0PtAumN0DYwuZTkWjGg+tMc3uhGOSvJdROF4NcHuVntHuLJwVC4O8C/hI1/0Tw92Z/KW2vyar1hCzEc6688spVraUe+CDXQMnvfve7HnINfF7r6+j33ntvovDjMFnYnHst0Yrt7ynQ/PfI4hxP8A80fxjSkYlm/8QcZAaO0oiKNH5XjOmlb33rWy9oAN/NhinSg7/8padLihtLACLNTTyDTAz4M/Bv7XKx49qaAvhFpdH3uP7668+lEIqsWkcQ+Z84t/19UfJC/n6sWn+RUP3Ud77znVnSkNa09X3b9YwCLVEgDP7B3N7P7J8I/j7gT+7aV6U0Pjlq1KjZmYC/vz+EgBtuuGGIBJCj5V6bKiHgCFnYBmidNQaLeytAIvhjsdb9TJcV+6XYaP5K8yPPf6wkJmf2TwP83xH4vzB69OjnpPl/oICNnS1Nkpb+B/z16vvwww+froEb1xL4I4Ro0FZT4c80/5aoa/+3JwUAfzGn7j//+c/D4E93TKf5JwrZAfhj1XpVftGnL7vsstlikmvb8xns2kaBZBTw4C/+fTbgL83/mLDPvynwR/PH7K+8+lkXXHBBqzX/8D0F4P81gf/Z9KtRWuDANMB/BuAvIfsVYU/NVVddRZe/lF95ler30EMPVStoYogEgHHk+Sem+iVjSoHmv0v+/bfFmJ4fO3bsc4qs/FApexmDv0C/XLmbfWUiRfN30f6B5l+cLNUwBP6Y/Z81n3/K89R2bGMKhMFf/kgY5JHyVbak+TvwF4NE858jJmng38bjZpdrmQKAv4rFdVN537O85i8+TmO2xkqxYattoPnTit2Z/dWGfbaE25UtX6nlPQB/zP6AvywAR+D3Twf8Cfg7+eST/6CYtlXCtsIFf+UlV6lv+VCBv9f898vzbwL8Ka6zE/BXsN/z8kU+pyDBrIG/BqqPhBIP/kcZ+Lc84W2P6FMA8Ff6U4/bbruNKmgO/DH7wyATBdug8hhmfwP/6A9t7O8wVN43LfCXYPsXwH/ChAmzsgX+cqsNlbZ/tGrInCMF8iu04k4X/KVE/kFKbuGDvwIlhqi2v4/2PyoFsz/g7zR/SW7PqzrTcwLoD7Kl+SeAP5o/plHT/GPPYvKbACGfvwN/MlnQ/FsAfwpYLTDNP7/HvtDvPmrgr1oAx6hE/DlaZ4dLEKAGQKo+/xlo/rEC/7/85S809hkjornyvr7CXzOa/y5F+mP2f0Emm2dl4ska+MuK0OfJJ58Mm/2bBP9wwJ/8os9akZ9CZzP5+3xJwP+rNClpCfyDjpVPT5s2bbaZ/fN3/Av5zjMA/9el+T+eTc3/5ptvHipzP+BPzYHDZfanRb2Bf+IExOwvX83gV199dYzy/AF/NP9Uwf8dzP4C/+eUTvG3bGj+Oke5cpl74/Mn4E8+f8z+LYJ/wCCtyE8hc5g8f7ag53lPlbBGI0Hzbwn8d2P2JyJamv/Tl19++SwL+MvzSVCgt99K8F+P2V/F2Z6Qb31mtsz+CqgdRsDh7NmzpwlDAP8+Bv5JJt7LL7/cWUQaolQ/NH+i/b+WDviLMb0gqe3ZHII/Zv/ypsz+XvM38C9QrlJAj0Uwq4pi9UgT/DH7v0qqn8B/9oknnmipfgU0JwrlUcLgr+JsKG3HpBDwt158+3UJto9nG/wlXH9DAX/nCPz/0cC/iVnmwV+1/enqN0aDlir418vnT6rf80qLyDr409hH0psr8hOAf0myaP+Q2X+BJMhnzz777NmyRKyy0qeFwlYK5zkAf2nyPe+88040f0qgfjVoSdpUwN9uRRxTuvpVze2nr7jiilkG/oUzHwrpSQKrVre77rprahTAX2vrG5j9tc4A/95e8/cYEq7054v8BHn+8fH5A/7z588frIC/0TL7U1QnZfCXdd6Z/XMF/qEiP2j+zYG/6+pn4F9I7KTwnmX69OnlCj7qpWj/s0OpfqXJClgR7U8VTYH/WsCfPP/zzz9/1rhx45I2Pyk8atkT5RMFogT+P/nJT4bLff31uXPnnqt19g9acw78/ctX0OR7kFVDbf89sQN/So6qDOJglfcF/McoLQLwr04h4K8+F+AvraiTBqJ3UOGPIj9o/hUtgX/QIOIZ0/zziWXE614Bf6X69ZJPkhKoaP5E+zcJ/tJI6DSG5o9f9Cl1Gpul7mcp1z+PF3XtaduTAhmA/xua2wT8zbzoootWZOMZAH/hGJo/4P9lA/8mqAr4f/DBB4Pk88fs7zX/VMB/l8r7viPQddH+KvKTlYC/BPDnfgD/ylTAH81fJYZnmdk/G0vIzpFtCgD+0kB6Kw+Z4iMpgT9mf4Ki0Pwl2M408M/2qNj5skGB1oK/8OOvKs72WK7AXz7/f5Ag0CudgD9lH/xeWWOvFHyefwL4jxHYHp2i5u/AH5+/yvs+m608fw/+auk7BZ8/udAG/tlYnnaO9qaAMmsq1DmsV5rgT89zwP8pNfWZqbVmmn97D6Rd/wAKRBH8vdk/HfDXWptJeV8J2a8UfIW/wOw/8J133hmtrn5j5Stpd/CXubMXtf0F/rT0JdrfNH9jOHlPgVaCP139XGMf5fnPVHxNVuqf5z0x7QEiRYFWgv+GkOY/I9tm/9aCvzT/38Witn8I/EcB/mj+KrLTJQWff840f7Sje+65Z0rQ2Mdr/qXNRPvT+cxF+5vZP1I8wW4mRAEDf5sOhUoBwF/tqrsrVuvMNKL9N9CuWlatR2X2N/Bv68mRBPxHCPxT8vmT6ifQzbrZX4GEPRUR7Vr6Bo190PwN/Nt6ctj1skqBVoK/mf2zOgp2slxQIGrgLyWWPP9zpUB+WWb/xlQ//+xNpfph9o+l5q9of6LrUzX709jHBfxl2+cP+N9+++1O8zfwz8VStXO2BwU8+P/0pz+l+YnL828p2l91AdZqjTmzvwX8tceo2TVToUAm4C+wfUwprDNUx+LTVK7V0j5Bhb9vYPYPAv4M/JMRLaz5pwH++4LGPk7z/9a3vvWsNPOsdPUj4E9SWc8nnnjitFB5X9P8W5rx9n/kKWDgH/khshtsJQUyAP9FAv9HIwL+ddL8Z5jmv3t3kQC9QxONfXIK/hIsejz44IMu2j+o7W/g38pFaYdFhwJh8F+2bJmzapnmH53xsTtpPQUKCfyJ9j/55JNflhW85qqrrtqVDlU6prNze++bgebfaPbPtuYfgP9pAfh/LYj2N59/e08Wu35GFGgl+Ls8f+VCW55/RtS3g3NJAcBf1fK6K1Yr3YC/RQrUflSu46ya/ZUl9vWgyM8/+iI/VPNrweeP5k+q3+8M/JvX/B34U95XJhta+n6Uja5+mP1bC/6KGn1m6tSpsyZOnFhjtf1zudTt3K2hQBj8FRHt0lil+Zc1Vd6XCn/y+Tvwx+dvFf5aQ3U7pi0oQAErzeXualp1puJZCNROpbHPBlWvfFONfR4x8G+LUUq4Rivz/DH7O/CnyA9d/bIJ/upv3uNXv/rVtxXtj2n06FQ1fwP/dphAdsmUKRACf9f8xMA/ZdLZjhGngAf/W2+99YxPPvkk1a5+kQJ/ldLeLmFkRhw1f9/YJ5Vofwf+qvD3togF+D+XLfAXgyyTr6XHo48+epqBf8RXvN1eWhTw5X1Ve3wq5X1TAH/X2EcC9muY/U3zT4vctnMbUiBq4I/lYdasWd+hpW+qZn/AX5bsGdriY/ZXdb9B7777rq/tD/hXtVDkB/DfEdT2f/6kk04i2n9JNsz+rQT/1WKQrsiPmf3bcMXbpdKigG/s87Of/ewsgb83+3dqxuzvWvp6s7919UuL3LZzG1IgouBPqh/g3yeV2v4B+JPn/6Jcx/EI+MsA/N/G7K+Av+eyDf6//OUvT5NmRMXBESmY/R34Y/ZXQ4bZ5vNvw1Vvl0qZAh78b7zxxqlE+weav4F/yhS0HaNKgSiB/8033zxUwvUxs2fP9pq/gX+yiYPPP4rgr9r+3yba38A/qsvd7itdCoTBH59/UOTHwD9dQtr+kaOAB38B7xkEs8rs/nW5gjspfqvIR9n7d9LHi4uLO1RWVubE56/GWUPVo8bAv6VZ4sF/8eLFYxSo4Vv6tmT23+vN/rnS/A38Wxo5+z/fKNAK8K8PfP4u2t/M/vk24vG53xD4nx7U9o8C+GP2P9zM/k3MQ9/S98033xyjCn/pgr83+z/frVu3j9ItiJDslrzPP1XwJ/CwS5cuaxSksWD48OG/FYOcPWrUqNWW6hcfxpMvTwqDVPOTnjfddNNUyvvK7H+U0qOa0/wB/zUKqnV5/gb++TLS8bvPJODvU/2Km9H8N2puLxLffnTMmDHTs1XeN6T5twr8dU+/mzx58v/GpcjPYJn+x3z88ceYa76mgL/OLQT8ec3/LWn+L2jgnhOTWtKO4L86AP9nDPzjx3jy5Ykl0JYrb7/nXXfdFQZ/8vyLEztWwjCV598I/gpmferCCy+crZoaq/Plee0+40OBDMD/TYH/I1EBfwH/TKL9DfybLvKTc/CXReJUmWzGSxhpNuAv0PwN/OPDZ/L2SZOAP0V+0PwN/PN2VO3GoUCEwZ9o/76pRvvHFvyXLFkyVoESKWn+5eXl29V9z+X5qzrT89nW/A38jakUGgUSwJ9UP2/2bw78V9PVD7O/zKKzTjzxxDWFRhd7nvyngK/t/8ADD5we9K3wPv+WzP651vwN/JuaXkGFv8Fvv/32WPn8x6QD/srzd2b/HIK/qxTVXKqfaf75zzji8gQe/O+++25X/zwV8JebYLUE7NdUAhWf/+xJkyYZ+MdlwuTRc7YS/HMa7a/a/tNWrlxJwF/Kmr9M/jNj5/PPAPyp7f98RUXF0mz5/BVz0F1d/b4dtPQ18M8jJmC32jQFAP8eehHwJ6aUCvjvCsD/L/j8p02bNvuUU05ZazQ2CkSNAoUE/rEq8vPee++1VvN/c8CAAS+ovG8uwD/s8+8sv2jSrn6Jmv9ll102a+TIkWss2j9q7MHux4N/0PzEtauWz7+8GZ//fuCvuU0mi4G/TaXIUSBq4L9hw4YRKvJzbms0/9iA/8svv9x5/vz5g19//fV0zf51mP3lj3x+/PjxL2Rb87///vtPpba/0i3Q/A38I7fc7YbSpUAG4P+aNP+nDfzTpbjt31YUSAL+pPqVq8hPcz7/RrO/qrJOv+iii1Zk435J9csA/ONT2x/wl4Q0ZOHChWOV6ofP/6hUUv0U8FengL838flnG/x37tzZTelQgP94A/9sLAc7RxQoAIMsKirqIeZE21MyWVLR/Gt8Y59rrrlm9nHHHbcuCs9i92AUCFMgouCPz/8rqfr8VS+mTmttZmy6+nnwf+utt8Yq2n+MwDYd8F8E+CsI6YWysrKPs+Xzl9TWTbX9veb/ddP8jdEUAgUyAX98/pdccsmcsWPHGvgXwmQosGeIMPgT8NcvlVQ/A/92Bn91Bizr27evgX+BMQd7nA4dwuAftPT9Wgo+f6f5A/7f+973Zh9//PHrjZZGgahRIAz+1PZXJgupfu1t9vfR/umA/wz5/H8nhfaVgq/w10rNf0+Q5591zR/wV7pF1/vuu88F/GkAUtL8lZ5BS9/fEhEt7cgC/qLGHex+koE/Zv+K5gL+VD+jRnP7VVVBe9rA3yZRVClQaOB/2mmnvax4hZopU6bUp0Pzjuns3N77ZgD++PwB/xezafb/xS9+oaqmpd0Af7r6SYL8Ripmf8BfEttvL7300lknnHDCWov2b++ZZddPpAAMUmV7u99www3O5x/k+TcJ/nKl7VSqH+BPnv9TV1999RzT/G1eRZECzG3x6W733HOPK/KTp5p/LT5/NP9Ygb8a+4yjyI807a+mEPCH5u/AX4zpBeUev6BApk+y4fP34H/vvfeeIvBH8zfwj+Jqt3tKmwKZgL+CkJ66+OKL5yit1sz+aVPeDsg1BTIBf1lsH6a2v7JZVmbjPkPR/ukG/NUKz2YQ8CfwfyU2mn9rwF+pfs7sb+CfjSlr5yh0CoTBH5+/hFt8/qlo/q+KIT193nnnUeRnQ6HTyZ4v/yiQAfgvkqb9iDLGcgH+aeX5K+DPwD9VzT8A/+fFkF7MtuYvC8DkoLHPsWb2zz9mYHd8IAU8+P/sZz87E/Cng2YK4L9KtTRek8//KYH/HAN/m1lRpEBrwV/KIy19DfzbY1C9z781mr+i8heKMaH5ZxX8q6uru95xxx2nGPi3x4ywa+aKAiHwP0PgT56/gX+uiG3nbVMKFAD4NwSav8vzN7N/0y19nc/fg79q+7+oCn9Z8/m3EvznS4L8rXKhZ1vAX5uue7tYihSAQSqIr9t1111HY5+UwV/a0asyjWL2N80/RVrbbm1LAQP/z+idl9H+ixYtGq8Kf6PTDPhD839eqXUvqhrfMlXl25XplCPgD/C/7bbbJhPwJ+3ouBTN/gb+mRLfjs8pBTIBf8z+3/nOd+aa2T+nQ2QnbyUFDPzjBf61ivZ3Zv9sg7+sCl3U9tRF+6cC/hIWalQbYIFp/q1cuXZYm1DAwL9NyGwXaQcKGPgb+GdF85em30XlfU+RFSJl8FeKxnyK/JAOZWb/dlj9dskWKWDg3yKJbIc8pQBzu7i4uOstt9xyRjp5/gT8qYbFw3Idz8hBql860f7x9fm3wuyfM80f8FcHNMz+E9RoqEWzP5q/gX+eco0Y3baBf4wGO2aPytxWQzYqsxr458vY+2h/A/98GTG7z3ylQKbgf/nll88ZPXr0xnx9frvvwqWAgX/+m/2p8Hdkinn+TvOX2eZ5VR17UeVKl2cr4M80/8JlEnF+Mu8Xvemmm8jzTyfaf4FiWp6+8sorDfzjPIEi/OwFBP5U+HtJJev/EJvGPtL8JwTR/imDv4r8/JWAv4iA/zz5/J9R/fPZxxxzzDqr7R9hThHTW/N+0R//+MdT0wD/laT6Ud73u9/97lzT/GM6eSL+2BEF/3TK+3qfv4G/tO8idRvrIBDtoGYk+029kpIS8vxrcwX+Chyplu/I+fwlfX2zpVQ/fP5ijvMUOPLb888/f85JJ51k4B9xZhHH2/Pg/5Of/MQ19lEmy9EtVPjbocY+qwz84zhb8uuZIwz+h2/cuDGVlr77gX+sivxESfM38M+vhW93mxoFDPxTo5PtlX8UMPDPQ5//r3/966qFCxcOefvtt8NFfipN88+/BWh3HG0KGPhHe3zs7lpPAQ/+aulL6eqUW/rmONUPs79p/k0NK+D/7rvvDnn99dcTK/x1zBOz/47A7D/fzP6tX7x2ZO4pkAn4i0k+dcUVV8xR97NNub9Tu4JRID0KLF68uEz5/V1vvfXWM+TSAvy/UVdXV662uMXebezfcSXLutuhsrJyg4F/enTO6t4e/N94440JS5cupbyvD/hrDvwbAp+/q/CX7YC/NM3+HvwJ+Pst6VDHHnvsegv4y+o0sZNlgQIe/K+99tozg6ZVLfn8d8rn7wL+DPyzMAB2ipxRIErgf8MNNwyR9WHEggULfJEf8/knG/kw+BPtryAkA/+cLRE7cZwp0ErwJ+BvgYF/nGdO9J/dwD9Pff6Y/dH8Dfyjv8jsDvOXAq0EfzT/Bapg+ZSsWnPN7J+/41/Id27gb+Cfldr+VXqpq98p8hu58r5Kh6pS/EFpOO2Qz2ydOnVyZn8VQZl7yCGHPGNm/0JmMfn9bAb++T1+dvdNUyAE/qeTxire/XX5/Cvaw+dvZv8UZypmf0X6D6W8bxR8/tOnTy+RP7Q6AP/xAv9vpgD+q6QZzaXID21Px4wZYz7/FMffdms7Cnjwv+66687A5y8GOaKFPH/v8zfNv+2Gya7UCgp48L/jjjtO/+STT3zAXz6C/0zVjPldLPL8Q+BPwN+o9g748+B/5513ThaDRPNPGfyHDRv2jKqgzRk5cuQGC/hrxQq2Q3JKAQP/nJLXTt6OFDDwz1Ozf6D5G/i34+KxSxc+BQz8C3+M4/qEBv7xAX/K+25Ted+sp/qFzP6TA59/qpr/nOHDhz9z7rnnEhRlmn9cuVCEn9vAP8KDY7eWEQVkQS6rqKiVzjeKAAAgAElEQVToIrN/OM/fzP4ZUTXHB7fS7J+z2v4e/G+++ebJckGM37Bhw8gUfP4r8fkr6O8Z1fY38M/xnLHTt44CBv6to5sdFX0KAP4NDQ1dfvnLX6YL/gtVnO2RcePGzbjssstWZuNJMwz4cz7/WHT1ywT8c9HSF/BXwEiV2gNPVs2BCSmA/3ZF+6/SgM3B5z9t2rR5pvlnYwnZObJNAQP/bFPUzhcVCnjwf+ihh1y0v3g3Ff5S0fyjCP609H2l4Fv6JoA/Ff6O2LJlS2fV9m+xvC/gT4W/iRMnvqABXy7AzjjVT9XPSrp27Vr1+OOPpwP+TvOXAPDMeeedZ+AfFY5g97EfBQz8bUIUKgUM/PPU5680v2FvvfUWRX6I9o8M+GP2V7T/8S2Y/dH8V8rkP0fbswb+hcpe8v+5Wgn+VPibr+1pq+2f/3OgUJ/AwL8wwJ/yvnT1a2/N/2SBP6l+KYM/mr/8RvNOOOGEjZbqV6hsJn+fKwPwt/K++TvssbhzA38D/6yY/fv379/5F7/4BQF/KYM/Pn+i/S+++GID/1iwm/x7SAP//Bszu+PUKBAG/6ClLz7/yhQq/JnPPzUSZ38vfP4JZv921/w9+AcBfylp/gr2m63tWQP/7M8RO2N2KJAE/H1Xv5LE0tW0Py0rK6PCnzX2yQ757Sw5pECUwP/6668fKsXx6Llz57amqx/R/vEJ+Isi+N9///0nk+evaP9/SsHnv0LA7zT/q6++et6IESM2mdk/hyvdTt0qChj4t4psdlAeUCBq4C/cGDF79uxpK1euPHzjxo3ptPQ18G9Pn78a9FTefvvtJ69evXpiquCvYD+n+X//+9838M8DZhHHWzTwj+Oox+OZAf+SkpLqe+6553SZ/elb0W5mfzR/A/8U5l0Uzf49evSofPjhhwn4Sxn8leo3W5q/gX8KY267tA8FDPzbh+521dxTIAz+SvseJ5ftsan4/MW3/0qRn7Fjx87MVpGfBPD/ijT/vvX19R1wpfkXbjZe/FZaWtpB1QkbunTpUqv7iafmT1c/RdeT6teu0f6A/2OPPYbmj9n/hFTM/gb+uV/gdoXMKGDgnxn97OjoUqC14K86MX+V0vbIqaeeOuOCCy5YlY0nDIG/9/kb+CcjbFjzjyj44/Ov3rt3b2liUBTfO3XqRJ7/CgP/bCwbO0cuKWDgn0vq2rnbkwKZgr/asM+48sorDfzbchAzAP9tqvC3KBcV/gKf/6SgsY/X/MuaA398/gT8XXPNNfMt4K8tZ5BdK1UKGPinSinbL98oYOD/2Yh95kzIk1crwb9BXf1qcwH+up9iafOVKvN7Mql+8tekBP5Kz5hFwJ9MR/NHjRpl0f55Mv/idJsG/nEa7Xg9qwf/e++9d8ry5cup7Z+Sz9+b/U3zb4f5YuDfDkS3S8aSAgb+sRz2WDx0GPwp8qN4LQ/+JT7Qzr9jwS0uLu5QWVm5IWrgrzLas8jzP/nkk1+ORWMfn+efhs8/55q/gjYmkeqnAETT/GPBPgr/IQ38C3+M4/qEBv5m9s+4vK83+wfgT3nfE4No/2Z9/mb2jyvbyZ/nbiX4r5Q28qq2p6yxT/6MddzutEDAv07rzKX6xVXzp7xvRQtFfnKq+SuWoOKf//mffWMfA/+4cZICfd5WgP+OoLyvgX+BzolCeazXX3+9VJbjalVmpchPPpr995DnH0vwf/PNNyeqpa/P829X8NeCqLjhhhsmUeQnHc1f6X7Pnn/++fPGjRu32cr7FgpbKZznyAD86epnLX0LZyoU3JMY+Oex2b8QwH/AgAHPXHTRRfMN/AuOtxTEA2UC/hJsn7r88svnjh8/flNBEMMeoqAo4MH/gQcemLJs2bJwtH9zAX/rQwF/M9s5z980/6DCX95p/pRllHb0rIF/QfGUgnoYA/+CGk57mBAFPPjfd999UyjvK6vtcUF5XwP/qM4Un+oXRc2fIj/K8/9WCwF/dUGFv1kG/lGdZXZfUMDA3+ZBoVKgkMBfxeJemjx58itVVVWr1HMgrSD2vCzyEzXwv/HGGyeS6mfgX6jsIn7PZeAfvzGPyxMXGvifeeaZr6hLoYF/uBsSk1lEyWm0f9euXcv/7d/+zQX8GfjHhX0U/nNmAv6qXvnUD37wg7nHHnus+fwLf6rk3RMa+OdxwN/bb789acmSJaOi4PMH/P/93/99okpEAv4nmdk/73iB3XASCixevLhMaVDdrrvuujNWrVpFz/OjNbcr1LSqJLFvBQJ3WVmZT/WbL/B/2sDfplVUKZAp+E+aNGnGJZdcUpON52tlV7/GgD/M/rHQ/B966KFqBWgMfeONNyYpT3OUtG1a+rZrwB/g/8Mf/nCimCOpfgb+2VgRdo52pwDgrxbVXSXYninwH6f5PUJ9xiv27NnTHPhT5GeBGNJT//qv/zrPNP92H0a7gSQUMPDPQ83/ueeeq9bADVOJ34kRBH8q/I1KRfNXVz8X7X/hhRcusFQ/409RpEAi+EvQPnrnzp2VBv5RHC27p3QoYOAfH/DfE3T1W5jtlr6U9w1p/mmD/9VXXz1/5MiRW6zITzpL1/ZtCwp48JdV6wyZ/8mFNvBvC8LbNXJOAQN/A/+00iKSzUjAX9pQ+W233TaBgD+ZSdPS/A38c77O7QKtpEBrwV81LJzP38z+rSS8HZZzChj4G/hnBfwrKio64fNXsN+EAPyrFRTVVGMfl+fvzf4G/jlf53aBVlIgE/CXAPD0ZZddNs8q/LWS+HZYTilg4G/gb+Cf0yVmJ89nCmQC/hJun7rgggvmqfjI5nymgd17YVLAwN/AP2vg/6Mf/WgCqX6m+Rcms4jjU2UC/upb8ZRSoQz84zhx8uCZCwD8G9TVz7X0jU2qXyuj/XMa8IfZPx3wVxnGT2UWnSXt6Fkz++cBp4jpLYbBX+m141ON9sfnb+Af00mTJ49dIOBPS99ZBv67d3eUn71DuPiIn4eq8GfgnyeL0m4zOhRobaqfgX90xtDuJDkFDPzz2Oy/cOFCV+RHefVfSaHIj4G/cQGjQJoUMPBPk2C2e95QIKLgP23lypVfUeB4XxXT6hAuU49Sy4vfSktLO8jajNnfaf5Dhw596dRTT31FvWVWXXXVVWm5svOqsY83+7cC/Lf17t17US7y/M3snzdr3m40DQoY+KdBLNs1rygQYfA/XODfL13wP/nkk1+WW67GwF/SUfiV68Y+AfhTBIWAv9Gq8Ndsqp/5/POKT8T2Zg38Yzv0Bf/gBv7xMfvntKufgX/B84pYPqCBfyyHPRYPHSXwv+GGG4aoguaIBQsWnCuzv2n+Tc3AVpr9DfxjsaTtIbNJgYSufuMs2j+b1LVztScFDPwLQ/Onq1/57uaj/Q3823Ol2bXzkgIvvfRSp+Li4q5BS1/Af4RKWbfY1c+i/fNyuGN104UC/lprMwn4U4vhV+Lo8zfwj9WytYdtKwp48L/22mvPrKmpoaXv0am09DXwb6sRsuu0lgIG/jHT/Pv06eO6+k2YMOFFFS1Zftddd6WVFpFsotHYJxTtT23/VAP+kNieVXTmAuvq19olbMflkgLJwF/BrBWqp1ESrqfhP5eVle3o3LnzSgP/XI6KnTsbFDDwN/DPNvinVN43iPY38M/GKrZz5IwCBv45I62duJ0pYOBv4G/g386L0C4fXQoY+Ed3bOzOMqOAgb+Bf3uB/3Jq+5vZP7MFbEfnlgIG/rmlr529/Shg4B9j8N++ffsyBTLVZzr9vM//hz/84URVZsLnPyqFIj8G/pkS3o7POQUM/HNOYrtAO1HAwD+G4N+/f/8XRo8e/eKePXsM/Ntp4dll84MCBv75MU52l+lTwMDfwD9rmv9//ud/TlSepQ/4q1JEdFliRDTfO3XqVKeAP9P801+vdkQbU8CD/09+8pMzaemr8tVfs2j/Nh4Eu1xOKGDgb+CfNfBXIZSJyoOeqC6DmP0N/HOyZO2kbUkBA/+2pLZdqy0pkAD+46W4HVtXV1cpi3CJ76bn31HaVOyqQ2Vl5Xqliv91+PDhj6iozoxLLrmkJhv3nEl5Xyvyk2KFP/L8c2X2N/DPxjKwc0SJAgb+URoNu5dsUiAJ+B8XgH+xgX82KZ3FcyWp7Z9yhT8D/ywOhJ2q4Clg4F/wQxzbBzTwN7O/mf1ju/ztwVuigIF/SxSy//OVAgb+Bv4G/vm6eu2+c04BA/+ck9gu0E4UMPA38Dfwb6fFZ5eNPgU8+P/4xz+eqn7j4yzaP/pjZneYGgUM/A38DfxTWyu2VwwpAPirVXa3m2666UyBP6l+R1mqXwwnQgE+soqzlXXp0qVKc3sKaayK9reAv6iPswX8RX2E7P4KhQKAvzr1dVMmy5nLly838C+UgbXn6AD4l5SUVN99992npQH+G4JUv4cjlur3u9NOO+0VpSnWTJkyJS2FtmM+zQUD/3waLbvXfKZAa8F/0KBBC4YMGfLUhRdeOHfy5Mmb85kGdu+FSYF8B//y8vIGWS62aZ3RHfYlA/+9ezuEq+r5aSsJr0HEqs1lqp9V+CtMJhHnpwqBv/P5r1692lf4K06sXklutKwEOzp37rzSg/+//Mu/zD3++OMN/OM8iSL67JmC/5gxY2ZeeeWVq7LxeK0p8gP4V1dXbxPwG/jLN9lRJXXbDfytsU82loGdI0oUCIM/plFVsPQ+/xbBX1XQnvrXf/3Xeccee+ymKD2T3YtRAApkCP6PCPxnGPi38VyKqtnfwL+NJ4JdLucUMPDPOYntAu1EAQP/zwhvPv8MJqC19M2AeHZopClg4B/p4bGby4AChQL+1PaXlc18/u1p9g98/hM2bNhAY59q6+qXwcq0QyNBAcBfvvzuP/3pT6euXLmSPP9UzP6r5POfP2zYsKd/8IMfzDWzfySG0m4igQJh8A/SWFNJ9fPR/pEx+xv4R6Cxz49+9KMJYo6+pa+Bv7GbvKdABuC/QOD/lIF/3k+Bgn0AD/733nvvlCCYNR/BfyvR/lprv7do/3YM+AvAH81/tGn+BcszYvVgBv6xGu5YPWwBgP9uov3jDv5f2bJlS0V7R/sL/CmCguZv4B8rNlK4D2vgX7hjG/cnM/AvjIA/A/+4r2R7/pxQIAT+ZwU+/68G5X2bS/XD529m/5yMiJ00WxQw8M9/8D9p/fr1R5jmn60lYecxCvwfBZKAPwF/5QpmNfC3iZLXFCgU8KfIj3z+L33729/+Q2zK+y5atGji0qVLR6khg4F/Xi9Du/moUiAT8FcU8lOXX3753PHjx1uRn6gOcIzvq9DAf+rUqa/s2LFjdSxq+xv4x3jl2qO3CQUM/NuEzHaRdqCAgX8em/0N/NthxdglY0UBD/4///nPzyIXWuV98fmnYvZ/VX7/p6644oo5pvnHasrkzcMa+Bv4p9X+MNnM9hX+LNo/b9a93WiKFDDwT5FQtlveUSCi4D9NgbVf2bhxY7/6+voONMvyLxpp8eK30tLSDmrs41L9vM/fzP6W5593i9BuOLoUMPCP7tjYnWVGgSiC//z586etWrXKwL+pofWNfSJo9k+1wl9tVVXVpxRn0PbcVVddtWDkyJFbJNn9n5iX2by2o40CWaGAgX9WyGgniSAFAP+GhoYuv/zlL0+LSoU/A/8WJko2wH/SpEkvbt++fdm1116bTbO/gX8EF7ndUuspYODfetrZkdGmQIbg/7Ba+s7MdkvfVoL/DMr7mtk/BbP/wIEDX5gwYcKL6k++/K677tqV6RTF579z587y22+/3Vf4a6mxj9P8lQo1S/6aZ03zz3QE7PhcUcDAP1eUtfO2NwUyBX8pkDMuueSSmmw8xw033DBE1ocRrQD/rYHP38A/la5+uQL/2267bYJqDqTS1a8R/DH7X3jhhQvGjRu32cz+2VhGdo5sUsDAP5vUtHNFiQIG/p+NxmdhhHnyytTsnwvw79q1a/kPf/jDCatXr/Zd/aqaaelr4J8ncy3ut2ngH/cZULjPb+AfM/Dv3bv3IsB/4sSJL2TT7C8yVtx0000TlAc9QeWGMfsb+Bcu34jNkxn4x2aoY/egYfAXFlDD4ti6urpKlcgt9il2/p00u+Li4g6VlZXrhR8Lhw8f/rCZ/dthymSi+Rv4t8OA2SXzlgIG/nk7dHbjLVDAg/9DDz00ReA/Th1ZUwX/vwr8H8k2+Ev4OHrWrFnnppnqZz7/VBv75Br8a2pqJqpAw0mm+RvvKQQKGPgXwijaMySjQBLwP06af0UKmn+kwJ+UcRr7nHXWWX+w2v4y0YQrIzHwJSUlDaqIVJtL8L/xxhsnyuc/wcDfmE2hUMDAv1BG0p4jkQKAf0VFRRdlaXnNPwrgT5GfI9Ko8LdVWWMzZYkw8G8p2r8NwB/N/1um+RuzKQQKGPgXwijaMySjwOLFi8uWLVvW9ZZbbjktMPtHAvwp77tp06b+KZb3NfBvb7N/p06dKq+//nqn+Svgr0Xw79KlC3n+s5Wj+dz3vve9+d/4xjcs1c94VOQoYOAfuSGxG8oSBQz8PyNkbFL9cqX5h8B/osD/xJY0/zD4X3TRRQtGjRq1yfL8s7Sq7TRZo4CBf9ZIaSeKGAUSwJ8CbQT8tbfP3zX2aY3mf8opp/xBJF49ZcqUtKrWGvhnMDGp8GfgnwEB7dDIUiAT8FcQ0q9+8IMfzD322GM3RfYB7cZiSwEP/irONmX58uXjglS/vAR/Bf29pKq1f1Bcm4F/Wwf8BeA/KTD7p6L5rwjK+z5nmn9s+U/kH9yD/09/+tOzpJGQDnWUrFrliq0pJvc5nAfN57Kysh2dO3deNWjQoFcN/CM/vLG+QQP/mJn9+/btu6h///4vjB079kWl5S3LRm1/NQcqOeSQQyrvuOMO7/NvCfzrMPuLQc4+6KCDnrvgggvmm9k/1nwosg9v4B/ZobEby5ACYfBX4J/P829R8xfffoM8fxWKm5nN2v5Bnn/aZn9p/TPQ/MePH/9H0/ybSfULwP9Fgf8L2QT/Hj16VD7yyCMTqe2fgs9/P/C/5ppr5o8YMcJ8/hkuZjs8+xQw8M8+Te2M0aCAB/+bb775dFr6yqr1jVR8/rLYviGrVqTAnzx/YZqBf9gc6aeZz/PPJfg//PDDkzSByPM/oYWAPwP/aKx/u4sWKGDgb1OkUCnA3FY31q533333lAD8Cfgrb6nIj4F/O84IlWOsVl7m0DfeeGPSkiVLRknTPiLVVL8ogb9MNXMksT1rmn87Tia7dLMUyAT8ZR596oorrpgjc6QF/Nk8ixwFPPjfe++9rshPEPBn4B+5kQrdkKLrqxYtWjTszTffnPjxxx+PjgL44/NXsYhJuhfM/ilp/oA/ef7f//7355nZP8ozLr73ZuAf37Ev9Cf34H/fffedjs9f4I/ZP2/BX70G/qDmQ2sKOtUviuCvIMLODzzwgIv237Bhwz+laPafq8CRZy+99NL5J5xwwkbL8y90dpN/z2fgn39jZnecGgUM/D+jU17l+UcZ/PH5K+ivRfCvrq4m1Q+z/3OXXXbZPAP/1Bas7dW2FDDwb1t629XajgIhs//pgdk/LzV/WY+nE+1/8skn/9E0/3aI9k9X8wf8vdnfwL/tFrxdKT0KtAL8dwZ5/gvM558erW3vtqVAoYC/lMjpRPvHEfx9wF/l7t27O7bU2CdXAX+A//3333+y/EbjUzH7A/4asLkE/F188cWm+bfturerpUiBDMD/VYH/ryzgL0VC225tTgHmtjCj25133kmq39h89fkb+G/ZYuDf5svHLljoFAiB/1RV+KP+eUsV/rzmb+Bf6JMjz58vA/B/XUrbo9ks8qNCcUMUKP61efPmnauWvunU9t8i8J8RO83/rbfemrB06VIf7R8V8Cfg73gF/FXLClGaWAKV7yoFXOc1f6L9p02bNk/pUBss4C/PuUkB3r6BfwEOqj2So0Am4E+FP9XSn5WtCn/ZAH9F+f9BNQrWxiLaP8Lg7wP+mgP/lfL5z9X27HnnnWfgbwwpkhQw8I/ksNhNZYEChQL+wpDp0v5fUqrfH9Vbo/DB/+233x66cOHCiVHR/Lt27Vr1+OOPn0y0f6D5V7Wg+TvwJ9XPNP8srGQ7RU4oYOCfE7LaSSNAAQ/+99xzj8/z/3qKef6vR0nzN/BvZ5+/B/+gtj9m/5TAn1Q/BUXNHTlypJn9I8AQ7Bb2p4CBv82IQqVAK8F/HeV9cwj+0+TzP2LTpk396+vrG7tmMga4jHnRPbO0tLSDmvjslvt4SyzBX1X+nM9fgHukyvu2q8+/NeAvf/88bc8a+Bcqe8n/5zLwz/8xtCdIToFWgP++ysrK9R78Tz311Jly2a7OBn2vv/76wSoQd7QC/loD/n+WEvl7uvrFxuwfQfCfHGj+I1PR/A38s7Fs7By5pICBfy6pa+duTwokAf9jWujq58BfKaxE+z9y2mmnzcom+CvV8Gtz584l2j9Vzb/ea/6yRLw0derUP+7YsWNdwQf84fPPd/CXBDlPPQGePffcc+eNGTNmvUX7tycrsGsno4CBv82LQqVAFMF//vz5aP5HKm4sFbO/gX+EzP5paf4C//kHH3zws9/97nfnHnvssQb+hcpl8vi5DPzzePDs1pulQITB/wiB/4AUfP4e/P8szf/3sdP86eqnCHta+nZuzwp/gc9/chDt35LZf7vMNSvR/A38jUNFmQIG/lEeHbu3TCjQSvBfF5j9H82F2V+a/zmB5p8W+MuF7Mz+AwcOXHfkkUfuTocuedfYJ2T2HxVo/vkI/vMPOuigZy+88MK5J5100joz+6czZW3ftqCAgX9bUNmu0R4UYG7X1tZ2f/DBB6cELX1T8fk3gv+4ceNmKVg7mwF/Ry1YsMCb/dMGf2r7H3rooYUP/u++++6Q1157baIGrd3Bf/r06SWffPJJlWpEn0LAn0w232wh4M9r/gb+7bHq7ZopU6C14C8N5DVq+8ulNVtRyJtSvqDtaBRoIwp48Fcr9tOXL19Obf+UwV/pdY8o2n/WRRddtCYbtxtE+7cW/P9EeV8V+flTwYP/yy+/3HnGjBlDqfAn0PWpfu2m+QP+MtVUC/wn632CajSnBP6aQPMp8mOafzaWj50jFxRoJfjXCPxdbX8D/1yMip0zGxRoDfhXVFSsxewvM/ujOQJ/b/YfmIrPv0uXLpt1P3+mpe8ZZ5zxR2HPepUcLlyzfwGB/wJ8/lddddWcY445xsz+2VjRdo6sUsDAP6vktJNFiAKFAv4C/j9R3vf000//k4G/KiFRBSn8KikpaVBFpNpctPT1mv8dd9xxSk1NzfgUNf9VaP6Av0xHc0844YS15vOPEGewW3EUMPC3iVCoFIga+Mvt8NVQql/Kmr+BfztG+3vwv+22207RAGL2Py4Fn/8qmY4WKODvGQP/QmUv+f9cBv75P4b2BMkpkAT8R6jIT6U64xV75dG/U1q3uPj/b++9gyy7qrvt6e7JQROlGY1yIhhMkkQwYIQxCAWiBUISIhkTbFL5H7vsKttg+zVgDBhTtgUug+FDvAWYKCOBhaQZkZFEkkAop5Em59gz0/M9z9Le9z195tzu2z3dMx12V50+95574j57rd/Kq+fAaJn9P/CBDxz/0EMPPb2A/yCzNZv9b7311mp53yPu8x8O+Ovzf8tb3vLdovkXFjUWR6CA/1h8K+WeRmIEnNvd3d2LPvShD1384IMPnofi1jH4W+Hv3HPPvfE973nPiAT8ZfCnvK8+/7M3btzYseaPyf9aU/2o7HfdpDH7C/4pz9/a/uMN/B/hhUXAXwH/kSDlco7RGIEC/qMxquWcY2EEsNjOxEK7EKXtYgLHxz340x32O1gPNkyKgL8C/mOBhMo9TOQREPxpFrLgb/7mby5DO7qQIlZPh2HOpF11j6bQqlnUz+y7e86cOSXafyJPignybBn8h6D592H2z3n+Y07zL+Df1xetDwcI+Ps5aUjfoEDDVbzI+4i033Ooczn7/D/84Q//AczRgL/BfP67qPD3MOYaff5fRVK7sZj9D/UtlONHYwQK+I/GqJZzjoURGAb4t3z+Y9HsX8C/M/C/6pWvfOU38PeMCPhfccUV0+byJ/jTlvEl+GsE/zloR9Pq2pHfZ8yYIfg/Ym3/Av5jgQ2Ue2g3Ahn83/ve916q5m/nsaL5l/kyEUZA8CeIb+H73ve+ce/zJ9dfn/93Nm3aVMz+g2j+Iw7+TKJ5//Zv//ZKwV/Nnz4DnYB/RPsXzX8isJKJ+QwF/Cfmey1PNWWK4A+fXvTBD35Q8H/xeA34w5L9vwb80WvgugL+g5v9xwT4p1S/r2KuufH8889fU/L8C0saayOQm5/gFy2a/1h7OeV+DmkEDgX8R7rC36FE+xfw37JlNlJcN6b2Tnz+owb+dvVj6Ujzz+D/tre97cZzzjmngP8hkXI5eDRGQPDHqjUf0+ilpCBdiGXrmcXsPxojXc55uEdggoD/JlP9rPA3GTX/cwHbnOp3RMEf378+fyOiOwH/1VRmsrzvVwr4H26yL9frdASq4E8akXNbn/+sEu3f6QiW/cbqCEwg8P9fa/tfdtll14E/GydTql+n4L8/l/fFTDLimj9Wh6P+67/+S59/Af+xSu3lvoY8AgX8hzxk5YBxMgKCPy19F1OW/dXJ5//MVOFv6jiq8KfmX8B/ELP/4QJ/zf7P7SDgT83/Rwb8velNb7qRalGri89/nHCNSXSbt91223Q0/gWa/VlfwNzW7F80/0k0Bybqow4H/GfPnr0OsP0Jy4h29TuE8r6TE/xhTBfefffd1Za+A5n9A/yPPvron/PivjHSqX6c+6iPf/zj2ew/GPjvJtUvg/+XC/hPVPYy/p9L8N+wYcP8v/iLv4iAvwL+4/+dlid4dASGC/629KUy66df/vKXr6Qvy4iW9x1Gbf9N3M+3qTvwzUsvvfT6SWH2v/HGG0/82c9+FuV9161b14nPf1TBHzCfb55/6ur3nEE0/xb4M4m+8od/+OWgK/0AACAASURBVIcri+ZfWNJYHIE24G+Fv6mlwt9YfGPlnjodgQz+H/vYxy6+//77X6xgO1hjHzV/wR+w/S8C7Fa+8Y1vXN3p9Qba71A0fyzI39bnX8C/fbT/qIP/Rz/60T8wIhphpID/SFBEOccRH4EM/n/2Z392KYLtBeRCZ7N/I/hPmzZtD/WuLGD1Q5bPv/3tb7/xwgsv3HTEH6TcQBmB2ggI/hRkW/Lv//7vrz7S4P93f/d3Jwyzpe+mDP4XX3zxdWDPpgkf8DeWNH/qnk/nBcxnEmXwf/Zgmv9RRx21Ggnyx2ecccaXL7nkkhtf+tKXPlJ8/oU/jbURyOD/53/+55co2HYC/tb2N54F8L+ygP9Ye6PlfvIIfOELX5hFGuviIYL/evj2T0Za8xf8Mdk//Yc//KFd/c7C1dZJV7898+fP1+f/bSv8gSPXL1y4cOPzn//8fUN5y11D2flI72tL30MBfwbqqpe97GXfoAnJvSNR21/wX7p06YL//M//DLM/0tfvdAD+a7iPH51++ulfwVyzsoD/kZ5V5fpNI1DAv8yLiToChwD+mv0/PZJm/0MBf7LXwuxfwH9ws/8vAN1vjBL4X6RpdAjg/2PA/8sF/Ccqexn/zzVc8Ecb+TEM6XNF8x//c2CiPkEN/M9LPv9Z+/fv72mX6ofPX81/TIE/9/Mtwf+iiy66noD2TUXzp71o9W/q1KnZ5z/i4M8kmr579+4F//Iv/3JRyvN/1mCaP+aaNTJIUv0K+E9U7jIBnsu5jQ9/PprJkMz+urRYPveOd7yj+PwnwDyYiI9QAf+o7W/1SgL+OgJ/+LapfitGKuDvUDT/Av5btszpJM8fyUjwv4ogpG/Q0veekTD7yyC3bNmy8D/+4z8u0i+KBCn4z27X1Y+0wD34/AV/8/wL+E9EzjJBnsm5Dc0c9Zd/+ZeC/0s69fkL/pSvLpr/BJkHE/ExquD/wAMPnOfcBvxnDqb5w7dvNtXvJS95yUqC6x4ZibGpgP/rks9/eW9vb7/W9GbX+KdVgsDaKeIISuRGwT919bthUmj+N9xww0nDzPP/pWb/0QD/T37yk6/S56/5qAPwX2tQFJPov4vZfyTIp5xjNEbgUMCf+X0lwvWNL37xizeOxr2Vc5YROJQRyOBPN9bXCP7J7D9jAPCfotkf8I88/7EE/nb1wxIxecD/1ltvNc9/SOV9jznmmF8uX778Kl7c10dS88fPv4jyvoJ/VEEbBPx7k+b/Y8GfmswrSsDfoZBxOXa0RqAG/kb7PwuNRNNo21Q/ov1X69IiKOrKP/mTP1lZwH+03k4576GMQAX8L8Hsr+b/DDT/8Qj+1wD+V7/2ta+9Hhfd5gnv81fzHyb436rmD0P6BgN190iY/SkS4YRZdOWVV74Kv5Hg/4wOwH+tZv8C/odCvuXY0R6BOvgj5D6T+JbZHYC/6VCfK+A/2m+onH+4I1Ax+1+azP4Z/LvbBPyNquav8EGFv5zq16nZf4Nmf7v6veIVr7jh2GOPLeCfX16eGCngb4eavz5/wP/rIwn+M2bMWITP/9WCPy/x6fv27RvI599LRcB1dvUr4D9c0i3HHY4ROFTwJyDqRkppbzgc91quUUZgKCNQAf/LBH+sts9AsJ0O7x4M/G821Q9r7YqR9Pkn8NfnfyZ5/h2DP6l+32Ix2r+Af7XsaAP4Z81/RMEfU+fiT3ziE6/mxVXB/yDTqPdGoMZewD80fwL+vlTM/kMh2bLv4RyBQwF/TJFX0rdiZQH/w/nGyrU6HYEq+FPh73wUN8F/WgH/TkfwCOxnkZ9hmv13EA15m2b/F77whV9fsGDBXSNl9ue8iynvOxTwtzvUDwv4H4EJVC7Z8QgMB/yxqK1BEwmzfwH/joe67HiYRyCD/xVXXPFawT9p/lOPBPhTKO7E9evXPyNV+Buq5n8N9HZ10fwHLvKzE5AOzX80wP8jH/nIxatWrbLIj2Z/254OpPkH+Gv2J1DjhhLwd5gpv1yuoxEYLvintqdX0rRqRdH8OxrqstNhHgHBnyqvS/71X//1svvuu6+q+XcN4vMfcbN/Bv/vf//7YfbftGnTsR2m+m0A+K8x1c+6A8Xnj2m9jc9f8A/NX58/QXl3Mei7D3XOGfBH3uWST33qU2r+pvoJ/o2dz5LZf58+f+4jNP8C/of6BsrxozUCtSI/CraDBvyp+ZsOpeZPy9OVZNasH637K+ctIzDcEQBoZ+FbP5ribJclzf/pyew/IPjDtwX//zrvvPNWvPOd73x4uNevHvf+97//RC0PlK0fFvib6nf55ZevKNH+zeDfh689NH8Yk6l+XyOtY6TB/2ID/mzQ0AH4my+q5v/FAv4jQT7lHKMxArXyvkMCfwTbK9/97nevIPWogP9ovJxyzkMagQz+H//4x1+L5m/AX0fgj6Z9C3xb8L9hJMHfIkMrV658Hdbjpw1V8xf83/KWt9xAo6ItJdXv4PK+hwX8a5p/T73nud/JDFDzX5+i/Qv4HxIJl4NHcwQK+I/m6JZzH8kREPwB2WOw3Gr27xT8NbML/hb5WUHvilUj8Qxq/gn8Xw+GPI1Ww8uGYvafdOD/y1/+8kKK/LwYU+RZlNcdrLxvBv/b0Li/cf75538dE8+dI2n2p6vfa1KFPzX/Gfj824H//gT+P8B89CXMNdcXn/9IkFA5x0iPQAH/kR7Rcr6xMgLf+MY3ZpMCfgyB2peOBfB/6KGHnkWev2b/Av7tJskwW/pWwf+q3//93/8a4Dxi4M+9Hv3Zz3724iGA/wY0f8H/iwX8xwo7KPdRH4EC/mVOTNQREPyJDVuK2f9SfP4v7tDsP2qafwH/DmbacMEfc/suivyE5j/S4E+p4KMp8vMazf6Yb87uQPMP8Md89IXi8+/gpZddjsgIFPA/IsNeLnoYRuCmm26aTXzWMsz+l6j58/nsDgL+AvwN+MNae8NImv0Ff1L9Xo/P/6nF7N9mAhwK+C9duvRXvDyj/b9GtP8dI2X2F/zJF70ktfQV/KcPZPantr/g/z0D/phA159zzjlriAfo34f4MBBAuUQZgYFG4FDBnyCklbjY1pVRLiMw1kZAHKFM9TLM/oK/LX0F/0Hz/BP4f2YkwZ+ufifZDdZUv6GCP9kHV+vzJ7NmxaQI+CMl4sSf/exnNvbp2Oev5i/4q/m/6EUvGjHwR4CYSRbB0TT2uUSzf9L8p1XB30C/vHAffYD/eoD/B7y0L7zhDW+4/txzz11dwH+ssYdyPzXwv5D4GqugDVjbP6f6Ge1fwL/MobE6AoI/c/lY8vyt7X8u4H8WGWBW+Bsw1S9H+49kwJ/gT9rhs0z1M9ofzX9ppwF/4NnVKJIF/AHcANmGPP++Cvhf9YIXvECf/29GQvMnv3/mzp079flfyourgn93vpcM/EhmRvv3EfC3CdORPc//+3d/93evZxI+QvBJn4SybNmyA7/61a/a0gyFHFoWgsc85jEHVqxYMeW3fuu3Wtte9apXHXjve98bx//1X/91P2tCETDGKisam/dVwH9svpeJclfw6Ueb1Lf5g4+1foeXTfniF78Y3+GPXc973vOm3HHHHfEdpasLHjgFAG88X5Wn5v0A13nz589f/qUvfeliTO4vRGl76tatW3uwCMMmH8WQjCN+l3fb0neUwT+b/TsB/93c/wbA/5rJCP5G+5/XabT/aII/E+kYov0vTT7/s5AepzFxAvyzQJIFAKpKTcFNsGPx4sX3IgBcx2T8yaJFi1YxsXazzz7mch8T7QDHHeju7g7w9jvCwQGlQfbhp779nGMfx+yjwJDH7Ofz/j179mhV2M/+/t6HJKug0fesZz1rv+dl8XwhZBRBYKKw0NF7jgL+oze2k/nM8kae36VLIBeQ018XJvgueF0X2m83Sxd8rHvXrl3dmOh7BGd4Wg+/T4UHTtNHb4dJAFuNvcd9WLrgmzLJA/JNeag8k33iEv7O55mcc+HmzZtP/MlPfvIChIenkvZ3EufzuFAgXTeBP2B7M1atz+DOGrFUPzV/yvv+zne/+91s9i/g30QgFZ9/TvU7u5NUP8B/N2Z/A/5GXPPP4I/m/xIkyLOckFXwT2Abj8O8nYIAsJdmQJvxFtyxZMmSewDw9UzUXUy6vaz7mMgcfqAvA7RrJ7Dgze/7XDhPL8f1cq5ens3Pblds3Ysg0Os+bN/rwr57+X2vQgPr/Z6Le4xzulAAaT9E0sc97Zeu2Lafe9vv9m3btvURKNkHgWbhIb8WBQnPUWIVJignL+A/QV/sCDxW0trVtFvaNj1XuohfCnZ31113dcOXewDUHkB2KtbRqSgnljzvEbjhTwK4HfS62UdBQLDthv90C+QA/TRAWh/8VPirn6extuueQO96OsfNZNsMP/ubrlbP4b1lnqkQoMIDv2sJGHyYyfkWcMyxaP2/xX0ehzAwTwFBwB9I87d6JRbbz1hOl/LVI1Lhr4B/hxPyEME/fP4jbfZP4H9ZNvsrgTaBvxMLkA1NHhBWK98KUG9jsu1k6WXi7xOEBWb/sgUgAaxSbB+LwC+gC/x7BP60VnDwHCEMKBQoHLiwbRe/7VE48HjBnbUX0Wqg9cDtcXwWKFjvYb897LPXToQKDl5fwQQi0QpxYPv27fuQzPfTJGk/47r/wQcf7MPPm4WEEAqKcNDhxB6Duwn+MMcFuMeMZ7HCX/H5j8H3NBq3lE3ymt41uUvKdC7ths67ofMevk9zgSeoiXfBD0IIENDdpgIEP5kO4FvzxHLnArXrWZx7Or8L1goACgPd8BSP63Ybv00DjGewzX1cpnkeF7clsJ8h8CcBQPCPOKskUAT4PypPHOjzX0tjeVQ40GIwm/McBfAv4rwzFQ7U9hPPamv2z+A/kuV9DwX8Cfi7ZtIE/H3mM5+Zg6/HgL/haP6/YrCuwmTzVSbNiPn8mThLSfW7DEapz1/Nvy3458mlOUotO4G962ymypPQ75qpYkImidRtcYyavlq8a4A+NPp0vjD78zm2+Tufd7PNJUCe06n9B/j7XWFC4YDPCgi7dZFw3C7Ou8ttChNaErxukqL7PL+/6cIgyGsr+2zFsrIdF8auM844o5fP4cLwWt5+EQJGg0WP7jm/+c1vzuC9zy/gP7rjPBbPru6BSb5H7V1AhtanoY3PYJmDELgQwFwIQC8QjAV6niE0brV2j+W7IC1gz0qLYDuLfW16NkMBgEWgDwuASzpHbEsafZjzBfVkAXB7fHZbMvnrp+9W+GC7fDKEELV3+U4SSELpyn8ca1BfWB2SABJBfnmpCgD5c/b5jzXwX758uQF/V7/tbW+b+NH+gv+vf/3rE2699dYL77nnHn3+QzH7jwr4A5JLbRChzx8NqQX+FdBuAXiegDkGoLpP3pZNT3XzU5qI4cfKwoKAbzxAxb8V8QFJuAhrgcKA4J3N/IJykobD7O/vugvykoSA3rRuWQuS6yHcAloOtCjw7NuwYGwwGAYLwEYFAQSCnbpZtChAkAonYTngt4hRsMRxjk1QQDEuwfiF008/PawSY5EZTsZ7yuD/t3/7t5cg2A5J8+ddfv4973nPCgJaS6rfGJk8CRin4lcP/zkuvW74Zw/0py9d0/x0Te0JVP0c2r0mdX6brWkca98ClmPSsph9cgdT/fIB4Co/0LGuT832oeWznxaA6Z7P7QIvnwX2AOI0RPrcQxBIoO/n+F1ffbIQdKXP8d3Pgn4C/saRrvLTzG8z0CchoR/wDwb++vxf/vKXj4bZ//IhRPvvNmXcdr6TFfxN9Xv6EHz+Af6k1pnqd/tIRftn8E8+/zPzxM3gnUE9m5WqMzRPvjwpm36rWK2yRNtKHVSizefPa6XU6vbq5zp1pGNa/v8E8AoDxhBEfIAChGsFBjX4vI+uAVwC2+0mxbKemAHBfxPrbQD8Tq0IChTJ5aD7YY/HaIngOC0NuhkiHoH72s1xOwl82UUaZFzbWAMEvD4yGFrxD2OEj06K26iCv+2qyUXuyOxv5zOsP1e+9a1vXQmtrZ0UgzWGHlIy1VxPRLzgHiAL0BsnNx26mqWpPPnM9cOrgbu4bbZmec3zgOqMvBggx37zEACOQmhYyLmORlhYoiCgdp/APkA7gbVBdyEMZDBP1lCFAjXuVjBdlbflz67llVVtPH+ubvdz/t7EWzvhs1Xwr++f78d9qpp/CvhbOVJFfipmf8G/0yI/gr/ZB0b7Ty7NH3/kBXfffbea/5DB/8ILL/waE3nEwT9F+5+p9Oykbwf+9e1VDb8O9Pm3dhO5aknIn+tSbad8SWCvXaf1PRFJMhg8albTwmDqIlr7XkB/J+C9g8/bAXbdADu0DKT4BFsnh1tBVwK/61bYrTBgbIKCgMewbOYcm7AgbFaoAPx3wGj2kBnRe+aZZ2oVKMGFnb7MEdhvGODfy/tbA/jfBIP8PDUsVrzyla8s4D8C76LTUyTt3oC7aeSOzwCgZ0FDc1GQFsDzFrIsALjnAeaz9ZPrW9fnDYgL8Ba+maV5HlrTRB9CgNvZd45rzjOb412MmFdDVwNvBf1l3qPC4b1UAZ1z9tuv3TO108br+2eNPmvqTQpUlSc2Xa8J/OvbEvgf0LpZifYv4N/ppByp/bLZn8Y+55Pqd/5QwR8pSZ//aIL/04xITT6sVvSoE0jptGliVcemCv5Nk7pqKWg3plWJdSCC6PSd1K+ZiU4Cz+6FFHcQwYjGFiQ3Qzbju1a7z4GFuhjyvroFDFLcruWAmIG15K+uRgBYj2S7ifNtw42wC9Ok8QUGH/YiaPQiECg4RLojKZOR7liEg07faGf7Cf6M8QICvi5BsFXzt+3pQEV+MvjfrNn/jW9844qXvexlazq7Wtmr0xHIAI9Pfqo+eYBYs7z1RqZDA9MBe/3tMwV9/fLss5jlGJZlRN4vEfxToJx8KtLm1P61BuTP0LXWgPDfG4CXfPPZJdCDMBB+9rrGXec9Vf4jH6kqOu007U7HoUnxGYzfNfHPTniublV4zTqtWqeddtpnwZAjDv42iLPID5bSq9/85jev5B4ndktfwR9///EsF1iTGTPxM4Zi9s/gTyrb7TAnNdJD+rPIjwF/n/zkJ6PID8KI4C/hhB9rMMDvZOINNqEHk6CHe3ynAyNB1V0LFUJvuRR41uxCiFgE9jHeoE/BAVDfbbyAfizAfw2CwAa2bcJCsAUBYKcWA4MQdScgBGw3U4LzGZCoC8FshghOJABmLwxvH66CqG1QBIJO3+LB+2Xwx4QcPv9OwJ93uDYxyCvf8Y53rKCPRgH/4b+COPILX/hCzxOe8IQeXGBTEcIi8I65rrl9piAOj5nDnJ/P57lYHdXeZ7M2wM70NX30izXVsxyj2V5Bgf0Fe03wOT2uZaLnktk8nyP4W2Z6zd/Z3J6DkQd6vKrlskmJqAJ4nRce4rA1Hl69h4EEkbrQIp9K4G9t/8+OdKqfFf5Wrlx5+RC6+u2GB65LRX6uvuSSS1YuXLiwgH99EhkUl/L8fwX4/w+lGb/Gi7/9T//0T3cd6gQT/E31M9pf7Qhh5GkGuBiNmsHfdd18n6NPq/6vZF4KQsu+rCazVNP5jpQAkEE+X7/ucqia5qr3mN+R4yBDAdAPKASYWYAAIMBHtgHnz+4D3QQ7+H0bRLjJ6lbGFrAYYLhFKVjLAcdaP8EgxJ24CkxXLAGEw5zkhwL+mv1J+1xxwQUXrB7m5cthjIBa/s033zwLwUuAn0fhm4Wmp2nCB+yPSn54tfslfJ6vbx7An8dxgr9CgMfNclFQYB/T5gySM3AuxrgT0B2ID1Vpf7gvbTDBoOm8ndz3QHxR3lPls9Xz1YWWBP4KtregaX+W/jAr3/nOd45Ynn8C/9ca8EfBoWM7KO/bD/xRdlbA97Y+//nP1wra8d+AJRY7Psth2rGi+Z+P5n8+YKvPX4lXyXWg8r4W+RkV8EeaPubzn/+8udDnker3tEoEbGMUaRMIViXgTgmyPuSDEWgnxNKJWazddTu57ya3R3IfhAshpTJGuqIxQ5yztegqsKaBmn6KL9ilFQCBYAvCwCO6C3QbIABsTNt0GfQiLESQIb/b2VFrTy+aVO9hmrLj9jKCP3Nm4f/5P/9Hs//5nWr+aCO3YBr9PKbIGwr4D/76tRJmHz28TP/7LMzz0zXns5jLfhTau4F2iwGGpfIbA+4EfkBd/7sAP1eXjAF4mvC5qsqHWr2m+kiXS9HxwSfbgd5AYDkYfVd5R9X8347v1BWidse345f14we696Z7GOz46v3Aj+QjqxP4X0ljn+8S0PrI4G938D0M+KM08TN/8IMfRLT/EMH/apv7XHzxxSsnPPjbh/lHP/rRCT//+c/PT6l+mv2HAv5Xofl/faQ0f1pCzsAcveTTn/70qwR/hJGzDIzRdwZ4hU+sLlEORkSDT5eD9qjmtrZ+bCfJDiRoDAf8h3K/TQJKJsJsRaj6EWv3E7URtBAk/7+ZAmYQ7IIwI93QNb9vhli3st7OYsrhdrZvQTDQpWAcgcGFW4kr2EOFxV6IZy8VDJWYSz2CysscJvhrihT8r6Rd9QrMoyPCIIcyx8byvgI9mrw+c33tU6lZom/e4Dqj6ecD+qHZA+gB5uxnKt08QH0+nxcA8ovTopYfQXuso9StqXlG2GeX42BAnn/vRClw36GA5XDAP1+jyh8HswhU7r1tMPBg993JOMHLd8JDHsJybE+WL1x00UU/etOb3jQiaazvf//7T0S4fub3vvc9wf/MAv5t3ojgD/EczxIBf6YfDQH8b0tm/xEDf/xx05HK59MdytK+L8Is9yzBX+mbSXdQQEx1gtcfsQ0RZmBvRc5Kh2mJ09U+S6SxLZ2velzrku6TiaJ+XU2No8VA21kn8rj4+0BpO/6upcAeCdU4AyXzlEYYWn6lAqLWga36x2iKtEoLAZ/XICWvcRsCwSZ+38bxO5lHewmispSxzZUO2Bgp3e+kzDLI4A9z0uffqeYf4K/Z//LLL79hMoN/hY66bEoDU+8mJoVpOk1fvRH08+BfS9TkXdTqMf8ey7KcuThfAcC0O84TJWzTYpU7rQMG6bWK02RtPq+bhPgqTVfpsJ1W3KSkNGnndWWi4bhc7bMTttK0b6a/qnDObf+/wn1JcI9Lp+sfRLN1RSLdTCOvq42JMUoqEPcxt1eYLs7c/jnC7dZOHmiwfQR/sOOZdPV7LULAmb7/IZj9J5fmL/jTkCHM/pYcPZLgT62AbsBiKmb/x0O8j0eKP13iZPJMyyCcgK0FwtVJyGeb+LQmbRX4tBwkEDdt0CCcqIvtuV3z3bXBhUr8rsPkZ3oO26OoRmIS0fQiaQRZWPB+WosmQU2D7pcXfveYYQkCTZJ/E+MYSBioC0rVcxonUBvHCO7TVeBa94FWAosIqf3rJgD4txpIyLKOZa1CAMC/0RRDYwnMOMBlsA1rwFYC13YYe8A97GaO7X31q1896WIHhgH+pnyuJff4p3Sc/PzrX//6G4j2HxG/6GAMdKz9fueddxqQNx1wn4lJdy5KgTnyR6kYsMxl0WQ/PwH/Mj4bkJdT8eYblKdGb80QA/OSRl+tTBf58vnPz3npZCzaadR5e1Vb7kSLT9c8KFVY/Uea1I2XqoK2gn4TYIeArcsv0XsuYBalzD3WeiD1hWN6XTgmipPxu4sxPpFhxD27tEqNp2doCRHVMZLPJj4XvDEpFdlqa30Tecs2eMlqeMPt8I3b//iP/3jNUP3r7d4LGHKiges//OEPBf+zOgR/M6CM9v8mlohrsERMDrO/4H/TTTedl1L9BH+DXDrx+Y+45p9fKNXMFkCsEYgj4LI9qlf5OxO/EUAhhqhMBWE3apZOyOQ6iEId/pl2o3nPJYO/17OCVvL3qRnkHN1ZCiIyIY/TzMgxEeHL+XJ5y+wXlNG4r00vIu+3EriYm2W0hAXPo7CQBIrwKfq5qo3UNYomoHebSzttfyCBocqgsqCQz+d3idhaBCng04ZHexEErD6oO8BaBOECSIGE27UQ2HAJ0NcqsJbo2Q3JfbAVq8H2xz72sVoVwkUgU+uEyY7nfQR/QGnRRz7ykUswR57Xgc9f8F+XwP/KyQL+zns0+6nMn6hoh+neaHrN9IL9UTD20OrZfozb2GeOgXjmzttdDiuATWaOMiDPnHsL76Qytv3881WgD20hgX87OqvOvfo++bd2NFmftwmgo7y34OqSgLlVwjuDOdfKGrr7RJEvY3Ws6+FiKrDAns4R1UkV2AVZs4BME/Z3rXfuz29a8szoidogLgoD/u5a8Nfy5+L1FDK4lwB/hQrPLZ+FxxzUb0TeLJ/O68yvE989IG9O4K8FcYuuRaPqR6JAXB5jfP4noPk/A59/Bv/jOtD8BX+tbFcX8O8M/CPgjxzNrzNBfj0S0f41AhPke2AErULSMMNhac75vEyKLgDJ1pZO0h4YQ7elOWEk3Wiy0TUrdc/KXbOm4obQAqD1YSafo6FGAnKFkggAgvn0MMGjiUYSKKzspUZiAZB5MiZThmRm7i+W+mwyuiRE6LOMRh1JYLA4SNT5ZgmCyoKA0nQ7EGxiPtV96xpKnQHW9xXwqxqQ3120FChspc/BYBJzkWkoFPTapwCCMpPgYRdiAh4xhoDtqxUG6Au+keO3IeDtJL5jj50OdRPIEGEGE04YEPx53kX/8A//cMkDDzyg2f/sQfL8JwX4J2tfF66NbuqN9KARWr52NnNVMFfDXwJ9LmOslkBLi9HkjsN6tBwBwG3ztMxJc/rrrWGfGtgo2IcykBSC1jzOAm2dVpo0/QTSQRZNwkE7IaCBPltAKTinQFwrbwq+Fu+KRW1bAOa8/hbpu1lAYC3I645T4N5h4S4Ws3fCLcfv0mCk+3oNATtp7kGPFgJL8Txm/uxOwb7WC4kS4fBWhYt9dh+1wRjrfYy/1j6zu2xvfgC3XjwH1pcp8NKDHpMgcF2IwZ94by0+xTlan3k/YVFEAdh71llnPdobeAT/BH/rrSRRrwAAIABJREFU1dDSV/A/GytRAf+m8U0Bf8cR8HceAX9Rb7wDzd9KdLtytP9ogX8iuH5AZ5nNkZgndtbSb+i57IFN6c4pBAt1AUKxjUluD+wuxkIptht8ijXENRWCcBVav38KEI9+7bKdZm7EEdW+BPLU5cpAI5cM6NGOU2sDlwsrA/sadGRXLAuHLLGgiCZN1gocCgUKIVV3Q4spPaocPKr1VzX/JgbXbvwE8vxXZ2r5ez6fawWAyjG5/kBoBmoIugjsYAhT2QbjME7AoEE7Lz7MsoptxgvoNrCE8SbGfDMCwlbW25iHuyaaayCDP8xJzb9T8Lfk6C2U97XC3/UTzezvfP72t789k3k3BzP9fJvcQHMLzZ+HlhYibAv8S6GHYwV+0+74bb48yqI7Ct0pzS6EY91tiRYe7URTK22bt7nuVEuv0kuTVcDz1ASDlp9dWkjXlC4019sWXPANi5lptqzXA7brWDZAM1vZbye0rnYv2GetO/qFJA3dDJ09Zt0kQLfXh33LA/SlPdeMS1QM9Rz+7uIfY6aQsJ/jD0CbBwR1xjSAHYHc+JwpAPMBXE0HVqxYMcWYnTrPIBWubdxO5qsD8elKDNCIx/8I/ggnT//+97//WnvDwMeP71TzJ/7gmyi018B7bpzw0f5XXHHFbNJijrv99tvPo7yvqX7P7BD8TfULs/9ogv9IAP1IniNrKUyMLoCrC4EpmIwWCa0KaCNhWdCvCHMKSwIMzC5eYUlQ69fioFtFxgcRu81WnZomDUgy13hRqve9WAaodqP1gP3Mesi1wyNWgUtHww/P6TX4HsIH14/e3cYypJiDgzIl6uPSZBVo0myqAkDTOfLvCgcwJyt5RRtj0wQ1JcLUtrCYPrjBFEIZoL0MYD5aBKxGuBrmtJH1duaYxYisQDjuSxIPA/zVxqyC9lMq/F053sFfUGa+dF911VUzmCMzoBXN+dHcRmEXAFoG7zlWcz7bFkEjmvkN1FMItu69tfKtvmfKnsK1tHNQzfo8J9tZwQYTiKt0UJ3/WbBOpvRs7QqTusCuls21YxGoWcKEzncXNfPQ8o2HUQiWDqyloTUs19RILrNdPGu0JOd5zcYJP7l/7Be+fhd40H6/YzbfD484wHgc4HMLTBmjA9DPAczYB9CC/U3L2oGJaFWr8qEPfOADxxNQ+3Si/QV/Nf8C/k0gmMGf2v7npTz/jsGfHG8b+0SRn9Ew+48kaI+1c8kIdWcYsQxx9xC13IPgpX9zBv29Lfl6FObNhRCwy3yYgXEYEa2c3QPGEfB5tu4IXQQ8oxpUNBBJaU26HQyImp2CnaqBOK12nSpBaXwOymSoM7+BtKCsTWXmmV0Eugfy4m8yNQFdn6PFoqwtYDEhmJOWgIcAvAdhao8gMKzj80ZjBzhGgWEH+8hEQxsab5aByQj+eZ4rlLI4R2eh3c/XN59ieo4BzI9B2D0W8D/OtCzWRwP+Rxl348Jcdt0q8c3nKRw7xbXzM4Oy86/JNJ/nZZ672VrVYObvF/3u6dKx0cs+zWfB2Pnr3LVI1nbN8Nlkz35RJZO5rU9dk/xOvlv8zMZcbtupJczUWAUAi2ox542P2QUv3U1KZy/0u0+z+znnnJPN/mONfY3p+yng3+HrOQTw34Pk+SsCJMzzL+Df4XjXd0va0BTdGZjXunRBYHLrIlilh7KXAeia/WFwWgdsChIZCS4piFBtSGEhhAJ9pYK90c4IDcewXubaNCfdEFoCOGfEG3BMDjLM5UdzF7HGDmD1e68y3aYAw6qFoKpNZbeA5kmYo5UILfVpi+KoH2AGgRYAvq+2sQ3b1romMngNZsn1xA9swRKw7dnPfvb2bFYd5vAf1sMmI/jDX6bhy58NgGvSX0Kcg6l3xzIflwLwS5mTx9rOFvBfotmfz3NtcsMS5nxjXYx5UUDNc8i55tKJvz3P0epczdaCqrDqXNQ8rvauJp/N7VnQTNq+5nKB2WA162BoqXqYz+tTsOsOgV6QVwiwxLb+eKtsQpPhy2f7XixavUmz38vmfSx9CP8HqimxFaHjsM7RiXCxAv4dvsVDBX9MSldRdayAf4fjPZTddDHQMbEHhtmNNaCVoiRowzTDnaDpU/M/ABqBTroQYCyzUp9wGar+0uUsUeiE32exf7gOFCDUrPzMfYXFwEwHBQQtCcl10Mp/zvdeNZs2aVHtzK11DSwzZK0CaE8GCkVTIr7ry9wBEw2N37VmUQB/DUzyAbT/VTBQAwjXajXAXaD/dNePf/zjvWPZpGnpau510T/+4z9Gnj9geNYgAX/jzuyvywnBdTrPNwu/q4KokfdH86zH8/0k1qdghj3a7ca4MCfmK7Aame/8tViPfny1+qpJfyBTfINA3W9T3U2l4KDQyLwKH3yyQhk1r8YeGrraO/sEiLud70bAC+YWp9ki4COcRs8MhNHomsl53d/gOoPmtA5YXjuC5xQeEF410/ehNPWp1bNvKYI1FIbY4b4F/DscqBzwd8sttwzF7D+FSb1Hnz+af5j9mdy/Gulo/w4fYdLvpvWAdM2pxhiY0qTvn+BFzatzERwMnooGJAgEZh3oJsgBhqYuGkioQGB1M4UD06Z0F9jYxHQptykcRCBVGuzw3aqN5cFv0sKagqOqLyv/XvGl9is0pBam3xSGu9caAYD+JubcQ2hbD8BEH4D5rmIerjVgCoa7QUEBxrqTpZeApDFXYXC44D+WA/6cEzfccEMPc20aQYwzrBEiqOuzx5x/NALkMpblAL651yexnIjmb7U9XVTOK4XNiEepavPZJF+dI03zybkzkAUgWYY020f2SP4umDNnwv9uXQqAelOqZGnjq2363tl9O4CvWd8IX4UD999uwyzm4GaEURtn7UJj3215a9b6+Uc8gG3SM7ghDsBIgP+ll1763Qnf2KdS4e/FQwj4C/DX549p+iqaMnwdArmtgP8QZ+nI797y2etGII6jiy5wZiLMxJcaRVL0nRogaGqUbgAY9CyA3iYlxgZYDGURn9XUTuSY42HiNsVYmAINw1WgpYFbN1vBYMLGpklVhtzOx9qOcVe1PLUjAwdtVATg23J4t5oXi8WELD/8IMz4Ia0BMOP7cAs8jHVg7dlnn72ZuWnA1ZhJGZyg4N9z7bXXzmWuLCJ98Tg0/hMA9xMAe6Pzj2MuRYpeMulbcne2mTPMwxx/chAVVAF/IOGyPn+cZ9VjU+S7fvNIg0um/Mirh1/Zp0IXklkn9zF/HtDVxHbN+Wr2u9TkmVu7LVuN8LyPZS90YYDdPoTrA0l7n5IqVxbQH3l+NqwzHir4wze+RROtG5k/E7urXxX8iVzXFNlJwF/W/H9tS9/zzjvvawX8hzVPD8tBtjA1h1r3AWBukOFB2QgKAyyh/eufxUS7DGa3XPCXeadMA60E1iuIBUY7RxeDRYx0H+guYIm4gaoWVzfZVv2vnVoMFACMD0g5zFHoRG0Mhm7g1Eaj4tH4H0QgvZc5eTfW9TV83gTjNs3QZkU7YdYWODliTFrwR4BZ/M///M+R6kd2yFkphVNBqh9wOS7QVJj9x5Lmr6ZPap4xJrNt/U0etb78owlU1az/GE37aPfLbZrDvkcZoG48SppfZqDovmoVoWrS5qvb6i6kJvN/xXIUVeyyKd9APPtQ8Ps2tltyeodaPESneX8zAL821aB4hHmyLmn+upvMZNrP3DcOZT+ut/1kKIT1oAD9YWFZh3SRDP6k+tnSt9M8/9zVLyr8TSrw1+yv5t9hnr/g3wuBZPD/agH/Q5qvR/TgZM7vuvrqq6eRGjNdKwFMfB6LrgJTDa0/YE71XJi5rgOrqs2HoUdjFPOvU/S2VdgEhmjBXHMTxDPK2NuBfwbAJs2vnbtAZs/cM+9Z3/8GmPiDaGb3o70ZKLjOYMHE5NewfSNWgZ2AaS+CgCbaw1pi+Prrr5+JRrzkox/96CXEcNix0qZV1n4YDPxvPlLlfX2HqcjWdEB9JhlBcwwgZU4YTHp0Whuxvxxh8XS0fivvLVDDz8GlCoJV60/Tu8zbalaf1q61OcHXR2W4NJeiOI0CIfPAstKbtQwB5gbibeC3jQiKlpy2CuV2jjU63/bVmxUQbWWNcLwDq9FuAm73jeW4kSPKKMbJxQ8R/K3wd3UB//YtfVvgr8+fPP+vFPAfJ5QxxNuU+cMQp1ELYgaMPVILAa15pmuh3S1CQDiezycBaqfC9E+E6S9FAJjPfrO4VFQy5C/3VDioMVM7LS+DRR0M6r7gDABaBlLAYC43bObAerR+64drEbgTor4HEH0I8F9H3vwW5q5a4GH7E/wBzCVW+AP81fzPHOvgn6xGMzDnL8YyeCwWixMx7z/WwD3dQjzPMSmoT+HQGhV2xbN2fgvwmzJB8nura/6+96oVJL/vinAg8EfqnVYco/T5rD/eEtObeN8P4v65FyHvXgTB+7EGrTZWxMJR9pfgve9gLuifnxQlpQ/b5B5DF8pFflJ536Fq/ldb5OcVr3jFjWRdbR5qv4ERqUB3uMZSsz/mkeMpqxmaPwy+kwp/Af4Q0e2a/fH5f5Xvtxaf/+F6a4f3OmYdUAGxG4YfKYIKA6YcYhUwVmC+/l4+20hFbdDiLFoALEoUrVNZH8V3C7Us1GqQyiMbe6Bw0Pprp/XVn7bJVCxo6OM1glstMNUSsITpdjMFAICHAQWFgPsAgocsNaypFwFhM8LAVlxXBnhFM6PRGl3B38j3v/3bv70UMFXzz+BvqmU7s/9au/oBWoelsY/CnsGjAP08eMFRCHUWnFqCid8c/BP5fgrz4AS+m6q30Eh9LT0s0VLX9DyXbOFxLKvWniqYt3vf9ZgPjtFHb3EoS9putgCUAXoGeFoRj/VWM0I02+vH512vxypptTy1egP0bERl5P2+3/7t395P1TrLR4cAMVrvupz3yI1ALu9rS9/U2KeT8r67ERzXU2vhaugtV/jbNKHB/zOf+cycW2+99XiL/EDw5w0R/H8j+L/whS/8Kkz0lwX8j9yEP9xXzubgFEg4A1CYzTIHzc967NYZmGtrZksUq+1iKrbT2nJ+P87CRboQOIf9EqKLIospi9Ecqa7d18G+6VkFjKw1VqwBUYXNfGsjtCHujbYgTvUD7DPwiJoiQsAqhAItBNsAjp2jlTKIFj2L6y/5+7//+8vQnjP4a01pB/5R2x9mdDPg/39Hq7FPfpcA5wyYpe9xgQF7mPmPB/iP06Tv+2NtTr5FeDTrmxFi1kir4ZbvqV2sR9V3X3fr5N8UvAzQ1B3jktLrojIe79Agz7W+Lz4/ZN0HAz4VBthuKqiR+bt8f4zxLqLvd5tbX8z4h5szHPnr/dM//dMJWNaeQVXDDP7LOyjvG+Av8Gv2p3W25X0L+NeZr3nZSfO/wyI/L3rRi75SwP/IT/qxcAe5NgGCZJRvRUucA4gsZFmGYGma12mWcDWjgHll5ULLtlrNzWBDAwqjrgDrVjR4vaBLU9BXO4HAfVMNgQOAm2WGd9pwKPUTWAPw3wXo34X2fxcCwP2CCvezGfdArxriSAZ4VcFfsz8uk6eBT4OBf9b8Rxz8HWfGTZ/+VK0xvK/FgP1y3tHJ3NtpWCZOx5VzEtsU3OaZ9mlMB0u32n0106Pd+GdBLFsAGqw2UTkvReYL+JFSl9LqbPu6lWWL7htA/X5MsXdaAZJ3tRYtbTPbdtqkhtTOkmY3FhjAGLiH97///Scyd59544032tjnzA5b+mbw/xYK7dWppe/kAP9f//rXofkPMeDvDmv7C/4whF/C+O3XXv4m+QhUrALdBBBapGgqoDoX0F+QTMiLmS+L2M92zQKLhYis575U1wCLvdlzS2XNyf1yuduBfz2orGoNSIFh0VwFsLDhkGZkU7nWCSy4BB7CHXAnYGLa14P2GQBo7C+wDZeAKYOHbCLW7M/UWPJXf/VXl2v2Hwr429jnda973YqRauzDvdgHQuFsPoLIEu7FmvonIKQZu3GK0ftW3jOQ00JEvJMcqd/K5siAngG+Ov7t/PyZNNK7CcuMhZ20zljyNmnzVnTUJbMaJWOdwXpW1LP5jYWemDvWczC/ft9E7gI5ydnIsB8fs7/FpJ6p5k+MytMsGd2J5g/tb0CgvEbt/5JLLllpgPCkMPsD/ucn8H96B419csDfnQb8nXvuuV8u4B++zaxJdaGJTKH4Sb/4DxsB5RltS+H7778/WgszUbtgsDYC6oLhdqGJTgEMu2B8sb950a7ZpwvmOCAI2anLfWHWsYaJHrDpR74u99BqAFJt/IHbJ3Yh6rnx/NzbAe7zQOrmNeTKZIINzzad2JJZAMssrm00uHnfi1Mt96X6lS1HrFWA7dGTPcUN2N44pxIqDIRPuW5irqeFVbXODFTuk9MGUwU26wZst/WwRYMYr1UwgQdZ7kmZA48AOFZxCw2TfgKaoYf1Vwn4E/yz5u9zDWT2V/O/GfD/v3/0R390A/E1jwzr4hxk8B6gOQ1taBYCmZ3xltju1OI7vN8T+S7gH8eyzAqRScufYeGorOUPBOpVoSxV0YvgPYUCA/OSKd94DFM0Q8M3Fc8Ifcbdss7r+PywJXMZ+zX2V4c+NrGvvR92pkJPO6Gb3uFE5FfpM4+hdJr/sIDER5t2kQ0yhdiHoE/pNLcCN03WbdIq99rVjk49TztabaLRKn1Wm/Q00WjT+5dupdFSOXDKlA996EMnQV+/Y0tfwZ85vqxT8McC+C3y/K+5+OKLV8DvNr31rW8dUsvhcRXwl33++P3PZ5Kr+XcE/nZpI6jmThv74PP/Msz5FxNZ80+M46Aa/EiHRsMbCNcNU+ix7K6NephsXYBJ0KmfYXIxL1xD0NECmCUq8nmsvlMALz7DJON8LgJdZX0Q3cOUD1gKNf8hMEQ7T7fzl1t8WsbU7noHuIbFckxx67OmOO+x1TOc+/ZcB4F/3s5vOaUqeo1z/30Q1gHbf9oxzHtQOKDAUBQ+8XsChH7nzJYBxmcqTHUW55gHGC1g7lnzfZklibUCWCGOe1T7NLUsggXt7KYWmlu5eol6cFm7GIEMRHl/hQAX3kk0azFd0AIvgMxaNP97eaa7EcTuAfzvt9OgaWNcW5Dah0Vj/1ABKIM/qUiX4/O/AG37qfrNBwN/aOwmff6vfe1rV+CLHBL457FmnHoALjMw5ts1D1Po8Syn5AUBTP/+Isbaqo4WfLIQVJj2XapjWvHRx7TLMRqV9x3bBXznHePr2jK6lsfdYRdHxtKuji6WybWXg4F6axj7h63RwHoTzx3BelhenOAHCZxVmvR6uU234G177kybnKsLgaeb7dKT3TW7XLhmP4BWCPc8Ct2844g/yfTp4/jdtXTqn+9NF0imV9eO2UFEKrH19QUNOCYu0qebFRD87Dj52ZgH6ZJxChq1zoDbmPcxji718/ubdJvSHbWk7CM7Z/8pp5wS9Emwbp+Cu8fZ1S+NVVv6bLr/8bSNbJqT4SvPtqsfQsBTGQMzkBrnsHNXtyBjvydp/t9i3K55zWteswL63DjhwR+t/wQ0svPvvffeF3cK/hDIXvxud6v5o438N4P784kK/hI9WkDU2IdIp8JIprGebsMdtVjWFroxyC00VJjndNPbXGScEG8whLyNfQPsZcjJx63PVWYbLXlT5HQ03eFQmUwwmMR8WnSodlVlNlXfKTsF00iLDCFag7pdoSAFVUVUvBHynMv9g8HWTdwCpPtbZtca+qw1l8fa8qaabLmPXqOpOXe0GoWx9kFM+xkz65jHuWsMpIv5Es2MfGYEz2mAk82H5iEAmBFg7QAbEoVFwEAzrQJsN6dc14A+aIMFHbfwQTvMTSCVtdUM/vl7NlMn0IrGLjJOqwhy71oC1hkgiACgIHCP9QP4bG8BK8NtxgqwfShMcZjgbz8DA/4+T+7xCvporB7KNW2sw/s5irHNLXOPR9M/mUXT/kmMraWfFzvmtsp17jmeGVjrwF61rlSFrjSGLU3feee80qRvNVDT8My7N2iPubGK9cOMr0GXgv8mTf7m2/PbNgStHfAh0/H2I0w2ZmAkWuixtLCFqziH/S66mRP2pbAC5XTmXjTFki5Zoo+F9Clg+3wWGzJ+Kf/5PT1HtNt2bqUMhmjFneZa/hwNtjK9unbfJKxXaT4sH2nOZfpq0aEgn2guBHU+S49OZutX7E1zksvvt4BRjIX0mOdsEszCqmIclvRpXAtr41qk0d3M1908/17WcT602/0IegoEuc9AE30OZZqNqX3JpjEj5Tmk+l0G+D9liOD/bTV/zP43TBrw/8UvfnGB4A9TOLtDs7/gfy/S+VWY/f8bwvnZeAB/iRogV0sPc56MQ5M7TL0HUNc0HWlsEMc0c5ZhGFMhmGiek0rjykzUjIx2VkuyJK59x81zNpUrmuNkwIcqwhWQqUMQl0FUAD2EgMRsQvP3s2uXDPqJGcd5MmOuf85atoyX32JJn9XYBbfYlsA/PrtNwE77xSkbKDmOVVBIvtkdttmVYcNktmi2VWuWybOfrXplQnsZh2iawtpo7V6Y+l7PwbyRy+5n7uzXPcH3sBrgerBGvIsceTaANc/Ict6FaYSCv24Bo8+NPF/M2JtOaC+CWQYLWm0wg1dlvFvV5ByfLCDUrQWJmUbgmZaAHBNg7XeLBQlUugUMOkMzvQur1/3c98Mw1B183kWtiz2DccAM/kT7vy419gnNX2CpHpvv0bHjmmuJq7kJs+6Vb3jDG1bi818z2HU07z/2sY+dSdbCXMZyoeV2DeCDCZ7MOJ6gZUXBijFckvz5zlvnt3Oz7ekz8OcdsqCVx1Vl2Hu2ip6LTXAcP0DfcrlG568yWE/tHpCPpjgJ8K23ELn3zgv26cPNMcXUUu7VFNMQgpkL03iWKC2t4Mc2hZWgVz4HjfIcbnM+zOXYo2yHLX1KswY1MkcUAqp9KlrPm54nAk2luwotSp+t79Kn10vXjPRXBfW0j8dnQT3YQEXIzLSVaS4a/iSakxbDGiA9JqAP7T/RZqu2QbrhOBf7HtCqoKAlbTHexk7Yg2AH4x40Kq2aJmnJYvbT3WIMS9CidJq27bGMMe9DAX8f89qGRH0K8YzbAQTFPiwwCiWHtTDWYHO96Xc0/1OZ789R88fs/2Tm/TEdav4b4UnfRqG9Givb5AF/GO8F5Plr9hf8BbJgBJkRVZmpkmfS/O9LqX5fGkvgL/FalUzznwwEEJmKmVZz3zSIKpca7bEYCUxKwnV7dMODqQgic2SKMhEBXaailM93j7UWvlXurHq3gP1cZC5uD2GB41vqhNSfmUoaw2pN8/icmI0/C/YhLCQNIgsOuUhOP4yoTXz3ycwla+85l7npe/COzEjSe24Bf2b06d7DVCkowhAUAGQk1kaPrntWTvO7WgZzIxaZOcfYDc0OaVZU2+lx+nn1nVuVj+17Ob/WAuuu7wVkDfxSS+x93OMe15dKEU+3GyGC2uKUW26qmS6BJdYU0B3AslgXgSmFvgsj6Ctj2tbc18Q4MrPOgKamJEM1QwBQ2mw3QdwAv4Y53mGWAM+1xkA07nsjQsGed77znUadNyJoBv/3ve99r2M+no+g/RTu1znVAv/quAukgmQG/ze/+c0rEDLWtWGIXWj5zvMZHGcVPqvvWW3vBMbrDLTgx0EHJzOGtnpWeI25reUox05kMB+I4VYFgCr4C/wKf/roHQ/999m0r8bvcyTQf5hKeusYxy1s28l97Ic5O3dtTDVTi5qA7p90KcAmwFZIilgRrpsFPasjav3RdZLbXNvd0mfTkmGaqWmJrgV/gV+XUT+BvC7MZDqVDiu0W6XF3NQq1hn0Exjn777TENbrQlMGe9ZZ4265BATztH+LNiuCal0wD/r2T/r0HUBD0mdYWyrCudUNzZyI8sacP4R05q6CmkLrDj5v571tl0616PHO9kiXChW6IaRPjstZGHttYuT926EwxQKNao2MoQgBgj9m/9/F56/mL/gfrWs0j2NlPGNbxey/CatIgD9WvRuglw2TwuyP5n8hpTs1+3cE/snnf78tfYn2/yKMZkxo/qaaMTGnoqFNQ/pTo5kl8VuIBka4hLVgYRe7qEOfNEWZwkwm+Wx9yuags7Y7mUFpMkjNecGM+KyQILNRww9NP2lNUdxEM1w2/XU4YdvGiMgH6udoYCQDXkbG0G6H2rkGDCTMoJj9jgbLseg2kIHEIlAmJqEGF+CfGIZaiJYBmYsMyOA5hQJr7auBWIzH/OyNmoEBVwO9FC52M6ZqND2WluU92kMgUgJ9R2p1WgV4pzaSOd0qgywnGC/A9cP64n3XtdkmAOsnVSULQWbcxjYki8BeQG0HoKXp+mHu1dTAVboETjvttDvxFT7wpCc9acNZZ53VmPVibX+YyyJiIl6PlekCtNinaJbWBVQF0nzPji0CxxqY0U2c/3Pvfve7VxB9vL7pfartM14Lid05gXOfQgT/6YzDCYzR8Sxq+7pQBEKBM3zTLl63E9DP16yOXb7PZBXaY4AeY2ERpbsUjiykZNEdNVDGKt65757tu9QwBStobroxH9yX8QZaJKwB4XdpNAO/NOd7dwlLj7Sp1Yf7ClpMJvigU+lVgSHRpuuwamT6lEYzMA9GozUhuDUMCej7TZuGcw0E/vXdW/RXB6c2AkT1+Cw8CGQK6bHWpaCrTiBn7SKtRZMjnisEboUAhXPeheAfAoLgL01Km9K0IK+QYCdD3u16hF6Ft43sbwfEnXzvRWNWIBgTnTQx+58Gjv0uxesE/ydVwb8+j+vgD61921Q/YmsK+CeNsDXR/K7mn8A/NH/M/l86TODfBZObJrADEFMB86mmkSnNo91Mh8HNgOFl07tagj7k+WqKaDzL2N/laBmI2oUMIEnt2fRujnksgoc+PNYuLQmf38IH79pjXWftaSga1GBMZ6R+H6qwkK9bBaMqwWjCrCxhklTrcC0zZ98wXaZFxiGjUUuQkVTXER/AojthD4LBTsFDX7Ate+1eghWlAAAgAElEQVTSh6ZoIJjAoQYiM1O7CYaqtqwQB/AvQDBYam46BP8Y1qfzvk9S81Nw8/1l8K8/00CgVwe5NO+9B+Mnou87546GMdzj/TCNXwLsv4Qe7sFkbZzANr7vRhBoRWN+85vfnKG14oMf/OAbEEzV/J/sMwhW1THONKd5FpBcjQ/yZoTs/+9d73rXCro0bqi8oy4azjgGc2FwCwH8kwn0+i1MnU9geRxgZzqlguy8pOXrDw9BI8/Voc6z+nzyu+BitL7ZESy3Q5u3oxHeydrYCE3PUUY50UkEsALuU1lsAbyI+7eJ1HF8tjx0WG800btforPwt6d3GQWh/JzoNFwCfA9NW5pU+E7r6EKZ3Gwh5NTnwmDPP5igONjxI/l7kyBSfx9V+kwCe9Blos9saejnFlQQYGxCEEh0Gub9RJ9B2woDCKJbeJ+mxj4Cfa5mvY5z6/bbyfvXOmbmzC722YOQYE2NfYz3PgKC90KX+5gPvWeeeabnHlDRONQxE/y53vNSnv9v208ja/6euy5cVTV/6Ph/1fzJ879+Umj+RMae+POf//yClOqn5q90PaDZP4F/9vl/aTQC/nJZWSwSmgSnwzBncW/WjZ/Homlebd0iKWpPmgMFdTX3MM+rHRohDkNZajqZqU2cZ4GaQwL2Cs89WMmuTsImoBhLjKEdwQwF/KvMpQn8D5Uo0znDrFkVKtUuBFQbrbCY470KRvIgAsFazelaEPRLKkSovfDu1BplZPzUrVZn/MVC3u3xEPpJvOuTrUbHu1+YrDct7bZJq+r0ufL45DX3Ee4Ug9jw+99BDMBt1grg/u+DUT4ME1yDiXsT/vpdBK7ts3GSJXE/8pGPvEGzP4Lrk7U2NYG/9yQzthoh4H8L4P+Zt7/97SsQtDcZ5HbTTTdFVUUL8CDk2kVP7f4MzJ2P5byPYTmF887wXquWqIEAZCBhqCqc+Dm/Qy1AaoBmSAAID3G/dzMe9/HuVisgCSpc378wy3PoDLYFfepe4x2Z1hnPYPEnrXSMifxHAbxuleCynSdTHU6abRrXTufVQPs1CVtVS9ZA4zEYDdePZf9qBkAri8M5Lt3xXrV6me2iG0fXznrevyWWwx3gwmcbK+0w8JDTSbNa+AwMtgLjVubIVmhFd+BeSy0jDKggDDl1eKAxQ7g+DeH3HFP9sIL9tsWrqj7/gcAfgf1aNX/ia67DajCxzf7f+ta35iAhnfizn/3swhTt3zH4w9juNuCPQJD/RqMZ0VQ/XlA0lNGXfueddx7FyzwGze541vYLP1ZzLwxjnsxTUzD7C+guM5KGEJG6bJ+uf1NNIvn8wp9eZwyZmTVNKvdtxxibiK8TJtp0naEwtk4Zy1DuRa3Bv7qZvNNrdbpfE0PTeqBmD/OIlDC+b2fRBBk+SF0ECgAyDdb6H9VU9FdGDIGxAr5X5wJzRkHvcZam1eerpSbf20DvcjAmnAWW+pjq8pAxmrKmf5t7eQQG9xsYyW2Pf/zjbz/77LMfoGLgVoTYKQgm8z/84Q+/CaZknv+TADtdS9HVz3GvgoiavwF/CA+3QGefeeMb33gDDUc2IUTMhV6tmHgamTpPxIKgP/9Ug/hYDIQ0BkWhuB9SVud4Hofqtk7ee74/rX+mgKrpWSYZMLDs7mbGcIdMH2A3/Uzrmb56tfgA/vQ9m+qNzdDVFvEH3Lf++jDP199FXfDKAkier4PN8+rx9X0HO7bdvVS3jwb4t+MHnbyn6vh08nx5HlT3rX6WN0ifvnPdfdKoi/E5HBvWPQW95DLQbbAjCe321thinAeC8SqbbEEX9tbYYirnc57zHC1obeNkOuUp1f0Ef4Trcyqav51HB0v16zW9VM0fYfvqyy+/vIB/Znh5cP2eAv5s6XunZn/A/8tMhCHX9meydKPFGNA1y3xvtXh96prwYd7h49P3rj8QjcmWoVZuOo61gV5hylSb0ITvcXwO85/qgcKDTN9FE7HXSt/75SU3EfBAE65JaKjvP5jG0cn+w5n0TUyqykDaEXb13fq5E0FnsHFoNwYDjY0MxlenJYA5FqbHxFiMJYh6737nHPoWFQLMLJAJRd92g5xgOsZeGOl9is2GmDu2IW75Xg8V/Otal+Orz9v7U1PP2g+MTtPondDI7Wjtv+LeNNdrbl3EnH8pzOl3AO9T1c6dsz57PnceI7YZvLUZs+ldxBP8zxOf+MSbeb6NWjQUhHVzcJ7HmrIn8Ksxez7pQb9+07tsAqmhAFfe1/vVr2wAqFH7CABrePYdXHu/AJ4CGaVn70fgr/ZvyPTYynSRdpOJfkDhc6QE5DzGnZxvMPBsR2Od0PBAY9/u3gajz8GerXp80zXa0Wia67lWQcx542GkWee2f4kOpN8Q0I0VMNYDYM0lmq2k+QDzZiPzxmwhuy0ab2CKYi9rg0Z3c6ro0zCcPhuCP4L181auXBmav2b/IYD/tQgA3yya/8DR/nb1i8Y+5Pl/hZc4aFc/AVmTJRNlKhr8dJuIAOQL0VqOhoEt1jepKTAF9JhxkL8brSsjV+NfqLZkEI8MIy3hG8zMs0pQbqsTw1ABYDDiHuz3qhTexBAGYy6dMJGmfbI0n38bSY1nqOBffScDjVe+57z2OpXnkMlEnIBrwVFzpBYBhQDjBgxy4vfpVglUQDQlrGleDHVM24FmtpbkOcV++lj3oglrCVhtPAC+zju4r/Xpfuf/5je/OVtt3ZLGHKf/Wv9FU8VCfa1WtluDtnQLQsDd7L+NxfTHZabuWYZX4TgBv6Aagk7dilAV8IYimDUJlHk+p9ifA8nMa/zDHiPp1fgVzA2606XhM0qfPme+dvUe6tvyO69eezAa6QTEm+hgKMcNJBgPdT4NJnB3CsrV6w4k2LUby/p1mgSHurDgMfkd5fmfx6ZCv5EerHvO2hkK5hbQSumdZshs1kWg0M4cNxVxu+4Djrf3xmZiRmzHbTqosSRmCu3VdSZ9DTbW2eeP2f9ScOZJ4otm/7rgnu85+fxD889mf6xs3ylm/4bCKRXN/9dJ8/8qA3hbQ1e/qnm96xOf+EQP0txsBn0uWs9C/JL2B1ebP5nPai/h7+MlqTGoxeR0JBmJlgGru2kWbFUdq07WThjEYFLxQBNrsPMPNinbAfRgx43GdQe75lC0waEysibwrzITfzciuwr8VYCoCwh+NyCQtW4ArQNafZxD0Ve+TvR1ZtZOOBqMsdbHMDPCpBV7T2o9mj038Hmz98dvFjPSt72E+5rjXM5AXZ2b+VwcY1T2DhjgWgOu/M51Z2vaN36Atec4qP9BBuiRBqzqu/MzjDssgQaVPSpzhKUt4oWy4J0Fo/o8GWjcq6DS7hkOB10MJEC3E6I6mU/txmKg7dVx7EThGIzG8xzJYF4VugY6f1VQzce2423umyx6kVKHEGBfDSs9RowAx0fVR60DKZB2u0GFuAQeQGi+i+UBNPFHrCfCNbbjCt4zUPVQ7yNH+wP+r0HBfDICclT4K+Bfe0uH4PPvxY/zKxv7/N7v/d7XWd+Gn2QnLzOCRoxs1tduvjwvwLSsORYPMj9eTcUiLfpkLTNqBTcW/TLRG5zDo3Kb2oKMxHVaIkWpzlSctE6wOpNpIqROGUa7yT9UTWEwAmy4n1GNhE330zZqKj9flajbCVjDERCqoNTEJDOzrWvrVQCogn9VaBB52C8XP8m52G3Lz1bfzUDzogoAda20OucEQf+8jcT0cuMaTaDmTWuVsLSs7qww91cZUnW+VsCPQw7oY91jPITPx2+mslnQJqxfnrNJqB2IMXf67PX5W6eLzNgT/eWxz8WoGmmyE+Cq01mndDsYqNYFiQ7ouV8K3mD0PEK/K78OeKoqYFefeTiCbdM7rvLT+thX59VAfLcqXHiM+yqkJ1dBLmAUqYTJKhZ9Hyz8hLC7wQZbZv4g9D6EwGChLVtymz1i9UJTg3eYaYCVYHduwCNOfOxjHzuV+LVnY/a/GLfYU8zy0uzfCfhPKp8/qXNzkaZOJHo4KvylPP9Bo/2RxDT734GE9r/Pfe5z/4fPt+LL2c4LO0CA3kzA3sIrRtcfjYZiDq+Ar68+CuOkAjn2eV9sExHzemFmajBVv32j/686GTPzrU7IJubSREyDMZT6MXkCV8FHYScviYhk1sFjXCq/5Qp74R9zO39RZtfv6aCouJePrazjfDWw7Sck1LlFuodcmCSnKuYCQ/2KlHDuah+BvE+rGJHgkp4554VHuhZLTqkKTS+/i3bj2vSOmvYd7F3l3wc6Xx2kM9Mf7NxNHLdT8G9wAbTSIvP79r7UjjNgtwPo+rn4HnPJ42Gg8W60GmQGO9DzDQZIg9FB9fg6bTW9i/r1BnrHQ7l2u+eo3kMejySURJqaYyeN1enT8Uzbo0hO9Xum0bRu0WRtn1YRrQYAbVXgS79V0TzoMr37eiGvamXBVo8P6c1543F+9v37mW05niWzgFbhsESfrRTHOn02gXp+juq8HOgd1cG/xqP6zc/qe8o0VTl3LlQUHTctTWxdgVRAay2Cr3UFNtkXwjgYFstv23ArCkoRW7MV/DBAdgY4dhom+2f+6Ec/egXg/0RLWHcA/tb2t5/EtZMm4K8C/kb7nzsE8N+LdPYAg3Uj6RrXYgW41TQQgF3t3BahpzDoJ1mAxcprCgK8AAUC/bBG6EfFLot8sFjbvl8DkaZJ1EBgsaku7TZJrVUGns8zwKSuA2tuUhImThmFi1Ks5k4+52C0DN5RQpfrGPgSAK9kmxe+t3Lf9Vnz3SVv85hqWc9WQE1iYlHSy8eujIeE34+5yBTYLZcKbpUPNvgxaYsKWaZTRU1y9o3qhAmY+tUySGMX1Qc9ZwqgjGP062p2ToVjIpe7Mq51jbTR59vE1NtpFO3A0nNkLdTPTbEe9bnSdN1229oxtXw/+ZnzPKtr9NXjq6+qfnwn18+CQXYXVM89EmA60LhU7z0LWHlbu2eunq9TYa+Dd9Oa/xWgr9JpNLpJhW2iGl1aAvAVsqVLPkdgaYU247M0KV27WNsh7+e+efF8fA7BINFm9Z5a4J/GJdNnptWW4MyGKAcsXUmT0pWLwZL5M+eIuiOuUxxFK97J4138SzQffUGs6ZDcMLlBU1hNK4J6v6wnDu9X9KnOV+vvJL//+n5Nc7pOt5lOskCSz+12XUm4AKwlYz8Sg3ijQJQVCHPVQoQAa4Cstsw2vvq7WewXsdFgXzDsVED/7FtuueVFfLbuxyLz/Jt4gtev5vlPSvCn3v1LyPMX/M9isMy/PajOdyZyiY2XsR8tfwOpG7/A5P8TS50a+COYo80fRzDSaalNqP3aLbnqOQV7Tfk5MCnWNcDoN8cGY479Me9gllGfdNk0W2fWaTJmrbxaBKNVwMZgMtNcePaoWW+qS0pDizx0xiVAXObBRMvVs6yg5W9WzDIyPWrf89mCGubBRplNmY2gL7ORqSg8JAYl1ocA4Hef0M+cP1f1Cknf50pjGYMgMxDYXQvOfpZpyBTSEoWMUqZEZEv4OTEZAT1+Yx/T0EKISEzG4yN9KwVn6sqxnoICXRRc8v1mhuY9ZSEkWXU816BFZvL7GQjMmgSEPB+q7zfPik6YWQegc8R3qT9jet+NWRr1+V+9+aaxGgyc67+3uxev0+5cTWBRZf4ZGOoD7bxPS+5bEUJyBnIzRKw7kOjTeIscULYj0VoUmuL6HhcFp6RJ6TMFjQY9piwS1yEEuBb8M21Kp8zlCGbLNGnmQ6bN+n1nC00ak5ZmrgVHPsuxQavSTaJRq1NGIyLuNVIk/SzdsVgUyiynaFKkcMC+UQZZWuW79Kfb1OOtpSCd5t4NmT5DSFAwSEpC7iWSgzJbQkBVoKvy2gzaA82XOu9umit57lZ/k66TgJvfdyhRvlt5sKXlrRhpAKGpsODQXYC/1TatLTHDYFgCah+DMnuW7XzFs9o76JdSWwH/jSng75pJEe2v5k9Hv5PM86+Cv+k6Bks1MQtflDmf5vjqj8ECcJ/NTyQUc+lTpLWgrx9fYMjpeNEXvMqYq0y+PrkyE6hLh0331I7BZ7DPhKm/SYaRADV8si5K9xI+ky4WiZ19ogQmv0dEOftEGVqX1DjDwhWtPPTMKDwfRJO1hxYz4XcZUhSqUUCQ+XCNYC78JtOyPnofY5+r2WXtIUA/MxjHvjoG5kUz/lOwqkwx2trf3Mb+nPbRNqOuDZb0vQrkXD8aFvGuoj2uDCS5XcICYMQ229QeAvz9k1nIYFhHnwPOZ7rlfBaFO3sdyGz0Z0c/BBmR10qfZVQyL5lR1mJasRzy0iQotGI62knqVaAYSDjIjKUJiKpzren3OgOfaN+bnj8z6yY6bKKvpvGtH5v3aaJ5f0uWtBYzFtwTmGeLWQjEiU4zbSosG0OR6z0oQAvi0qbBY1FOmvlv3wl7TuxIoB60Lu1LIhUBPdJGNTenbTmLxCj1EMT9kz6lPejE9rvxOdNkXncyTzKNuq7TqTSaaCGsAKlWQvBPPodAILh7O2mxw2iAfjourAYKBuwrLerCDWurypdZGEmQyHFVYU1IQobnzH0Sok5KUtRyNdOD0qWr77VKR03zoN3Y1Odidc7k82eBwLVzxgyC1AfE7AB7a0R/Dd6JPG4eruQl9rVAEPDZfY7W5T1nVdiogP8GfP7fQfufPOAP8J+MACD4ayYJzV+QqDLf6gupvAjTfBz87UZqyrwFEAOaUo5+pFnVCT8PfvUFtGPimSFVGU2bSZZ97PGz/7jPCC5J9xvmdMHchZ8F5TApmScumMsk+C1qW8ss2Cc0AatVuQ/bo/61CxPNtUzGspfmpnpOAT2ECyTR/Qg/MgwroJn7vJ8x2U+6lh3j7NPdZzc7yrMOuS98Jwym3T6+I34z5bKb63fbptgGOtyrvctDOMBk1sN9Z43dbV08uylc4W+UmKy4yHEW1FHzj+6GfJ5reh2EZl8EtROZkBqJHdiCEbEoJFhy1uI2LsHMNHGq9aRFa1AO7myZS9N779eUpc58qnPjUMZpoh7bxGjzs1bHskp3ddqs0m31cxON+nu20CS6zAJtWLAETUFUzS5p0SE0aw1LGnnQnoDOOhrQSKPcU1jSWBsIGV3sOIeloC03G4v54yooCgp83s/nPrTDEK5dpFN+c1tolvIKmP9+yiT3oU32tWsnfLjmBs8WrcThzT1YVqVVhfFuLKuWtu6B7nq451YHUF2uftfcz2c7k6rxy8sNuLZfgjVTTKE2sDpSMQV9F7+z1nqXO2VGtVT2sXCav2kNDIug96AiIC9RsZCfpHmQrRoxFYZLi56rPv8qcyjwJAsBCgJaBAyItQEX35XUbNo2zdLZWYn1mDyP24C/bbw3Cv7U5biGd3891oP1E7qxz9e+9rV5P/3pT08i4O8lmEkE/zOZNC2zf5Xwq5pBltgz0UpESldOBhm3k8MZUX2RdUtClYjqTKmJ4fjC835ZqEjALiGHBi3Ac2zkgwvymuY1EwnSCip8j+YyMhE+m1+6nu1WZdvAOlpfOomYNKGhZ8tAOn+Y6P0z4FGtgD/71h8ga+EAaSnB2AD4WEO4U+jFfoCGF/GdwMqWxl5JV+mnxR9GxhLESZOZWHM/U+iE2Iob4F5bn8nW6CKuo3VrCAddPK8CgS6FcBUwbqHtq50Yha5VQeZkPAfjHJXeFAjN9oARLWKtVWiJwgBLCAwcK8NRQJiNYBHxIGo+zikZITcQlgLWajrhPqguGXzqgFSfw3WQqoPfcJnW4Xp3w7lOfUyGc458TDLJ9jPr1wX6bC7OTFr+oAbPWo07BGRpVTcYoGyFRl1ipn+FEJ40dwO7pEubA21IgV7WE4iKj9IocyO0dC1q5pKnoK89zM+9MP8+YpH6iD86YCCy9y895ufIdMm8n/KEJzwhth9puqy/lySst+iUew66zPQJr4nv0qRr6dJ2yHZKhG6lzx6EfK1809GEA8DZzcqpufZCxPxIt1xLV4LCvAHYQZ9sX8g2+2Ro5dOK69qUa+lZWpfuc7EmBfaw6qVt8ThV0K0+X5XnV8G5Pgb1/fLvGVsUIlX0BH4/O2YuSUBp7OlQpYek+e+2lwgu7OsmFfgD/Cej/evzf2Ed/Ksvrwr+lYFvvavBmHGVyTYJFVWm3AT+6Zo5QjeKqUD00T+c3wT1XChCrT2ar8AQtEqExs46iklkbV/zvZqCOaTmUGs6JG1E818E8ijYuBBYEmY+mEiY5ceCVnAozHskj5XIbJ/MOXsA9W60qC41ECVuvnfBRPyuEBA90LEqWcZVs9x8LQbGCwj4rrUMJCZjM6b55rIns2WUaeYaWpLUWHLHRZlVtFBO5sl+VoHq3G3HdBqY7UgOz7g5VxODzdvqWlg7QcLtMmEZMA+e0xxDUNYkLz2yWPO910XLmzQJ7YXG7mdpWPBXCIDm1NytDLeZ/W0bbcEjjwlrmtY1tPQDWtM0yavV22J2xYoVffQFGbQYzLh5OYdwo0l4CEuf7c2lUS18jF8XAoMWvy7GuUWjFsWyiBoKoCWipVEBX7oU8KNJlAKAn6Vj1tFAS8GB965LISwN0mi26mVhgHW49Kp8vvpodY283WPXFcV8voxJdZypY0n9OlXwx+R/PdH+17z85S+/HiFqXbUxVyevYeAEzU7OcBj3SZr/KSngT/B/WlXzbwL/wUC6OvhVKS1rDO3cCdV903VbUnpiKBHBq0YvE5E56OdRO+AFRv/wxECC0chEmOQylug3rxkQ4M514g0a2ceyhyCPPZh5LBAzog0mDuNrHDeXkhlRm3463efswBjtkGU4dmPUxJi0inl2qUtpoWoa0QyGh/R3e9Hb+W0xn00dVYCIYNKsdchkamDf2MuhzhTGzSAO4UarwN0pM83j0o6ZpvNUaTM2abaXPhXKWdTmFboVrDdBi9LoZoPw2NUuf9HwxWpuVlbDeraZ2KEQ3rXWqdlDm5YQ34Mpdg+ZQ7vpsd4/CGkI41B27XwEbA9NltYMhIDpCABRTwJMsDiVgns0TINe5xnIbSOm5L6zeJsCgnQrfR4jjSbLXrgBk5Ce0xfjhrJlo4H39/PL1+i59Vsdn+pPWbUo5Pks/rTT/AV/NP9vXXbZZdeBCxMb/CnGcxSa/ynUUA7NHzfHU6s+/6bBzNuyH6bOLDLDyQM/mMmxzqDSebMPXzNOBP/IVPT/sdg5aiNMZRVa+X0wjXuR/o323AAj2cpEs72kEbx72aeXnM/4nM1/mv5uu+22YF6a+zT1JeGicwopew57BCT47G7gPXTxDjRRdsFcujDThjuB9wt2zIwoZ0GdP4WFWSxzUmtmO/idyFw9BSa0XDOlWolBh5owswCQCD4sAmk+Rind/NdkbuwEMIf98Ef4wMwAmyxrWStrYsSV227RSthXH/XPxjYBP7nNFLalRYOBrdR2PzVAHjY7CHoV/CM7hvcU/nre3R782XvRuPqYBweyaV6zvK6yQp+Hf9I00ah3Ab0aIyTNTuW9Tqcny0zepe45A71nKgzYotl+E6xPR2g4ie3L+X1Bij8whiDaqbPkehf9UoKbLE71uTmcEekE/BE0b2AeBvjDV9YhcGpF7vhvXGn+gj/Afyo5kYL/70OELfDPPvrqy6i+hCZQH8h8WDW3ZImtwoxyUwh9d/rd9fPZznUr+4SPPgXkbdVX72JeJ0u0l2QibsDktwtm08sSkfPZDHjOOefkPtYdv8Sy45EdAbUPutl1V4OdAPoe5qdayFyYy0K+L2Y5xkJRWgkMVlIr0XrAnNFNEEFMzGOFgoX6Mk05VQsxsDDNwbqVIB58IloFqpp8XSNq97YFeH9LwG5gnW60jdCfpYYNvgstPS0RUyNtJo1/PaCfi7BsgT61yO1Do9rH7+Hz13xfzPRHltaGc/WksXfj8gt3n64EaFL6nEHcgQGGi1Ekl7KO+i7QW7j5pEXje7imwb5a7HTvWXtf4UB6zfE8/ehyIHqsCrRVRbSJjrNg36D5W+THaP8VNNG65g/+4A+u4z7XTmjwh8nOv/32209NZv8A/9RRr1+ef7sB7oRJVgUCADz86WrzvJzsW4+8WxkJv2+zP7p90dEcHoDZmMKxRdO9WoMRv/rq+c0KUJE/j7a4i7xMI/OPSPDccIinHDP8EWDu9MB07P44C2vOLJjNLDtDapI0qDBFM4d5ksUAQ4WEE607gdaylP0UBGwDnU2QrYhpt7loOehkbg//KQ7/kdJh1VqXny/76bWuSZt5LX1mqxs0twmgXo9gvRprmiVXV+tyS8JA+PLNkmE/O7jFAn3uIthsJ+O+CyvN3uKHP/zv/Ehckfc8lQDh6ffff/8sBIBZvPvoy2KJd2hPmjxKQR3NeiH0eAxCw2NYS5v2u9AyoOUuhIBkHaimGh5El9UA1Dr4V5+/Ss9twH8jAX8rDPi76KKLvjPhwf8rX/nKAsD/tB/84Adq/i/A5/8UwF+JrBWc4QDWwX+oplH3N3jOqF6YRIA2pw3/XgrYk3mYomMnp3uQwG6lB/p9bNuonx4mwlzZ1UuQyv5kBuz3Xo/EJC/XPOIj0C+dSFcCZuOexz3ucVOZQ/orZ7LMQaBd9MADD5yKkHAGQsDpmCOP01JgQBIMIWoPuIbYo3BKWiLVcDwLAFUGVzelVpmkArkR89JkAvEcea9AHemujOdD0OF9+ODvRTC/B3q00+AWtCX99sbL9CKQ7c9utMwz0gwpQvkRJ5UjcgMt+pQ2n/e853Xfcccd05lj0uVMXAbG9iy+7777ngTuPI7PJ1kvhDudp2UAOtRCF0WKXOtaMAmL762HGQiHMmblfZqsXW5LAX9R3lfwZ7nm/PPPvw4sWj2hNf8M/t/73vdM9ft9wR8GaUpWx+DfZP6vEL+WQ/N5d+mT10SvZo/GsNb0HZjOJpiOkfaRY8/EkKFsQLNYgx9/C8yml/vZj/9v/5HOuz0i5FMuOqQRSObIiG7WZWCqIRrHNMDf3hJH2/feXhPJ/BguAcBfk6OBSjOKeBcAAAzUSURBVIvY130sR23tAosW6T5oNQka0s2MwZ0rZs/IcTcF1qBYffTQ5yNa2kx/TXRp9L059ebJG5ina83APTX+nVjc9hEgFRUpC22OwZc9xm4p06bdXZljPVgGpqJoTkc4X2Z7ayxES3QJSJPsq4tAV4FBvQYQLtUykJrCzU9pfEzhR9sL14TNAbdV962Cv1klSfP/1itf+cpr2W/igz9BHKfTBOEld999d2j+vARNp1EPuslHkgevOuhJs29V4+J7dDJTI1Cj0E8IqD/E8iCmQ9ePwFD062/iu8zHil29aBd7eAGm3LU6NY2xOVxuZxyOAO6t6bgIjFaeDQOxOmGUSBXkme8LdA3YhAoT5PEwmeMtEcq2hboOknUglz6OTnqmFlZdA3UmVDcxDseC0E6obhr+Jg0oaT5RMS9F4UckvrSZ6RJBfDPLGoTyh4ibuS+Z8/XTb2C70fo7ec59utgwh+4mGGo3MTRW2CupdOOQDsbiLX/qU5/SEqBrYCbCgDQ5S+uzLd6tEssiXR4nbUKXLsfp2uNZ7IwZLgJp0jV02XLZtaO5TFeORQX8e5njm7A436jPH2H2Ws71yITW/D/3uc8tRCs6/fvf//5L6MYX4K//VPDPKRF5EJsGMzMYmIqNGHbDMEyvsxDHFjSETWoJWavAXPigfny0+dUwEYP5IvVuqAM8FidwuafxNwJqIlRYnIWrQIFgLgxnAabH5cYHoI2YSbDMLALowKAkgwbzMtvIZquIpbTVgzSQajpR1exY1zqqo1YH+2pqbNN+mXk1ueTkax5vUF3S7iNvXi3fdDu2b2XZDMOzNvqDmPE16UufG1m24XLbDi/YW9Lrxt+8Hu93nCwEBhPOYg7OhSbnA/xHQ6cn4LI7mc+npSDBhdKmNQdS3YG5CAoWMlI479ekqAr40kU13Rzr1hRrUQj+CLjfTXn+13LtR971rnepwHb8N66i/avgj9n/BQRoaPZXCuun+eenF+QdPAdTjYK12oQpO4L+OgbwYTT5+/WXWG9Z0z4Du5lFDX8jL0Xz4a7HP/7xpvbsK5G+Hc+rsuMojIBZBZy2h3TQHv2JzH0LCy1CEFicKhHajtoAQddmFWiePBbrwNFaDHLJ04rW0ao6mGgk7rrKbJp88QrW7VJn63nJ9WHwuCwoqJHzOfvwpcvtWthYHsHatlqw19qmYM7aCnoK5xvR+iOC3yI6utmIq9GxWlJgR2HOlVMOPgIKABYPw1pnuXhddzMUzqE7g3eXSo9m8EB/ViOUFo9lOcHsH7MKrBkC1li1MPJ6paG81K100EE/8CfL6JqXvvSl34FmHsb3P7HBH3P/6T/5yU9ywN+TNfvr89fsX82JdhBhELnsbTTTyGVyAXcD9R5Ai7gXRnIPDGWNxT1gJjKfXTCe3YD/bvw8vSXqd/DJX/Y4MiNwxRVXTGNOz4TZzDT2RTdBqotu74JFRicn7UPLwLFaA1JFMyubRVCSJY91C/AELUWgXbBRO0GgbiGoai55ZDxndrdBl5a5tWpe7kNhLfytpsxCd7ra7ocGV5l6B00rgG9jsQKm6Xu7X/CCF+wmrkaXQAnOOzJTr1x1gBFQGLA4GBUdZxL0PceMNMBc9/RcAnmPhhaXYyE4BavAydDpseDX0WYUQIeRPSBNKtzrFvAyVSu2mj9CcMS1YPLX7P/tiy+++Fq2T2zwN+Av+/w1+2PufIrlHbPZX01fhpCW/QySDMU8e6t1WW/bQCFNhxbyuNf+ykQBP2Kwnm6AYjYsND2eRyCZIKfBeGYiuM7DFLgABnQi65ONTlYgMI+ZxbXWATURuxwaTBj91NPz9ytkkhnQQH79JsEgm/gf5V+oNZTTTWZ9C19tNh0vVbzcqN/e2BpN+gjkDxJLs4ZlK37NHaRi2UCnAP14npyT/N6d/gT2TkcYmEsWwRLcAsfy+TSEgVNM69U1YBVQCwxZhtjGY9YSYNgiLiDXrFHBhYYE/01o/d8V/PH5fwdaWjWhNf8M/hT6uZCSq78HU3uy/k+LNjg4ybQf9fNhKtvU7NUi0BoeVDJKwUIynPUwm40ctw1m02t0PsBvUFBhMJOcSMf742cTJM/RQ8U5GxbZJjQsAQC8TCUsAgYjaRVgiXoClj9NgYVWNItaApnhZEtAE8Dn8cq/JTqMzX7Wj2+xHIP37FWhWR96fNgUPMBe2lzFb+tTv3OzZzZBnztsoIPAokm/FL0a75Oy3H8Yx7Aid6Fo9pCuPtWSxLi1oiERtHgMa/PDl+kSkCaxCpyIFW+Z1jrTeqFB+41Ei2CbQkEfBvwF+FPb/zorVE548Ccl6rQf/vCHF5Jv+TykpifC2GzkIHBr2rfTltr+RgZ2Na0lb0eLuFtNgt/WIAxsUZNgoHZbg/v5z3/+/0vCLBO0jMAEHIHrr79+qvnKMhAEgem6yWAuZg0sx0d5CjR0KmbJk/luQaFFdilkXysLRulh1kYnR1fC/Jd9/tXv1aGD1rJZXz++fSuizS3ayVqE7gehx3sRuu9KQbUWydrO0itN8lvv4W4dPQFfe3mkcTACOXMA2ptFHYGoNCj4I/SejFX7sdDlqQgES60nYNMw6G4mAkCPbjP7TGC1/gGxaP+L2f86MG9ig3+u8Ldy5coLMGf+DoPzWAMlZC6a9o3UN/cXBqNm8SApeHfCZB7CfLiW9TbMI8VPOA6Iotzi6I2AlgEqZE4lbmYh8TPLsJ6doEuAxbTBZQD+QpiN9QMiiNDIZHsW5FzlfGc5kFZBIFkIwqyv9Q06NFJ/k6b8FES7Kfe3QLN/QNM+GstDrDe86U1v2l5M+qP3vsuZx8cISJef/exnZ1sKnGD25WS1nYaQfqoWAAUAUwihQ0sPz9Eqp3Wb2hU3gW3fufTSSye+2R/wnwvjOonl/FWrVp1lxKQ+RE2HaPn3A/aR+8uiNrGOgdqEZrPruc997r5S2GN8EEG5y9EfARkNVcw07U/F96j50cJBi1iWyGigGYWBU8mmkQGdYMES4wJSNHI0Hqr5/wP0DbDFHLkT+jNoz8p6d/L5fixuD0Oja+2IZ0EerrkVP/5eK2CWgNrRf9/lCuNjBKCF7uwWsM0w9GTtjmMJELQxmM2HjN05Qdcd26dBX7ei/V/3ile8wmj/NUNNQx9XqX4WP8GPuQjT/9loLJpE5ttYxxreMBgD9x7BbLgNZraD9LxdpcDH+Jj05S6P3AjkyGSYygzrmxtohAlyqWWFjUZGADgZ8D9OzSM1HJqv9qElIAXW6m7bbnqsaXiCvIBv90rL6yqMI5ibSbOTcrph1h9q3/EjNzrlymUEjswIpLTe6VgA5kB/C8C7KB6EYH6CDYjs94GCq/XsZxdccMFPwcWtCA9DcmOPK/CXUX3605+ewYMeR6DffLSNqab+wFC2ovVvNVWP3/YVbeLITNhy1fE/AilgcA7xABYRWkJNgeUKAmofMJ4TcbUdb/2AVEpY3/52S+1qztfVBjNaZUAfwviaM844Yz37bx9q8ZHxP4rlCcoIjNwIGLeDpXs2tDQfIWAxQoBVPuciYFvr4uHnPOc5q6hBM+S09HEF/mk4uzDhd8Ncuuml7f335V7agL5RSSVif+TmXTnTJBwBBQBMiN1o6kYnR7MhtI9jbTikOwAmZCSyrYh7bVWN4H0XoH8P9Pggi7n52zHp21u8r9DkJJxA5ZFHfARyFg/KbRfC9gzM/bNscAUd7hlul9jxCP4jPrDlhGUEygg0j4DmR9OSbEWMFWAhwG/DEmMA7Cy4z/K7aCBrNe0TxLeNIKTdxfpWZlMZgdEbAWNvqCg4FaG771CqzhbwH713VM5cRmBCjYDmR4DdlqWzCLadCvBbmjcq9b3zne80k6Y00JlQb7w8zEQegQL+E/ntlmcrI1BGoIxAGYEyAg0jUMC/TIsyAmUEygiUESgjMMlGoID/JHvh5XHLCJQRKCNQRqCMQAH/MgfKCJQRKCNQRqCMwCQbgQL+k+yFl8ctI1BGoIxAGYEyAgX8yxwoI1BGoIxAGYEyApNsBAr4T7IXXh63jEAZgTICZQTKCBTwL3OgjEAZgTICZQTKCEyyESjgP8leeHncMgJlBMoIlBEoI1DAv8yBMgJlBMoIlBEoIzDJRqCA/yR74eVxywiUESgjUEagjEAB/zIHygiUESgjUEagjMAkG4EC/pPshZfHLSNQRqCMQBmBMgIF/MscKCNQRqCMQBmBMgKTbAQK+E+yF14et4xAGYEyAmUEyggU8C9zoIxAGYEyAmUEyghMshEo4D/JXnh53DICZQTKCJQRKCNQwL/MgTICZQTKCJQRKCMwyUaggP8ke+HlccsIlBEoI1BGoIxAAf8yB8oIlBEoI1BGoIzAJBuBAv6T7IWXxy0jUEagjEAZgTIC/z9KwlrSOcwPQgAAAABJRU5ErkJggg=="
                        alt="Buch" style="width: 24px; height: 24px;" />
                </button>
                <button id="readingModeBtn" class="audio-btn" title="Lesemodus aktivieren"
                    aria-label="Lesemodus aktivieren">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="sceneDimmerToggleBtn" class="audio-btn" title="Hintergrund abdunkeln"
                    aria-label="Hintergrunddimmer aus">
                    <svg id="sceneDimmerIconFull" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="8"></circle>
                        <circle cx="12" cy="12" r="6" fill="white" stroke="none"></circle>
                    </svg>
                    <svg id="sceneDimmerIconHalf" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="8"></circle>
                        <path d="M12 4a8 8 0 0 0 0 16z" fill="white" stroke="none"></path>
                    </svg>
                    <svg id="sceneDimmerIconCrescent" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <path d="M16.5 4.5A8 8 0 1 0 16.5 19A6.8 6.8 0 1 1 16.5 4.5Z" fill="white" stroke="white">
                        </path>
                    </svg>
                    <svg id="sceneDimmerIconSun" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="4" fill="white" stroke="none"></circle>
                        <path d="M12 2v3"></path>
                        <path d="M12 19v3"></path>
                        <path d="M2 12h3"></path>
                        <path d="M19 12h3"></path>
                        <path d="M4.9 4.9l2.1 2.1"></path>
                        <path d="M17 17l2.1 2.1"></path>
                        <path d="M19.1 4.9L17 7"></path>
                        <path d="M7 17l-2.1 2.1"></path>
                    </svg>
                </button>
                <!-- FULLSCREEN BUTTON -->
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild">
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="white">
                        <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
                    </svg>
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" />
                    </svg>
                </button>
                <button id="subtitleRecenterBtn" class="audio-btn" title="Text auf aktuelle Stelle zentrieren"
                    aria-label="Text auf aktuelle Stelle zentrieren" type="button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 7h10" />
                        <path d="M3 12h10" />
                        <path d="M3 17h10" />
                        <path d="M14 12h7" />
                        <path d="M18 9l3 3-3 3" />
                    </svg>
                </button>
            </div>
        </div>

    </div>
    <div id="sceneDimmerOverlay" aria-hidden="true"></div>

    <!-- ARCHIVE MODAL -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title-wrap">
                    <button class="archive-primary-btn active" id="archivePrimaryInhaltBtn"
                        type="button">Inhalt</button>
                    <button class="archive-primary-btn archive-primary-gear" id="archivePrimarySettingsBtn"
                        type="button" aria-label="Einstellungen" title="Einstellungen">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7"
                            stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path
                                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 0 0-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 0 0-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 0 0-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 0 0-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 0 0 1.066-2.573c-.94-1.543.826-3.31 2.37-2.37c.996.608 2.296.07 2.572-1.065z">
                            </path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                    </button>
                </div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>
            <div class="archive-tabs">
                <button class="archive-tab active" data-tab="kapitel">Kapitel</button>
                <button class="archive-tab" data-tab="lore">Funde</button>
                <button class="archive-tab" data-tab="lesezeichen">Lesezeichen</button>
            </div>

            <div class="archive-tab-content active" data-tab="kapitel">
                <div class="col-left" id="chapterList" style="flex:1;">
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Marktplatz</div>
                    </div>
                    <div class="menu-item active" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Antiquariat Hannrath (Hier)</div>
                    </div>
                    <div class="menu-item" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse</div>
                    </div>
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lore">
                <div class="col-left" id="loreList" style="flex:1;">
                    <!-- Dynamisch gef&uuml;llt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lesezeichen">
                <div id="bookmarkList" style="width:100%;">
                    <!-- Dynamisch gef&uuml;llt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="einstellungen">
                <div class="reader-settings-panel">
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Anordnung</div>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="blaettern" checked>
                            <span>Bl&auml;ttern</span>
                        </label>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="timestamps">
                            <span>Timestamps</span>
                        </label>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="flat">
                            <span>Feed</span>
                        </label>
                    </div>
                    <div class="reader-settings-group">
                        <label class="reader-settings-title" for="readerFontSizeRange">Schriftgr&ouml;&szlig;e</label>
                        <div class="reader-size-row">
                            <input id="readerFontSizeRange" type="range" min="14" max="30" step="1" value="18">
                            <input id="readerFontSizeNumber" type="number" min="14" max="30" step="1" value="18">
                            <span class="reader-size-unit">px</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Schriftart</div>
                        <div class="reader-font-picker" role="group" aria-label="Schriftart ausw&auml;hlen">
                            <button type="button" class="reader-font-option is-active" data-font="segoe"
                                aria-label="Segoe UI" aria-pressed="true">
                                <span class="reader-font-sample reader-font-sample-segoe" aria-hidden="true">AaBbCc</span>
                            </button>
                            <button type="button" class="reader-font-option" data-font="times"
                                aria-label="Times New Roman" aria-pressed="false">
                                <span class="reader-font-sample reader-font-sample-times"
                                    aria-hidden="true">AaBbCc</span>
                            </button>
                            <button type="button" class="reader-font-option" data-font="arial" aria-label="Arial"
                                aria-pressed="false">
                                <span class="reader-font-sample reader-font-sample-arial" aria-hidden="true">AaBbCc</span>
                            </button>
                            <button type="button" class="reader-font-option" data-font="constantia"
                                aria-label="Constantia" aria-pressed="false">
                                <span class="reader-font-sample reader-font-sample-constantia"
                                    aria-hidden="true">AaBbCc</span>
                            </button>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Lautst&auml;rke</div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerTextVolumeRange">Text</label>
                            <input id="readerTextVolumeRange" type="range" min="0" max="100" step="1" value="100">
                            <input id="readerTextVolumeNumber" type="number" min="0" max="100" step="1" value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerBackgroundVolumeRange">Hintergrund</label>
                            <input id="readerBackgroundVolumeRange" type="range" min="0" max="100" step="1" value="100">
                            <input id="readerBackgroundVolumeNumber" type="number" min="0" max="100" step="1"
                                value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Farben</div>
                        <div class="reader-color-field">
                            <button id="readerBgColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerBgColorPickerPopover">
                                <span class="reader-color-row-label">Hintergrund</span>
                                <span class="reader-color-preview" id="readerBgColorPreview"></span>
                            </button>
                            <div id="readerBgColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerBgColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerBgColorMarker" class="reader-wheel-marker" aria-hidden="true"></div>
                                </div>
                            </div>
                        </div>
                        <div class="reader-color-field">
                            <button id="readerTextColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerTextColorPickerPopover">
                                <span class="reader-color-row-label">Schrift</span>
                                <span class="reader-color-preview" id="readerTextColorPreview"></span>
                            </button>
                            <div id="readerTextColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerTextColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerTextColorMarker" class="reader-wheel-marker" aria-hidden="true">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="readerColorResetBtn" class="reader-color-reset-btn" type="button">Farben
                            zur&uuml;cksetzen</button>
                    </div>
                </div>
            </div>
            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer">
                <button id="btnSaveData" class="archive-footer-btn">SAVE (Export)</button>
                <button id="btnLoadData" class="archive-footer-btn">LOAD (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <!-- NO DEBUG CONSOLE -->

    <!-- MAIN APPLICATION LOGIC -->
    <script type="module">
        console.log("DEBUG: Script Wrapper Start");
        const isIOSSafari = /iPhone|iPad|iPod/i.test(navigator.userAgent);

        // FALLBACK TIMEOUT: Force hide loading screens after 10s
        setTimeout(() => {
            console.warn("Liminal Fallback: Force hiding loading screens (10s)");
            const l1 = document.getElementById('loading');
            const l2 = document.getElementById('loading-screen');
            if (l1) l1.style.display = 'none';
            if (l2) l2.style.display = 'none';
        }, 10000);

        // --- ERROR HANDLING ---
        window.addEventListener('unhandledrejection', function (event) {
            console.error("Unhandled Promise Rejection:", event.reason);
        });

        (async function () {
            try {
                console.log("DEBUG: Starting Imports...");

                window.fallback2DMode = false;
                let THREE = null;

                try {
                    // 1. Load THREE (Direct URL instead of importmap for old Safari compatibility)
                    THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
                    window.THREE = THREE; // Global Ref
                    console.log("DEBUG: THREE Loaded");
                } catch (threeErr) {
                    console.error("DEBUG: Failed to load THREE.js. Forcing 2D fallback mode.", threeErr);
                    window.fallback2DMode = true;
                    document.body.style.backgroundColor = '#050505';
                }

                // 2. Audio Player is loaded globally via script tag
                console.log("DEBUG: SharedAudioPlayer Available");

                // 3. Init GameState (loaded via script tag)
                if (window.GameState && typeof window.GameState.init === 'function') {
                    await window.GameState.init();
                }
                console.log("DEBUG: GameState Initialized");

                // --- GLOBALS ---
                let isLoreMode = false;
                let activeLoreId = null;
                let isReadingMode = false;
                const READER_LAYOUT_STORAGE_KEY = 'gameboy_reader_sentence_layout';
                const READER_FONT_SIZE_STORAGE_KEY = 'gameboy_reader_font_size_px';
                const READER_FONT_FAMILY_STORAGE_KEY = 'gameboy_reader_font_family';
                const READER_BG_COLOR_STORAGE_KEY = 'gameboy_reader_bg_color';
                const READER_TEXT_COLOR_STORAGE_KEY = 'gameboy_reader_text_color';
                const READER_TEXT_VOLUME_STORAGE_KEY = 'gameboy_reader_text_volume';
                const READER_BACKGROUND_VOLUME_STORAGE_KEY = 'gameboy_reader_background_volume';
                const READER_LAYOUT_TIMESTAMPS = 'timestamps';
                const READER_LAYOUT_FLAT = 'flat';
                const READER_LAYOUT_BLAETTERN = 'blaettern';
                const READER_FONT_SIZE_MIN = 14;
                const READER_FONT_SIZE_MAX = 30;
                const READER_FONT_SIZE_DEFAULT = 18;
                const READER_FONT_FAMILY_DEFAULT = 'segoe';
                const READER_FONT_FAMILIES = Object.freeze({
                    segoe: '"Segoe UI", "Trebuchet MS", system-ui, sans-serif',
                    times: '"Times New Roman", Times, serif',
                    arial: '"Arial", "Helvetica Neue", Helvetica, sans-serif',
                    constantia: '"Constantia", "Palatino Linotype", "Book Antiqua", Palatino, serif'
                });
                const READER_VOLUME_DEFAULT = 1;
                let readerSentenceLayout = normalizeReaderSentenceLayout(localStorage.getItem(READER_LAYOUT_STORAGE_KEY));
                let readerFontSizePx = normalizeReaderFontSize(localStorage.getItem(READER_FONT_SIZE_STORAGE_KEY));
                const storedReaderFontFamilyKey = localStorage.getItem(READER_FONT_FAMILY_STORAGE_KEY);
                let readerFontFamilyKey = normalizeReaderFontFamilyKey(storedReaderFontFamilyKey);
                if (!storedReaderFontFamilyKey || storedReaderFontFamilyKey !== readerFontFamilyKey) {
                    localStorage.setItem(READER_FONT_FAMILY_STORAGE_KEY, readerFontFamilyKey);
                }
                let readerBgColor = normalizeReaderHexColor(localStorage.getItem(READER_BG_COLOR_STORAGE_KEY), null);
                let readerTextColor = normalizeReaderHexColor(localStorage.getItem(READER_TEXT_COLOR_STORAGE_KEY), null);
                let readerTextVolume = normalizeReaderVolume(localStorage.getItem(READER_TEXT_VOLUME_STORAGE_KEY));
                let readerBackgroundVolume = normalizeReaderVolume(localStorage.getItem(READER_BACKGROUND_VOLUME_STORAGE_KEY));
                const readerColorWheelSync = { bg: null, text: null };
                const readerColorPopoverState = { activeKey: null };
                let manualBackgroundDimLevel = 0;
                const BLAETTERN_CONTROLS_HIDE_DELAY_MS = 5000;
                const BLAETTERN_LONG_PRESS_DELAY_MS = 600;
                const BLAETTERN_SWIPE_TURN_RATIO = 0.18;
                const BLAETTERN_SWIPE_VELOCITY_THRESHOLD = 0.45;
                const BLAETTERN_SWIPE_SETTLE_MS = 220;
                const BLAETTERN_BOOKMARK_LABEL = 'Lesezeichen';
                const BLAETTERN_BOOKMARK_SAVED_LABEL = 'Gespeichert';
                let blaetternPages = [];
                let blaetternPageIndex = 0;
                let blaetternPaginationDirty = true;
                let blaetternPaginationKey = '';
                let blaetternSwipeAnimating = false;
                let blaetternSwipeState = null;
                let blaetternControlsVisible = true;
                let blaetternControlsHideTimer = null;
                let blaetternSwipeCommitTimer = null;
                let blaetternBookmarkHideTimer = null;
                let blaetternLongPressTimer = null;
                let blaetternSuppressTapUntil = 0;
                let blaetternLastSyncedSubtitleIndex = -1;
                let blaetternPaginationRetryTimer = null;
                function isBlaetternLayoutSelected() {
                    return readerSentenceLayout === READER_LAYOUT_BLAETTERN;
                }

                function isBlaetternLayoutActive() {
                    return !!(isReadingMode && isBlaetternLayoutSelected());
                }

                function clearBlaetternPaginationRetryTimer() {
                    if (!blaetternPaginationRetryTimer) return;
                    clearTimeout(blaetternPaginationRetryTimer);
                    blaetternPaginationRetryTimer = null;
                }

                function scheduleBlaetternPaginationRetry(reason = 'layout') {
                    if (blaetternPaginationRetryTimer) return;
                    blaetternPaginationRetryTimer = setTimeout(() => {
                        blaetternPaginationRetryTimer = null;
                        if (!isBlaetternLayoutActive()) return;
                        const width = Math.round(subtitleContainer ? subtitleContainer.clientWidth : 0);
                        const height = Math.round(subtitleContainer ? subtitleContainer.clientHeight : 0);
                        if (width <= 20 || height <= 20) {
                            scheduleBlaetternPaginationRetry(`${reason}:wait`);
                            return;
                        }
                        const p = window.audioPlayer;
                        if (!p || typeof p.renderLines !== 'function') return;
                        const idx = Number.isFinite(p.currentSubtitleIndex) && p.currentSubtitleIndex >= 0
                            ? p.currentSubtitleIndex
                            : 0;
                        p.renderLines(Math.max(0, idx));
                    }, 140);
                }

                function markBlaetternPaginationDirty() {
                    blaetternPaginationDirty = true;
                    blaetternPaginationKey = '';
                    blaetternLastSyncedSubtitleIndex = -1;
                }

                // FIX: LOAD STATE BEFORE PLAYER INIT
                const savedMode = localStorage.getItem('gameboy_reading_mode');
                if (savedMode === 'true') {
                    isReadingMode = true;
                } else {
                    isReadingMode = false;
                }

                let isCenteringCamera = false;
                let activeLightId = null;
                // window.subtitleTracks removed

                // State to resume main chapter
                let mainAudioState = { time: 0, wasPlaying: false, src: 'assets/kapitel1b.mp3' };

                // Content switching + resume helpers
                const MAIN_CONTENT_KEY = 'liminal_library';
                const CURRENT_PAGE = 'liminal library.html';
                const CURRENT_CHAPTER = '1b';
                const CURRENT_CHAPTER_TITLE = 'Antiquariat Hannrath';
                const BOOKMARK_PAGE_KEY_MAP = {
                    'index.html': 'kapitel1',
                    'liminal library.html': 'liminal_library',
                    'index.html?chapter=kapitel1c': 'kapitel1c'
                };
                let contentSwitchInProgress = false;
                let contentSwitchToken = 0;
                const mainChapterAutoplayIntent = window.ChapterAutoplayIntent
                    ? window.ChapterAutoplayIntent.consume(MAIN_CONTENT_KEY, { defaultPolicy: 'auto' })
                    : { policy: 'auto', shouldAutoplay: true, source: 'fallback', reason: 'intent-missing' };

                function markChapterAutoplayIntent(targetPageKey, policy = 'auto', reason = '') {
                    if (!window.ChapterAutoplayIntent || !targetPageKey) return;
                    if (policy === 'manual') {
                        window.ChapterAutoplayIntent.markManual(targetPageKey, MAIN_CONTENT_KEY, reason || 'chapter-menu');
                        return;
                    }
                    window.ChapterAutoplayIntent.markAuto(targetPageKey, MAIN_CONTENT_KEY, reason || 'auto-transition');
                }

                // ============================================
                // DEBUG (disabled in production UI)
                // ============================================
                const liminalDebug = {
                    lastSave: null
                };

                function liminalDebugNote() { }

                function liminalCause() { }
                function liminalTrace() { }

                function writeStateHandoff(targetPageKey) {
                    try {
                        if (!window.PlayerStateManager || typeof window.PlayerStateManager.exportStates !== 'function') return;
                        const states = window.PlayerStateManager.exportStates();
                        const payload = {
                            from: MAIN_CONTENT_KEY,
                            to: targetPageKey,
                            at: Date.now(),
                            states
                        };
                        sessionStorage.setItem('gb_state_handoff', JSON.stringify(payload));
                        sessionStorage.setItem('gb_handoff_expect', String(targetPageKey || ''));
                        liminalDebugNote('handoff-out', `to=${targetPageKey} states=${Object.keys(states).length}`);
                    } catch (e) {
                        liminalDebugNote('handoff-out-error', e && e.message ? e.message : String(e));
                    }
                }

                function mergeIncomingStateHandoff(expectedTargetKey) {
                    try {
                        const raw = sessionStorage.getItem('gb_state_handoff');
                        const expected = sessionStorage.getItem('gb_handoff_expect');
                        if (!raw || !window.PlayerStateManager) {
                            if (expected && expected === expectedTargetKey) {
                                liminalCause('C09_RESTORE_WITHOUT_STATE', 'handoff missing');
                                sessionStorage.removeItem('gb_handoff_expect');
                            }
                            return;
                        }

                        const payload = JSON.parse(raw);
                        if (!payload || payload.to !== expectedTargetKey || !payload.states || typeof payload.states !== 'object') {
                            return;
                        }

                        let merged = 0;
                        for (const [key, incoming] of Object.entries(payload.states)) {
                            if (!incoming || typeof incoming !== 'object') continue;
                            const current = window.PlayerStateManager.getState(key);
                            const incomingStamp = Number(incoming.lastUpdate || 0);
                            const currentStamp = Number((current && current.lastUpdate) || 0);
                            if (current && currentStamp > incomingStamp) continue;

                            if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                                window.PlayerStateManager.saveStateAt(key, {
                                    sentenceIndex: Number.isFinite(incoming.sentenceIndex) ? incoming.sentenceIndex : 0,
                                    sentenceTime: Number.isFinite(incoming.sentenceTime) ? incoming.sentenceTime : 0,
                                    wasPlaying: !!incoming.wasPlaying
                                });
                                merged++;
                            }
                        }

                        sessionStorage.removeItem('gb_state_handoff');
                        sessionStorage.removeItem('gb_handoff_expect');
                        liminalDebugNote('handoff-in', `from=${payload.from || '-'} merged=${merged}`);
                        if (merged === 0) {
                            liminalCause('C09_RESTORE_WITHOUT_STATE', 'handoff merged=0');
                        }
                    } catch (e) {
                        liminalDebugNote('handoff-in-error', e && e.message ? e.message : String(e));
                    }
                }

                mergeIncomingStateHandoff(MAIN_CONTENT_KEY);

                function getActiveContentKey() {
                    if (isLoreMode && activeLoreId) return `lore${activeLoreId}`;
                    return MAIN_CONTENT_KEY;
                }

                function resolveBookmarkPageKey(page) {
                    return BOOKMARK_PAGE_KEY_MAP[page] || 'kapitel1';
                }

                function extractLoreIdFromBookmark(bm, fallbackKey = '') {
                    const directLoreId = Number(bm && bm.loreId);
                    if (Number.isFinite(directLoreId) && directLoreId > 0) return Math.trunc(directLoreId);

                    const keyCandidate = (typeof fallbackKey === 'string' && fallbackKey)
                        ? fallbackKey
                        : (typeof (bm && bm.contentKey) === 'string' ? bm.contentKey : '');
                    const keyMatch = keyCandidate.match(/^lore(\d+)$/i);
                    if (keyMatch) return Number(keyMatch[1]);

                    const chapterMatch = (typeof (bm && bm.chapter) === 'string' ? bm.chapter : '').match(/^lore(\d+)$/i);
                    if (chapterMatch) return Number(chapterMatch[1]);

                    const refs = [
                        (typeof (bm && bm.audioRef) === 'string') ? bm.audioRef : '',
                        (typeof (bm && bm.textRef) === 'string') ? bm.textRef : ''
                    ];
                    for (const ref of refs) {
                        const m = ref.match(/lore(\d+)\.(?:mp3|txt)/i);
                        if (m) return Number(m[1]);
                    }
                    return null;
                }

                function resolveBookmarkContentKey(bm) {
                    if (bm && typeof bm.contentKey === 'string' && bm.contentKey.trim()) {
                        return bm.contentKey.trim();
                    }

                    const loreId = extractLoreIdFromBookmark(bm);
                    if (Number.isFinite(loreId) && loreId > 0) return `lore${loreId}`;

                    if (bm && typeof bm.page === 'string' && BOOKMARK_PAGE_KEY_MAP[bm.page]) {
                        return BOOKMARK_PAGE_KEY_MAP[bm.page];
                    }
                    return '';
                }

                async function ensureBookmarkContentForCurrentPage(bm, reason = 'bookmark') {
                    await waitForContentSwitchIdle(`${reason}:pre`);

                    const targetKey = resolveBookmarkContentKey(bm);
                    if (!targetKey) return true; // Legacy bookmark without content metadata

                    const currentKey = getActiveContentKey();
                    if (targetKey === currentKey) return true;

                    if (/^lore\d+$/i.test(targetKey)) {
                        const loreId = extractLoreIdFromBookmark(bm, targetKey);
                        if (!Number.isFinite(loreId) || loreId <= 0) {
                            console.warn('[Bookmark] Invalid lore target:', bm);
                            return false;
                        }
                        if (typeof window.startLoreMode === 'function') {
                            await window.startLoreMode(loreId);
                        } else {
                            return false;
                        }
                        await waitForContentSwitchIdle(`${reason}:switch-lore`);
                        return getActiveContentKey() === `lore${loreId}`;
                    }

                    if (targetKey === MAIN_CONTENT_KEY) {
                        if (isLoreMode) {
                            if (typeof window.restoreMainAudio === 'function') {
                                await window.restoreMainAudio({ saveCurrent: true });
                            } else {
                                return false;
                            }
                            await waitForContentSwitchIdle(`${reason}:switch-main`);
                        }
                        return getActiveContentKey() === MAIN_CONTENT_KEY;
                    }

                    return false;
                }

                function getActiveSubtitleTracks() {
                    return window.audioPlayer && Array.isArray(window.audioPlayer.subtitleTracks)
                        ? window.audioPlayer.subtitleTracks
                        : [];
                }

                function getActiveSubtitleIndex() {
                    return window.audioPlayer && Number.isFinite(window.audioPlayer.currentSubtitleIndex)
                        ? window.audioPlayer.currentSubtitleIndex
                        : -1;
                }

                function clearContentState(key) {
                    if (!key) return;
                    if (window.PlayerStateManager) {
                        window.PlayerStateManager.clear(key);
                    }
                    if (key === MAIN_CONTENT_KEY) {
                        mainAudioState.time = 0;
                        mainAudioState.wasPlaying = false;
                    }
                }

                function isCurrentContentCompleted() {
                    const p = window.audioPlayer;
                    if (!p || !p.audio) return false;
                    const tracks = getActiveSubtitleTracks();
                    if (tracks.length === 0) return false;

                    const t = p.audio.currentTime || 0;
                    const duration = p.audio.duration || 0;
                    const subtitleIndex = getActiveSubtitleIndex();
                    const reachedTextEnd = subtitleIndex >= tracks.length - 1;
                    const reachedAudioEnd = duration > 0 && t >= Math.max(0, duration - 0.25);
                    return reachedTextEnd && reachedAudioEnd;
                }

                async function saveCurrentContentState(options = {}) {
                    const {
                        keyOverride = null,
                        clear = false,
                        preferCachedTime = false,
                        reason = 'unspecified'
                    } = options;

                    const p = window.audioPlayer;
                    if (!p || !p.audio) return;

                    const key = keyOverride || getActiveContentKey();
                    if (!key) return;

                    if (clear) {
                        clearContentState(key);
                        liminalDebug.lastSave = { key, cleared: true, reason, at: Date.now() };
                        liminalDebugNote('state-clear', `${key} (${reason})`);
                        return;
                    }

                    try {
                        let currentTime = p.audio.currentTime || 0;
                        if (!preferCachedTime && typeof p.audio.getAccurateCurrentTime === 'function') {
                            currentTime = await p.audio.getAccurateCurrentTime(800);
                        }

                        const wasPlaying = (typeof p.audio.isProbablyPlaying === 'function')
                            ? p.audio.isProbablyPlaying()
                            : !p.audio.paused;

                        if (window.PlayerStateManager) {
                            const tracks = getActiveSubtitleTracks();
                            if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                                const sentence = window.PlayerStateManager.findSentenceStart(currentTime, tracks);
                                window.PlayerStateManager.saveStateAt(key, {
                                    sentenceIndex: sentence.index,
                                    sentenceTime: sentence.time,
                                    wasPlaying
                                });
                                liminalDebug.lastSave = {
                                    key,
                                    reason,
                                    currentTime: Number((currentTime || 0).toFixed(3)),
                                    sentenceIndex: sentence.index,
                                    sentenceTime: Number((sentence.time || 0).toFixed(3)),
                                    wasPlaying,
                                    at: Date.now()
                                };
                                liminalDebugNote('state-save', `${key} -> ${sentence.time.toFixed(2)}s idx=${sentence.index} play=${wasPlaying} (${reason})`);
                            } else {
                                window.PlayerStateManager.saveState(key, tracks, p.audio);
                                liminalDebug.lastSave = {
                                    key,
                                    reason,
                                    currentTime: Number((currentTime || 0).toFixed(3)),
                                    sentenceIndex: null,
                                    sentenceTime: Number((currentTime || 0).toFixed(3)),
                                    wasPlaying,
                                    at: Date.now()
                                };
                                liminalDebugNote('state-save', `${key} (legacy) ${currentTime.toFixed(2)}s (${reason})`);
                            }
                        }

                        if (key === MAIN_CONTENT_KEY) {
                            mainAudioState.wasPlaying = wasPlaying;
                            mainAudioState.time = currentTime || 0;
                        }
                    } catch (e) {
                        console.warn('[State] saveCurrentContentState failed', e);
                        liminalDebugNote('state-error', `${reason}: ${e && e.message ? e.message : e}`);
                    }
                }

                async function pauseWithFade(duration = 350) {
                    const p = window.audioPlayer;
                    if (!p || p.paused) return;

                    await new Promise(resolve => {
                        const stepMs = 35;
                        const startVolume = p.volume;
                        const steps = Math.max(1, Math.floor(duration / stepMs));
                        let i = 0;
                        const timer = setInterval(() => {
                            i += 1;
                            p.volume = Math.max(0, startVolume * (1 - (i / steps)));
                            if (i >= steps) {
                                clearInterval(timer);
                                p.pause();
                                resolve();
                            }
                        }, stepMs);
                    });
                }

                function wait(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                async function waitForContentSwitchIdle(reason, timeoutMs = 2200) {
                    const endAt = Date.now() + Math.max(300, timeoutMs || 0);
                    let waited = 0;
                    while (contentSwitchInProgress && Date.now() < endAt) {
                        await wait(60);
                        waited += 60;
                    }
                    if (contentSwitchInProgress) {
                        liminalDebugNote('switch-wait-timeout', `${reason || 'unknown'} waited=${waited}ms`);
                    } else if (waited > 0) {
                        liminalDebugNote('switch-wait', `${reason || 'unknown'} waited=${waited}ms`);
                    }
                }

                async function seekAndSyncSubtitle(p, targetTime, reason) {
                    const safeTarget = Math.max(0, Number(targetTime) || 0);
                    liminalTrace('seek:start', {
                        reason,
                        target: Number(safeTarget.toFixed(3)),
                        before: Number(((p && p.audio && p.audio.currentTime) || 0).toFixed(3))
                    });
                    let seekResult = {
                        ok: false,
                        target: safeTarget,
                        position: p.audio.currentTime || 0,
                        attempts: 0
                    };

                    try {
                        if (typeof p.audio.seekAndConfirm === 'function') {
                            seekResult = await p.audio.seekAndConfirm(safeTarget, {
                                maxAttempts: 5,
                                settleMs: 220,
                                tolerance: 0.9
                            });
                        } else {
                            p.audio.currentTime = safeTarget;
                            await wait(260);
                            const pos = (typeof p.audio.getAccurateCurrentTime === 'function')
                                ? await p.audio.getAccurateCurrentTime(900)
                                : (p.audio.currentTime || 0);
                            seekResult = {
                                ok: Math.abs(pos - safeTarget) <= 1.0 || pos >= safeTarget - 1.0,
                                target: safeTarget,
                                position: pos,
                                attempts: 1
                            };
                        }
                    } catch (e) {
                        liminalDebugNote('seek-error', `${reason}: ${e && e.message ? e.message : e}`);
                    }

                    const effectiveTime = Number.isFinite(seekResult.position) ? seekResult.position : safeTarget;
                    p.currentSubtitleIndex = findSubtitleIndexForTime(effectiveTime);
                    p.renderLines(p.currentSubtitleIndex);
                    liminalDebugNote('seek', `${reason} target=${safeTarget.toFixed(2)} pos=${effectiveTime.toFixed(2)} ok=${seekResult.ok} tries=${seekResult.attempts}`);
                    if (!seekResult.ok) {
                        liminalCause('C10_SEEK_CONFIRM_FAILED', `${reason} target=${safeTarget.toFixed(2)} pos=${effectiveTime.toFixed(2)}`);
                    }
                    liminalTrace('seek:end', {
                        reason,
                        ok: !!seekResult.ok,
                        attempts: seekResult.attempts || 0,
                        target: Number(safeTarget.toFixed(3)),
                        position: Number((effectiveTime || 0).toFixed(3)),
                        subtitleIndex: p.currentSubtitleIndex
                    });
                    return seekResult;
                }

                async function verifyPlaybackStarted(retries = 2, delayMs = 320) {
                    const p = window.audioPlayer;
                    if (!p) return false;
                    const isTransportPaused = () => {
                        if (!p || !p.audio) return true;
                        if (typeof p.audio.isTransportPaused === 'function') {
                            return p.audio.isTransportPaused();
                        }
                        return !!p.paused;
                    };
                    let sawRecentProgress = (p.audio && typeof p.audio.hasRecentProgress === 'function')
                        ? p.audio.hasRecentProgress(1800)
                        : false;
                    liminalTrace('verify-play:start', {
                        retries,
                        delayMs,
                        paused: !!p.paused,
                        transportPaused: isTransportPaused(),
                        sawRecentProgress
                    });

                    for (let attempt = 0; attempt <= retries; attempt++) {
                        try {
                            await p.play();
                        } catch (e) {
                            console.warn(`[Audio] play() failed on attempt ${attempt + 1}:`, e);
                            liminalTrace('verify-play:play-error', { attempt: attempt + 1, message: e && e.message ? e.message : String(e) });
                        }
                        await wait(delayMs);
                        const currentPos = (typeof p.audio.getAccurateCurrentTime === 'function')
                            ? await p.audio.getAccurateCurrentTime(700)
                            : (p.audio.currentTime || 0);
                        const transportPaused = isTransportPaused();
                        const hasRecentProgress = (p.audio && typeof p.audio.hasRecentProgress === 'function')
                            ? p.audio.hasRecentProgress(1800)
                            : false;
                        sawRecentProgress = sawRecentProgress || hasRecentProgress;
                        const started = !transportPaused && hasRecentProgress;
                        liminalDebugNote('play-check', `attempt=${attempt + 1} paused=${p.paused} t=${currentPos.toFixed(2)}`);
                        liminalTrace('verify-play:attempt', {
                            attempt: attempt + 1,
                            paused: !!p.paused,
                            transportPaused,
                            hasRecentProgress,
                            currentPos: Number((currentPos || 0).toFixed(3)),
                            started
                        });
                        if (started) {
                            liminalTrace('verify-play:success', { attempt: attempt + 1, currentPos: Number((currentPos || 0).toFixed(3)) });
                            return true;
                        }
                    }
                    if (!isTransportPaused() && sawRecentProgress) {
                        liminalTrace('verify-play:success-fallback', { sawRecentProgress: true });
                        return true;
                    }
                    liminalTrace('verify-play:failed', { retries, delayMs });
                    return false;
                }

                async function skipBySecondsInLiminal(deltaSec) {
                    const p = window.audioPlayer;
                    if (!p || !p.audio) return;
                    if (contentSwitchInProgress) return;

                    const delta = Number(deltaSec) || 0;
                    if (!delta) return;

                    await waitForContentSwitchIdle(`skip:${delta}`);
                    const wasPausedBeforeSkip = !!p.paused;
                    let before = Number(p.audio.currentTime);
                    if (!Number.isFinite(before) || before < 0) before = 0;
                    if (!wasPausedBeforeSkip && typeof p.audio.getAccurateCurrentTime === 'function') {
                        const measuredBefore = await p.audio.getAccurateCurrentTime(900);
                        if (Number.isFinite(measuredBefore) && measuredBefore >= 0) {
                            before = measuredBefore;
                        }
                    }
                    let target = Math.max(0, before + delta);
                    const duration = Number(p.audio.duration);
                    if (Number.isFinite(duration) && duration > 0) {
                        target = Math.min(duration, target);
                    }

                    let seekResult = {
                        ok: false,
                        target,
                        position: before,
                        attempts: 0
                    };

                    try {
                        // SC seeks are significantly more reliable while the stream is playing.
                        // We preserve original pause state after the seek operation.
                        if (wasPausedBeforeSkip) {
                            try {
                                await p.play();
                                await wait(140);
                            } catch (_) { }
                        }

                        if (typeof p.audio.seekAndConfirm === 'function') {
                            seekResult = await p.audio.seekAndConfirm(target, {
                                maxAttempts: 5,
                                settleMs: 220,
                                tolerance: 1.0
                            });
                        } else {
                            p.audio.currentTime = target;
                            await wait(260);
                            const pos = (typeof p.audio.getAccurateCurrentTime === 'function')
                                ? await p.audio.getAccurateCurrentTime(900)
                                : (p.audio.currentTime || 0);
                            seekResult = {
                                ok: Math.abs(pos - target) <= 1.2 || pos >= target - 1.2,
                                target,
                                position: pos,
                                attempts: 1
                            };
                        }
                    } catch (e) {
                        liminalDebugNote('skip-error', `${delta}: ${e && e.message ? e.message : e}`);
                    }

                    let measuredAfter = Number.isFinite(seekResult.position) ? seekResult.position : NaN;
                    if (typeof p.audio.getAccurateCurrentTime === 'function') {
                        const verifyPos = await p.audio.getAccurateCurrentTime(1000);
                        if (Number.isFinite(verifyPos) && verifyPos >= 0) {
                            measuredAfter = verifyPos;
                        }
                    }

                    // Guard against bad SC seek responses that jump back to the beginning.
                    if (delta > 0 && Number.isFinite(measuredAfter) && measuredAfter < (before - 0.8)) {
                        try {
                            p.audio.currentTime = target;
                            await wait(240);
                            if (typeof p.audio.getAccurateCurrentTime === 'function') {
                                const retryPos = await p.audio.getAccurateCurrentTime(900);
                                if (Number.isFinite(retryPos) && retryPos >= 0) {
                                    measuredAfter = retryPos;
                                }
                            } else {
                                measuredAfter = Number(p.audio.currentTime) || target;
                            }
                        } catch (_) {
                            measuredAfter = target;
                        }
                    }

                    const effectiveTime = Number.isFinite(measuredAfter) ? measuredAfter : target;
                    p.currentSubtitleIndex = findSubtitleIndexForTime(effectiveTime);
                    p.renderLines(p.currentSubtitleIndex);
                    liminalDebugNote(
                        'skip',
                        `delta=${delta} before=${before.toFixed(2)} target=${target.toFixed(2)} pos=${effectiveTime.toFixed(2)} ok=${seekResult.ok} tries=${seekResult.attempts}`
                    );
                    if (!seekResult.ok) {
                        liminalCause('C10_SEEK_CONFIRM_FAILED', `skip delta=${delta} target=${target.toFixed(2)} pos=${effectiveTime.toFixed(2)}`);
                    }

                    if (wasPausedBeforeSkip) {
                        p.pause();
                        if (typeof updateIcons === 'function') updateIcons();
                    }
                }

                function findSubtitleIndexForTime(timeSec) {
                    const tracks = getActiveSubtitleTracks();
                    if (tracks.length === 0) return 0;
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        if (timeSec >= tracks[i].time) return i;
                    }
                    return 0;
                }

                const TOP_FADE_BYPASS_COUNT = 2;
                function syncReadingTopFadeMask(activeIndex) {
                    if (!subtitleContainer) return;
                    const shouldDisableTopFade =
                        isReadingMode &&
                        Number.isFinite(activeIndex) &&
                        activeIndex >= 0 &&
                        activeIndex < TOP_FADE_BYPASS_COUNT;
                    subtitleContainer.classList.toggle('no-top-fade', shouldDisableTopFade);
                }

                // Helper: Restore Main Audio
                window.restoreMainAudio = async function (options = {}) {
                    const {
                        saveCurrent = true
                    } = options;
                    liminalTrace('switch:restore-main:enter', { saveCurrent: !!saveCurrent });

                    if (!isLoreMode && !contentSwitchInProgress) return;
                    if (contentSwitchInProgress) {
                        liminalTrace('switch:restore-main:blocked', { reason: 'contentSwitchInProgress' });
                        return;
                    }

                    const p = window.audioPlayer;
                    if (!p || !p.audio) return;

                    contentSwitchInProgress = true;
                    const switchToken = ++contentSwitchToken;
                    liminalTrace('switch:restore-main:lock', { switchToken });

                    try {
                        const loreIdBeforeSwitch = activeLoreId;
                        if (saveCurrent && loreIdBeforeSwitch) {
                            await saveCurrentContentState({ keyOverride: `lore${loreIdBeforeSwitch}`, reason: 'restore-main:save-lore' });
                        } else if (!saveCurrent && loreIdBeforeSwitch) {
                            clearContentState(`lore${loreIdBeforeSwitch}`);
                        }

                        isLoreMode = false;
                        activeLoreId = null;

                        await pauseWithFade(320);
                        if (switchToken !== contentSwitchToken) return;

                        p.audio.src = getSCUrl('assets/kapitel1b.mp3');
                        liminalTrace('switch:restore-main:src-set', { switchToken, src: p.audio.src });
                        p.volume = readerTextVolume;
                        const textLoaded = await p.loadText('assets/kapitel1b.txt');
                        if (!textLoaded || switchToken !== contentSwitchToken) return;
                        markBlaetternPaginationDirty();
                        liminalTrace('switch:restore-main:text-parsed', {
                            switchToken,
                            tracks: Array.isArray(p.subtitleTracks) ? p.subtitleTracks.length : -1
                        });

                        const savedMain = window.PlayerStateManager ? window.PlayerStateManager.getState(MAIN_CONTENT_KEY) : null;
                        const resumeTime = savedMain && savedMain.sentenceTime !== undefined
                            ? savedMain.sentenceTime
                            : Math.max(0, mainAudioState.time || 0);
                        liminalTrace('switch:restore-main:resume-time', {
                            switchToken,
                            resumeTime: Number((resumeTime || 0).toFixed(3)),
                            hasSavedMain: !!savedMain
                        });
                        liminalDebugNote('restore-main', `resume=${resumeTime.toFixed(2)}s saved=${!!savedMain}`);
                        if (!savedMain && (mainAudioState.time || 0) <= 0.01) {
                            liminalCause('C09_RESTORE_WITHOUT_STATE', 'main restore fallback at 0');
                        }

                        await seekAndSyncSubtitle(p, resumeTime, 'restore-main:pre-play');

                        const shouldResume = savedMain ? !!savedMain.wasPlaying : !!mainAudioState.wasPlaying;
                        liminalTrace('switch:restore-main:resume-decision', { switchToken, shouldResume: !!shouldResume });
                        if (shouldResume) {
                            p.volume = 0;
                            const started = await verifyPlaybackStarted(2, 320);
                            liminalTrace('switch:restore-main:verify-result', { switchToken, started: !!started });
                            if (started) {
                                p.currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                                p.renderLines(p.currentSubtitleIndex);
                                p.volume = readerTextVolume;
                            } else {
                                p.volume = readerTextVolume;
                            }
                        }

                        updateIcons();
                    } catch (e) {
                        console.warn('Restore failed', e);
                        liminalTrace('switch:restore-main:error', { message: e && e.message ? e.message : String(e) });
                        liminalDebugNote('restore-main-error', e && e.message ? e.message : String(e));
                        updateIcons();
                    } finally {
                        if (switchToken === contentSwitchToken) {
                            contentSwitchInProgress = false;
                            liminalTrace('switch:restore-main:unlock', { switchToken });
                        }
                    }
                };

                // Real startLoreMode implementation
                window.startLoreMode = async function (id) {
                    liminalTrace('switch:start-lore:enter', { id });
                    if (isLoreMode && activeLoreId === id) return;
                    if (contentSwitchInProgress) {
                        liminalTrace('switch:start-lore:blocked', { id, reason: 'contentSwitchInProgress' });
                        return;
                    }

                    const content = window.GameState?.getLore(id) || {
                        audio: `assets/lore${id}.mp3`,
                        text: `assets/lore${id}.txt`
                    };

                    const p = window.audioPlayer;
                    if (!p || !p.audio) return;

                    contentSwitchInProgress = true;
                    const switchToken = ++contentSwitchToken;
                    liminalTrace('switch:start-lore:lock', { id, switchToken });

                    try {
                        await saveCurrentContentState({ reason: `start-lore:${id}` });

                        isLoreMode = true;
                        activeLoreId = id;

                        await pauseWithFade(320);
                        if (switchToken !== contentSwitchToken) return;

                        p.audio.src = getSCUrl(content.audio);
                        liminalTrace('switch:start-lore:src-set', { id, switchToken, src: p.audio.src });
                        const textPath = content.text || `assets/lore${id}.txt`;
                        const textLoaded = await p.loadText(textPath);
                        if (!textLoaded || switchToken !== contentSwitchToken) return;
                        markBlaetternPaginationDirty();
                        liminalTrace('switch:start-lore:text-parsed', {
                            id,
                            switchToken,
                            tracks: Array.isArray(p.subtitleTracks) ? p.subtitleTracks.length : -1
                        });

                        const savedLore = window.PlayerStateManager ? window.PlayerStateManager.getState(`lore${id}`) : null;
                        const resumeTime = savedLore && savedLore.sentenceTime !== undefined
                            ? savedLore.sentenceTime
                            : 0;
                        liminalTrace('switch:start-lore:resume-time', {
                            id,
                            switchToken,
                            resumeTime: Number((resumeTime || 0).toFixed(3)),
                            hasSavedLore: !!savedLore
                        });
                        liminalDebugNote('start-lore', `id=${id} resume=${resumeTime.toFixed(2)}s saved=${!!savedLore}`);
                        if (!savedLore && resumeTime <= 0.01) {
                            liminalCause('C09_RESTORE_WITHOUT_STATE', `lore${id} restore fallback at 0`);
                        }

                        await seekAndSyncSubtitle(p, resumeTime, `start-lore:${id}:pre-play`);

                        p.volume = 0;
                        const started = await verifyPlaybackStarted(3, 320);
                        liminalTrace('switch:start-lore:verify-result', { id, switchToken, started: !!started });
                        if (started) {
                            p.currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                            p.renderLines(p.currentSubtitleIndex);
                            p.volume = readerTextVolume;
                        } else {
                            p.volume = readerTextVolume;
                            console.warn(`Lore ${id} loaded but still paused.`);
                        }

                        updateIcons();
                    } catch (e) {
                        console.warn('Lore switch failed', e);
                        liminalTrace('switch:start-lore:error', { id, message: e && e.message ? e.message : String(e) });
                        updateIcons();
                    } finally {
                        if (switchToken === contentSwitchToken) {
                            contentSwitchInProgress = false;
                            liminalTrace('switch:start-lore:unlock', { id, switchToken });
                        }
                    }
                };

                // --- CONFIG ---
                const config = {
                    roomWidth: 8,
                    roomHeight: 9,
                    segmentLength: 10,
                    shelfDepth: 1.2,
                    hallWidth: 6
                };

                // ============================================
                // SCENE SETUP (THREE.JS)
                // ============================================

                let scene, camera, euler, backgroundModeColor, lookTargetSphere, renderer;

                if (!window.fallback2DMode && THREE) {
                    scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2(0x050505, 0.06); // Denser fog, matches background
                    scene.background = new THREE.Color(0x050505); // Black-ish background

                    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
                    camera.position.set(0, 1.6, 3.0);
                    euler = new THREE.Euler(0, 0, 0, 'YXZ');

                    backgroundModeColor = 0x010101;
                    lookTargetSphere = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.0 }) // Set opacity > 0 to debug
                    );
                    scene.add(lookTargetSphere);
                }

                // Helper to render Archive Content (Fixes ReferenceError)
                window.renderArchiveContent = function () {
                    // Reload logic if needed, or just log
                    console.log("Archive content updated");
                    if (!window.fallback2DMode && typeof renderArchive === 'function') renderArchive();
                };

                // FIX: Define controls object to prevent ReferenceError
                // Replicates PointerLockControls movement logic (planar forward)
                const controls = {
                    moveRight: function (distance) {
                        if (!camera) return;
                        const vec = new THREE.Vector3();
                        vec.setFromMatrixColumn(camera.matrix, 0);
                        camera.position.addScaledVector(vec, distance);
                    },
                    moveForward: function (distance) {
                        if (!camera) return;
                        const vec = new THREE.Vector3();
                        vec.setFromMatrixColumn(camera.matrix, 0);
                        vec.crossVectors(camera.up, vec);
                        camera.position.addScaledVector(vec, distance);
                    }
                };

                // SAFELY INITIALIZE WEBGL RENDERER
                if (!window.fallback2DMode) {
                    try {
                        renderer = new THREE.WebGLRenderer({
                            antialias: !isIOSSafari, // iOS: Disable antialiasing to save GPU budget
                            powerPreference: isIOSSafari ? 'default' : 'high-performance',
                            precision: isIOSSafari ? 'mediump' : 'highp'
                        });
                        renderer.setSize(window.innerWidth, window.innerHeight);

                        // iOS: Disable shadow maps to prevent WebGL context loss on older devices
                        renderer.shadowMap.enabled = !isIOSSafari;
                        if (renderer.shadowMap.enabled) {
                            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        }
                        renderer.toneMapping = THREE.ACESFilmicToneMapping;
                        renderer.toneMappingExposure = 1.0;

                        if (isIOSSafari) {
                            // iOS: Cap pixel ratio to avoid exceeding GPU memory
                            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                            // WebGL Context Loss recovery (prevents permanent black screen)
                            renderer.domElement.addEventListener('webglcontextlost', (e) => {
                                e.preventDefault();
                                console.warn('[Liminal] WebGL context lost (iOS)');
                            }, false);
                            renderer.domElement.addEventListener('webglcontextrestored', () => {
                                console.log('[Liminal] WebGL context restored (iOS)');
                            }, false);
                        } else {
                            renderer.setPixelRatio(window.devicePixelRatio);
                        }

                        document.body.appendChild(renderer.domElement);
                    } catch (e) {
                        console.error("WebGL Initialization failed, entering 2D Fallback Mode.", e);
                        window.fallback2DMode = true;
                        document.body.style.backgroundColor = '#050505';
                        // Hide loading items if the 3D init failed so users aren't stuck on a loading screen forever
                        const loadingText = document.getElementById('loading');
                        if (loadingText) loadingText.style.display = 'none';
                        const loadingScreen = document.getElementById('loading-screen');
                        if (loadingScreen) loadingScreen.style.display = 'none';
                        const uiContainer = document.getElementById('audioPlayerUI');
                        if (uiContainer) uiContainer.style.display = 'flex';
                    }
                } // end if (!window.fallback2DMode)

                function syncViewport() {
                    const vv = window.visualViewport;
                    const viewWidth = Math.max(1, Math.round(vv ? vv.width : window.innerWidth));
                    const viewHeight = Math.max(1, Math.round(vv ? vv.height : window.innerHeight));
                    if (camera) {
                        camera.aspect = viewWidth / viewHeight;
                        camera.updateProjectionMatrix();
                    }
                    if (!window.fallback2DMode && renderer) {
                        renderer.setSize(viewWidth, viewHeight, false);
                    }
                }

                // Ensure initial calibration uses the real visual viewport on mobile.
                syncViewport();

                // Start animation with correct background color
                if (scene) scene.background = new THREE.Color(isReadingMode ? backgroundModeColor : 0x050505);
                const uiContainer = document.getElementById('audioPlayerUI');
                const iconPlay = document.getElementById('iconPlay');
                const iconPause = document.getElementById('iconPause');
                const modeToggleBtn = document.getElementById('readingModeBtn');
                const subtitleContainer = document.getElementById('subtitleContainer');
                const audioControlsEl = document.getElementById('audioControls');
                const subtitleRecenterBtn = document.getElementById('subtitleRecenterBtn');
                const RECENTER_MOBILE_RADIUS_PX = 75;
                const skipBackBtn = document.getElementById('skipBackBtn');
                const fullscreenBtn = document.getElementById('fullscreenBtn');

                function normalizeReaderSentenceLayout(value) {
                    if (value === 'kindle') return READER_LAYOUT_BLAETTERN;
                    if (value === 'timestamp') return READER_LAYOUT_TIMESTAMPS;
                    if (value === READER_LAYOUT_TIMESTAMPS) return READER_LAYOUT_TIMESTAMPS;
                    if (value === READER_LAYOUT_BLAETTERN) return READER_LAYOUT_BLAETTERN;
                    if (value === READER_LAYOUT_FLAT) return READER_LAYOUT_FLAT;
                    return READER_LAYOUT_BLAETTERN;
                }

                function normalizeReaderFontSize(value) {
                    const parsed = Number(value);
                    if (!Number.isFinite(parsed)) return READER_FONT_SIZE_DEFAULT;
                    const rounded = Math.round(parsed);
                    return Math.max(READER_FONT_SIZE_MIN, Math.min(READER_FONT_SIZE_MAX, rounded));
                }

                function normalizeReaderFontFamilyKey(value) {
                    if (typeof value !== 'string') return READER_FONT_FAMILY_DEFAULT;
                    const cleaned = value.trim().toLowerCase();
                    if (cleaned === 'georgia') return 'times';
                    return Object.prototype.hasOwnProperty.call(READER_FONT_FAMILIES, cleaned)
                        ? cleaned
                        : READER_FONT_FAMILY_DEFAULT;
                }

                function getReaderFontFamilyStack(value) {
                    const normalized = normalizeReaderFontFamilyKey(value);
                    return READER_FONT_FAMILIES[normalized] || READER_FONT_FAMILIES[READER_FONT_FAMILY_DEFAULT];
                }

                function normalizeReaderVolume(value) {
                    if (value === null || value === undefined) return READER_VOLUME_DEFAULT;
                    if (typeof value === 'string' && !value.trim()) return READER_VOLUME_DEFAULT;
                    const parsed = Number(value);
                    if (!Number.isFinite(parsed)) return READER_VOLUME_DEFAULT;
                    const normalized = parsed > 1 ? (parsed / 100) : parsed;
                    return Math.max(0, Math.min(1, normalized));
                }

                function normalizeReaderHexColor(value, fallback = null) {
                    if (typeof value !== 'string') return fallback;
                    const cleaned = value.trim().toLowerCase();
                    if (!cleaned) return fallback;
                    const match = cleaned.match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
                    if (!match) return fallback;
                    let hex = match[1];
                    if (hex.length === 3) hex = hex.split('').map((ch) => `${ch}${ch}`).join('');
                    return `#${hex.toLowerCase()}`;
                }

                function getReaderFallbackBgColor() {
                    return document.body.classList.contains('scene-dimmer-light-mode') ? '#ede6d6' : '#11161d';
                }

                function getReaderFallbackTextColor() {
                    return document.body.classList.contains('scene-dimmer-light-mode') ? '#1f1d18' : '#f2ecdc';
                }

                function mixHexColors(baseHex, tintHex, alpha = 0.5) {
                    const base = hexToRgb(baseHex);
                    const tint = hexToRgb(tintHex);
                    if (!base || !tint) return baseHex;
                    const a = Math.max(0, Math.min(1, Number(alpha) || 0));
                    return rgbToHex(
                        (base.r * (1 - a)) + (tint.r * a),
                        (base.g * (1 - a)) + (tint.g * a),
                        (base.b * (1 - a)) + (tint.b * a)
                    );
                }

                function applyReaderDimmerTint() {
                    const overlay = document.getElementById('sceneDimmerOverlay');
                    if (!overlay) return;

                    const base = document.body.classList.contains('scene-dimmer-light-mode') ? '#ffffff' : '#000000';
                    const isFreezeMode = manualBackgroundDimLevel >= 100;
                    if (!isFreezeMode || !readerBgColor) {
                        overlay.style.backgroundColor = base;
                        return;
                    }

                    const mixed = mixHexColors(base, readerBgColor, 0.5);
                    overlay.style.backgroundColor = mixed;
                }

                function applyReaderColorSettings() {
                    const hasCustomText = typeof readerTextColor === 'string' && !!readerTextColor;
                    subtitleContainer.classList.toggle('reader-custom-text', hasCustomText);

                    if (hasCustomText) subtitleContainer.style.setProperty('--reader-custom-text', readerTextColor);
                    else subtitleContainer.style.removeProperty('--reader-custom-text');
                    applyReaderDimmerTint();
                }

                function applyReaderTextSettings(options = {}) {
                    if (!subtitleContainer) return;
                    const rerender = options.rerender !== false;
                    const isFlatLayout = readerSentenceLayout === READER_LAYOUT_FLAT;
                    const isBlaetternLayout = readerSentenceLayout === READER_LAYOUT_BLAETTERN;

                    subtitleContainer.classList.toggle('reader-layout-flat', isFlatLayout);
                    subtitleContainer.classList.toggle('reader-layout-blaettern', isBlaetternLayout);
                    subtitleContainer.classList.toggle('reader-layout-timestamps', !isFlatLayout && !isBlaetternLayout);
                    subtitleContainer.style.setProperty('--reader-font-size', `${readerFontSizePx}px`);
                    subtitleContainer.style.setProperty('--reader-font-family', getReaderFontFamilyStack(readerFontFamilyKey));
                    applyReaderColorSettings();
                    markBlaetternPaginationDirty();
                    syncBlaetternUiState('reader-settings');

                    // Open bookmark buttons may overlap after layout/font changes.
                    subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((btn) => {
                        btn.classList.remove('visible');
                    });
                    hideBlaetternBookmarkButton();

                    if (rerender && window.audioPlayer && typeof window.audioPlayer.renderLines === 'function') {
                        subtitleContainer.dataset.version = '';
                        const idx = Number.isFinite(window.audioPlayer.currentSubtitleIndex)
                            ? window.audioPlayer.currentSubtitleIndex
                            : 0;
                        window.audioPlayer.renderLines(Math.max(0, idx));
                    }
                }

                function syncReaderSettingsUi() {
                    const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
                    layoutInputs.forEach((input) => {
                        input.checked = input.value === readerSentenceLayout;
                    });

                    const rangeInput = document.getElementById('readerFontSizeRange');
                    const numberInput = document.getElementById('readerFontSizeNumber');
                    const valueAsText = String(readerFontSizePx);
                    if (rangeInput) rangeInput.value = valueAsText;
                    if (numberInput) numberInput.value = valueAsText;
                    const fontOptionButtons = document.querySelectorAll('.reader-font-option');
                    fontOptionButtons.forEach((button) => {
                        const isActive = button.dataset.font === readerFontFamilyKey;
                        button.classList.toggle('is-active', isActive);
                        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                    });

                    const textVolumeRange = document.getElementById('readerTextVolumeRange');
                    const textVolumeNumber = document.getElementById('readerTextVolumeNumber');
                    const bgVolumeRange = document.getElementById('readerBackgroundVolumeRange');
                    const bgVolumeNumber = document.getElementById('readerBackgroundVolumeNumber');
                    const textVolumeValue = String(Math.round(readerTextVolume * 100));
                    const bgVolumeValue = String(Math.round(readerBackgroundVolume * 100));
                    if (textVolumeRange) textVolumeRange.value = textVolumeValue;
                    if (textVolumeNumber) textVolumeNumber.value = textVolumeValue;
                    if (bgVolumeRange) bgVolumeRange.value = bgVolumeValue;
                    if (bgVolumeNumber) bgVolumeNumber.value = bgVolumeValue;

                    const effectiveBg = readerBgColor || getReaderFallbackBgColor();
                    const effectiveText = readerTextColor || getReaderFallbackTextColor();
                    const bgPreview = document.getElementById('readerBgColorPreview');
                    const textPreview = document.getElementById('readerTextColorPreview');
                    if (bgPreview) bgPreview.style.background = effectiveBg;
                    if (textPreview) textPreview.style.background = effectiveText;
                    if (typeof readerColorWheelSync.bg === 'function') readerColorWheelSync.bg(effectiveBg);
                    if (typeof readerColorWheelSync.text === 'function') readerColorWheelSync.text(effectiveText);

                    updateAllSliderFills();
                }

                function setReaderSentenceLayout(nextLayout, options = {}) {
                    const normalized = normalizeReaderSentenceLayout(nextLayout);
                    if (!options.force && normalized === readerSentenceLayout) return;
                    readerSentenceLayout = normalized;
                    localStorage.setItem(READER_LAYOUT_STORAGE_KEY, readerSentenceLayout);
                    applyReaderTextSettings({ rerender: true });
                    syncReaderSettingsUi();
                }

                function setReaderFontSize(nextSize, options = {}) {
                    const normalized = normalizeReaderFontSize(nextSize);
                    if (!options.force && normalized === readerFontSizePx) return;
                    readerFontSizePx = normalized;
                    localStorage.setItem(READER_FONT_SIZE_STORAGE_KEY, String(readerFontSizePx));
                    applyReaderTextSettings({
                        rerender: readerSentenceLayout === READER_LAYOUT_FLAT || readerSentenceLayout === READER_LAYOUT_BLAETTERN
                    });
                    syncReaderSettingsUi();
                }

                function setReaderFontFamily(nextFont, options = {}) {
                    const normalized = normalizeReaderFontFamilyKey(nextFont);
                    if (!options.force && normalized === readerFontFamilyKey) return;
                    readerFontFamilyKey = normalized;
                    localStorage.setItem(READER_FONT_FAMILY_STORAGE_KEY, readerFontFamilyKey);
                    applyReaderTextSettings({
                        rerender: readerSentenceLayout === READER_LAYOUT_FLAT || readerSentenceLayout === READER_LAYOUT_BLAETTERN
                    });
                    syncReaderSettingsUi();
                }

                function setReaderTextVolume(nextVolume, options = {}) {
                    const normalized = normalizeReaderVolume(nextVolume);
                    if (!options.force && normalized === readerTextVolume) return;
                    readerTextVolume = normalized;
                    localStorage.setItem(READER_TEXT_VOLUME_STORAGE_KEY, String(readerTextVolume));
                    if (window.audioPlayer && typeof window.audioPlayer.volume === 'number') {
                        window.audioPlayer.volume = readerTextVolume;
                    }
                    syncReaderSettingsUi();
                }

                function setReaderBackgroundVolume(nextVolume, options = {}) {
                    const normalized = normalizeReaderVolume(nextVolume);
                    if (!options.force && normalized === readerBackgroundVolume) return;
                    readerBackgroundVolume = normalized;
                    localStorage.setItem(READER_BACKGROUND_VOLUME_STORAGE_KEY, String(readerBackgroundVolume));
                    if (typeof applyBackgroundSfxVolume === 'function') applyBackgroundSfxVolume('reader-background-volume');
                    syncReaderSettingsUi();
                }

                function setReaderBgColor(nextColor, options = {}) {
                    const normalized = normalizeReaderHexColor(nextColor, null);
                    if (!options.force && normalized === readerBgColor) return;
                    readerBgColor = normalized;
                    if (readerBgColor) localStorage.setItem(READER_BG_COLOR_STORAGE_KEY, readerBgColor);
                    else localStorage.removeItem(READER_BG_COLOR_STORAGE_KEY);
                    applyReaderTextSettings({ rerender: false });
                    syncReaderSettingsUi();
                }

                function setReaderTextColor(nextColor, options = {}) {
                    const normalized = normalizeReaderHexColor(nextColor, null);
                    if (!options.force && normalized === readerTextColor) return;
                    readerTextColor = normalized;
                    if (readerTextColor) localStorage.setItem(READER_TEXT_COLOR_STORAGE_KEY, readerTextColor);
                    else localStorage.removeItem(READER_TEXT_COLOR_STORAGE_KEY);
                    applyReaderTextSettings({ rerender: false });
                    syncReaderSettingsUi();
                }


                function getBlaetternTracks() {
                    return getActiveSubtitleTracks();
                }

                function getBlaetternCurrentSubtitleIndex() {
                    return window.audioPlayer && Number.isFinite(window.audioPlayer.currentSubtitleIndex)
                        ? window.audioPlayer.currentSubtitleIndex
                        : -1;
                }

                function clearBlaetternControlsHideTimer() {
                    if (!blaetternControlsHideTimer) return;
                    clearTimeout(blaetternControlsHideTimer);
                    blaetternControlsHideTimer = null;
                }

                function clearBlaetternSwipeCommitTimer() {
                    if (!blaetternSwipeCommitTimer) return;
                    clearTimeout(blaetternSwipeCommitTimer);
                    blaetternSwipeCommitTimer = null;
                }

                function clearBlaetternLongPressTimer() {
                    if (!blaetternLongPressTimer) return;
                    clearTimeout(blaetternLongPressTimer);
                    blaetternLongPressTimer = null;
                }

                function clearBlaetternBookmarkHideTimer() {
                    if (!blaetternBookmarkHideTimer) return;
                    clearTimeout(blaetternBookmarkHideTimer);
                    blaetternBookmarkHideTimer = null;
                }

                function setBlaetternControlsVisible(visible, reason = 'unspecified') {
                    const shouldShow = !isBlaetternLayoutActive() ? true : !!visible;
                    blaetternControlsVisible = shouldShow;
                    if (!audioControlsEl) return;
                    audioControlsEl.classList.toggle('blaettern-controls-hidden', !shouldShow);
                    audioControlsEl.classList.toggle('blaettern-controls-visible', shouldShow);
                    liminalTrace('blaettern:controls', {
                        reason,
                        visible: shouldShow,
                        readingMode: !!isReadingMode,
                        layout: readerSentenceLayout
                    });
                }

                function scheduleBlaetternControlsAutoHide(reason = 'idle') {
                    clearBlaetternControlsHideTimer();
                    if (!isBlaetternLayoutActive()) {
                        setBlaetternControlsVisible(true, `${reason}:inactive`);
                        return;
                    }
                    blaetternControlsHideTimer = setTimeout(() => {
                        setBlaetternControlsVisible(false, `${reason}:timeout`);
                    }, BLAETTERN_CONTROLS_HIDE_DELAY_MS);
                }

                function bumpBlaetternControlsAutoHide(reason = 'interaction') {
                    if (!isBlaetternLayoutActive()) {
                        clearBlaetternControlsHideTimer();
                        setBlaetternControlsVisible(true, `${reason}:not-blaettern`);
                        return;
                    }
                    setBlaetternControlsVisible(true, reason);
                    scheduleBlaetternControlsAutoHide(reason);
                }

                function hideBlaetternBookmarkButton() {
                    const root = subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
                    const btn = root ? root.querySelector('.blaettern-bookmark-btn') : null;
                    if (!btn) return;
                    stopBlaetternBookmarkMapLayerLoop(btn);
                    btn.classList.remove('visible', 'saved');
                    btn.style.removeProperty('left');
                    btn.style.removeProperty('top');
                    btn.dataset.index = '';
                    btn._flatLockedX = null;
                    btn._flatLockedY = null;
                    setBlaetternBookmarkButtonLabel(btn, BLAETTERN_BOOKMARK_LABEL);
                    clearBlaetternBookmarkHideTimer();
                }

                function setBlaetternBookmarkButtonLabel(btn, label) {
                    if (!btn) return;
                    const labelNode = btn.querySelector('.bookmark-label');
                    if (labelNode) labelNode.textContent = label;
                    else btn.innerText = label;
                }

                function ensureBlaetternBookmarkButtonMode(btn) {
                    if (!btn) return;
                    if (btn.dataset.flatOverlay === '1') {
                        btn.classList.add('bookmark-btn-flat-overlay');
                        return;
                    }

                    btn.dataset.flatOverlay = '1';
                    btn.innerHTML = '';
                    const mapLayer = document.createElement('span');
                    mapLayer.className = 'bookmark-map-layer';
                    const mapCanvas = document.createElement('canvas');
                    mapCanvas.className = 'bookmark-map-canvas';
                    mapCanvas.setAttribute('aria-hidden', 'true');
                    mapLayer.appendChild(mapCanvas);

                    const overlayLayer = document.createElement('span');
                    overlayLayer.className = 'bookmark-overlay-layer';
                    const labelLayer = document.createElement('span');
                    labelLayer.className = 'bookmark-label';
                    labelLayer.textContent = BLAETTERN_BOOKMARK_LABEL;

                    btn.appendChild(mapLayer);
                    btn.appendChild(overlayLayer);
                    btn.appendChild(labelLayer);
                    btn.classList.add('bookmark-btn-flat-overlay');
                }

                function resolveBlaetternSceneCanvas() {
                    const gameCanvas = document.getElementById('gameCanvas');
                    if (gameCanvas instanceof HTMLCanvasElement) return gameCanvas;
                    const anyCanvas = document.querySelector('canvas');
                    return anyCanvas instanceof HTMLCanvasElement ? anyCanvas : null;
                }

                function drawBlaetternBookmarkMapLayer(btn) {
                    if (!btn || !btn.classList.contains('bookmark-btn-flat-overlay')) return;
                    const mapLayer = btn.querySelector('.bookmark-map-layer');
                    const mapCanvas = mapLayer ? mapLayer.querySelector('.bookmark-map-canvas') : null;
                    if (!(mapCanvas instanceof HTMLCanvasElement)) return;
                    const drawCtx = mapCanvas.getContext('2d');
                    if (!drawCtx || !mapLayer) return;
                    const sceneCanvas = resolveBlaetternSceneCanvas();
                    if (!sceneCanvas || typeof sceneCanvas.getBoundingClientRect !== 'function') {
                        drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                        return;
                    }
                    try {
                        const canvasRect = sceneCanvas.getBoundingClientRect();
                        const btnRect = btn.getBoundingClientRect();
                        if (!canvasRect.width || !canvasRect.height || !btnRect.width || !btnRect.height) return;
                        const dpr = Math.max(1, window.devicePixelRatio || 1);
                        const targetW = Math.max(1, Math.round(btnRect.width * dpr));
                        const targetH = Math.max(1, Math.round(btnRect.height * dpr));
                        if (mapCanvas.width !== targetW || mapCanvas.height !== targetH) {
                            mapCanvas.width = targetW;
                            mapCanvas.height = targetH;
                        }
                        drawCtx.clearRect(0, 0, targetW, targetH);

                        const overlapLeft = Math.max(btnRect.left, canvasRect.left);
                        const overlapTop = Math.max(btnRect.top, canvasRect.top);
                        const overlapRight = Math.min(btnRect.right, canvasRect.right);
                        const overlapBottom = Math.min(btnRect.bottom, canvasRect.bottom);
                        if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) return;

                        const scaleX = sceneCanvas.width / canvasRect.width;
                        const scaleY = sceneCanvas.height / canvasRect.height;
                        const srcX = (overlapLeft - canvasRect.left) * scaleX;
                        const srcY = (overlapTop - canvasRect.top) * scaleY;
                        const srcW = (overlapRight - overlapLeft) * scaleX;
                        const srcH = (overlapBottom - overlapTop) * scaleY;
                        const dstX = (overlapLeft - btnRect.left) * dpr;
                        const dstY = (overlapTop - btnRect.top) * dpr;
                        const dstW = (overlapRight - overlapLeft) * dpr;
                        const dstH = (overlapBottom - overlapTop) * dpr;
                        drawCtx.drawImage(sceneCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
                    } catch (_) {
                        drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                    }
                }

                function stopBlaetternBookmarkMapLayerLoop(btn) {
                    if (!btn || !btn._flatMapRaf) return;
                    cancelAnimationFrame(btn._flatMapRaf);
                    btn._flatMapRaf = 0;
                }

                function startBlaetternBookmarkMapLayerLoop(btn) {
                    if (!btn || btn._flatMapRaf) return;
                    const tick = () => {
                        if (!btn.isConnected || !btn.classList.contains('visible') || !btn.classList.contains('bookmark-btn-flat-overlay')) {
                            btn._flatMapRaf = 0;
                            return;
                        }
                        drawBlaetternBookmarkMapLayer(btn);
                        btn._flatMapRaf = requestAnimationFrame(tick);
                    };
                    tick();
                }

                function resetBlaetternInteractionState() {
                    clearBlaetternLongPressTimer();
                    clearBlaetternSwipeCommitTimer();
                    blaetternSwipeState = null;
                    blaetternSwipeAnimating = false;
                    hideBlaetternBookmarkButton();
                    const root = subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
                    if (root) resetBlaetternLayerTransforms(root);
                }

                function syncBlaetternUiState(reason = 'unspecified') {
                    if (!uiContainer) return;
                    const active = isBlaetternLayoutActive();
                    uiContainer.classList.toggle('blaettern-layout-active', active);
                    if (!active) {
                        clearBlaetternControlsHideTimer();
                        setBlaetternControlsVisible(true, `${reason}:off`);
                        resetBlaetternInteractionState();
                        return;
                    }
                    if (!blaetternControlsVisible) {
                        setBlaetternControlsVisible(false, `${reason}:keep-hidden`);
                        scheduleBlaetternControlsAutoHide(`${reason}:keep-hidden`);
                        return;
                    }
                    bumpBlaetternControlsAutoHide(`${reason}:on`);
                }

                function getBlaetternRoot() {
                    return subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
                }

                function getBlaetternLayerRefs(root) {
                    if (!root) return null;
                    const prev = root.querySelector('.blaettern-page-prev');
                    const current = root.querySelector('.blaettern-page-current');
                    const next = root.querySelector('.blaettern-page-next');
                    if (!prev || !current || !next) return null;
                    return { prev, current, next };
                }

                function getBlaetternViewportWidth() {
                    const root = getBlaetternRoot();
                    if (!root) return Math.max(1, subtitleContainer ? subtitleContainer.clientWidth : 1);
                    return Math.max(1, root.clientWidth || subtitleContainer.clientWidth || 1);
                }

                function setBlaetternLayerTransition(root, enabled) {
                    const refs = getBlaetternLayerRefs(root);
                    if (!refs) return;
                    const value = enabled ? `transform ${BLAETTERN_SWIPE_SETTLE_MS}ms ease` : 'none';
                    refs.prev.style.transition = value;
                    refs.current.style.transition = value;
                    refs.next.style.transition = value;
                }

                function resetBlaetternLayerTransforms(root) {
                    const refs = getBlaetternLayerRefs(root);
                    const width = getBlaetternViewportWidth();
                    if (!refs || !width) return;
                    refs.prev.style.transform = `translate3d(${-width}px, 0, 0)`;
                    refs.current.style.transform = 'translate3d(0, 0, 0)';
                    refs.next.style.transform = `translate3d(${width}px, 0, 0)`;
                }

                function applyBlaetternSwipeOffset(root, rawOffsetPx) {
                    const refs = getBlaetternLayerRefs(root);
                    const width = getBlaetternViewportWidth();
                    if (!refs || !width) return;
                    const offsetPx = Number(rawOffsetPx) || 0;
                    const hasPrev = blaetternPageIndex > 0;
                    const hasNext = blaetternPageIndex < blaetternPages.length - 1;
                    let clamped = offsetPx;
                    const edgeClamp = width * 0.24;
                    if (clamped < 0 && !hasNext) clamped = Math.max(clamped, -edgeClamp);
                    if (clamped > 0 && !hasPrev) clamped = Math.min(clamped, edgeClamp);

                    if (clamped < 0) {
                        refs.prev.style.transform = `translate3d(${-width}px, 0, 0)`;
                        refs.current.style.transform = `translate3d(${clamped}px, 0, 0)`;
                        refs.next.style.transform = `translate3d(${width + clamped}px, 0, 0)`;
                    } else {
                        refs.prev.style.transform = `translate3d(${-width + clamped}px, 0, 0)`;
                        refs.current.style.transform = `translate3d(${clamped}px, 0, 0)`;
                        refs.next.style.transform = `translate3d(${width}px, 0, 0)`;
                    }
                    return clamped;
                }

                function createBlaetternLineElement(index, options = {}) {
                    const track = getBlaetternTracks()[index];
                    const span = document.createElement('span');
                    span.className = 'subtitle-line blaettern-line';
                    span.dataset.index = String(index);
                    span.innerText = track ? track.text : '';
                    if (!options.forMeasure) {
                        span.title = 'Tippen zum Abspielen';
                        span.style.cursor = 'pointer';
                        if (index === getBlaetternCurrentSubtitleIndex()) span.classList.add('subtitle-current');
                    }
                    return span;
                }

                function clearBlaetternSmartLineStyle(lineEl) {
                    if (!lineEl) return;
                    lineEl.classList.remove('blaettern-line-smart');
                    lineEl.style.removeProperty('--blaettern-smart-word-spacing');
                    lineEl.style.removeProperty('--blaettern-smart-letter-spacing');
                    lineEl.style.removeProperty('--blaettern-smart-stretch');
                    lineEl.style.removeProperty('--blaettern-smart-wdth');
                }

                function applyBlaetternSmartJustification(layer) {
                    if (!layer || layer.classList.contains('blaettern-page-empty')) return;
                    const lineElements = Array.from(layer.querySelectorAll('.blaettern-line'));
                    if (!lineElements.length) return;

                    const layerRect = layer.getBoundingClientRect();
                    const layerStyle = window.getComputedStyle(layer);
                    const paddingLeft = parseFloat(layerStyle.paddingLeft) || 0;
                    const paddingRight = parseFloat(layerStyle.paddingRight) || 0;
                    const innerWidth = Math.max(1, layer.clientWidth - paddingLeft - paddingRight);
                    if (innerWidth <= 20) return;
                    const sampleLine = lineElements[0];
                    const sampleLineStyle = sampleLine ? window.getComputedStyle(sampleLine) : null;
                    const timestampGapPx = sampleLineStyle ? (parseFloat(sampleLineStyle.marginRight) || 0) : 0;

                    const elementRectCount = new Map();
                    const linesByTop = new Map();

                    lineElements.forEach((lineEl) => {
                        clearBlaetternSmartLineStyle(lineEl);
                        const rects = Array.from(lineEl.getClientRects()).filter((rect) => rect.width > 1 && rect.height > 1);
                        elementRectCount.set(lineEl, rects.length);
                        rects.forEach((rect) => {
                            const key = Math.round(rect.top - layerRect.top);
                            let line = linesByTop.get(key);
                            if (!line) {
                                line = {
                                    left: rect.left,
                                    right: rect.right,
                                    elements: new Set()
                                };
                                linesByTop.set(key, line);
                            } else {
                                line.left = Math.min(line.left, rect.left);
                                line.right = Math.max(line.right, rect.right);
                            }
                            line.elements.add(lineEl);
                        });
                    });

                    const visualLines = Array.from(linesByTop.entries())
                        .sort((a, b) => a[0] - b[0])
                        .map((entry) => entry[1]);
                    if (visualLines.length <= 1) return;

                    for (let i = 0; i < visualLines.length - 1; i++) {
                        const line = visualLines[i];
                        const elements = Array.from(line.elements);
                        if (!elements.length) continue;
                        if (elements.some((el) => (elementRectCount.get(el) || 0) > 1)) continue;

                        const lineWidth = Math.max(0, line.right - line.left);
                        const boundaryCount = Math.max(0, elements.length - 1);
                        const lineVisualWidth = lineWidth + (boundaryCount * timestampGapPx);
                        const slack = innerWidth - lineVisualWidth;
                        if (slack < 4 || slack > (innerWidth * 0.24)) continue;

                        let letters = 0;
                        let spaces = 0;
                        elements.forEach((el) => {
                            const compact = (el.textContent || '').replace(/\s+/g, ' ').trim();
                            if (!compact) return;
                            letters += compact.replace(/\s/g, '').length;
                            const localSpaces = compact.match(/\s+/g);
                            if (localSpaces) spaces += localSpaces.length;
                        });
                        const totalGapUnits = spaces + boundaryCount;
                        if (letters < 8) continue;
                        if (totalGapUnits < 3 && slack > 20) continue;

                        const sparseLine = totalGapUnits < 6;
                        const wordShare = sparseLine ? 0.52 : 0.68;
                        const letterShare = sparseLine ? 0.31 : 0.24;
                        const stretchShare = 1 - wordShare - letterShare;

                        const addWord = Math.min(1.35, Math.max(0, (slack * wordShare) / Math.max(1, totalGapUnits)));
                        const addLetter = Math.min(0.21, Math.max(0, (slack * letterShare) / Math.max(36, letters)));
                        const usedSlack = (addWord * totalGapUnits) + (addLetter * letters);
                        const remainingSlack = Math.max(0, slack - usedSlack);
                        const stretchScale = Math.min(1.085, 1 + ((remainingSlack * stretchShare) / Math.max(220, lineVisualWidth)));
                        const stretchPercent = stretchScale * 100;
                        const wdthValue = stretchPercent;

                        if (addWord < 0.05 && addLetter < 0.01 && stretchScale <= 1.003) continue;

                        elements.forEach((el) => {
                            el.classList.add('blaettern-line-smart');
                            el.style.setProperty('--blaettern-smart-word-spacing', `${addWord.toFixed(3)}px`);
                            el.style.setProperty('--blaettern-smart-letter-spacing', `${addLetter.toFixed(3)}px`);
                            el.style.setProperty('--blaettern-smart-stretch', `${stretchPercent.toFixed(2)}%`);
                            el.style.setProperty('--blaettern-smart-wdth', wdthValue.toFixed(2));
                        });
                    }
                }

                function findBlaetternPageIndexForSubtitle(subtitleIndex) {
                    if (!blaetternPages.length) return 0;
                    const idx = Math.max(0, Math.min(getBlaetternTracks().length - 1, Number(subtitleIndex) || 0));
                    for (let i = 0; i < blaetternPages.length; i++) {
                        const page = blaetternPages[i];
                        if (idx >= page.startIndex && idx <= page.endIndex) return i;
                    }
                    return Math.max(0, blaetternPages.length - 1);
                }

                function ensureBlaetternPagination() {
                    if (!subtitleContainer) return false;
                    if (!getBlaetternTracks().length) {
                        blaetternPages = [];
                        blaetternPageIndex = 0;
                        blaetternPaginationDirty = false;
                        blaetternPaginationKey = '';
                        return true;
                    }

                    const width = Math.round(subtitleContainer.clientWidth || 0);
                    const height = Math.round(subtitleContainer.clientHeight || 0);
                    if (width <= 20 || height <= 20) return false;

                    const signature = [
                        window.subtitleVersion || 0,
                        getBlaetternTracks().length,
                        readerFontSizePx,
                        readerSentenceLayout,
                        width,
                        height
                    ].join('|');

                    if (!blaetternPaginationDirty && blaetternPaginationKey === signature && blaetternPages.length) {
                        return true;
                    }

                    const measureLayer = document.createElement('div');
                    measureLayer.className = 'blaettern-page-layer blaettern-page-layer-measure';
                    measureLayer.setAttribute('aria-hidden', 'true');
                    subtitleContainer.appendChild(measureLayer);

                    const computedPages = [];
                    let startIndex = 0;
                    while (startIndex < getBlaetternTracks().length) {
                        measureLayer.replaceChildren();
                        let endIndex = startIndex - 1;

                        for (let i = startIndex; i < getBlaetternTracks().length; i++) {
                            const node = createBlaetternLineElement(i, { forMeasure: true });
                            measureLayer.appendChild(node);
                            if (measureLayer.scrollHeight > (measureLayer.clientHeight + 1)) {
                                measureLayer.removeChild(node);
                                break;
                            }
                            endIndex = i;
                        }

                        if (endIndex < startIndex) {
                            endIndex = startIndex;
                            measureLayer.appendChild(createBlaetternLineElement(startIndex, { forMeasure: true }));
                        }

                        computedPages.push({ startIndex, endIndex });
                        startIndex = endIndex + 1;
                    }

                    measureLayer.remove();
                    blaetternPages = computedPages;
                    blaetternPaginationDirty = false;
                    blaetternPaginationKey = signature;

                    const anchorIndex = Number.isFinite(getBlaetternCurrentSubtitleIndex()) && getBlaetternCurrentSubtitleIndex() >= 0
                        ? getBlaetternCurrentSubtitleIndex()
                        : (blaetternPages[Math.max(0, Math.min(blaetternPageIndex, blaetternPages.length - 1))]?.startIndex || 0);
                    blaetternPageIndex = findBlaetternPageIndexForSubtitle(anchorIndex);
                    return true;
                }

                function renderBlaetternLayer(layer, pageIdx) {
                    if (!layer) return;
                    layer.replaceChildren();
                    layer.dataset.pageIndex = String(pageIdx);

                    if (pageIdx < 0 || pageIdx >= blaetternPages.length) {
                        layer.classList.add('blaettern-page-empty');
                        return;
                    }

                    layer.classList.remove('blaettern-page-empty');
                    const page = blaetternPages[pageIdx];
                    for (let i = page.startIndex; i <= page.endIndex; i++) {
                        layer.appendChild(createBlaetternLineElement(i));
                    }
                    applyBlaetternSmartJustification(layer);
                }

                function updateBlaetternProgressBadge(root) {
                    if (!root) return;
                    const badge = root.querySelector('.blaettern-progress-indicator');
                    if (!badge) return;
                    if (!blaetternPages.length || !getBlaetternTracks().length) {
                        badge.innerText = '0%';
                        return;
                    }
                    const page = blaetternPages[Math.max(0, Math.min(blaetternPageIndex, blaetternPages.length - 1))];
                    const percent = Math.max(0, Math.min(100, Math.floor((page.startIndex / Math.max(1, getBlaetternTracks().length)) * 100)));
                    badge.innerText = `${percent}%`;
                }

                function ensureBlaetternRoot() {
                    let root = getBlaetternRoot();
                    if (root) return root;

                    subtitleContainer.innerHTML = '';
                    root = document.createElement('div');
                    root.className = 'blaettern-page-root';

                    const badge = document.createElement('div');
                    badge.className = 'blaettern-progress-indicator';
                    badge.setAttribute('aria-live', 'polite');
                    root.appendChild(badge);

                    const prev = document.createElement('div');
                    prev.className = 'blaettern-page-layer blaettern-page-prev';
                    root.appendChild(prev);

                    const current = document.createElement('div');
                    current.className = 'blaettern-page-layer blaettern-page-current';
                    root.appendChild(current);

                    const next = document.createElement('div');
                    next.className = 'blaettern-page-layer blaettern-page-next';
                    root.appendChild(next);

                    const bookmarkBtn = document.createElement('button');
                    bookmarkBtn.className = 'bookmark-btn blaettern-bookmark-btn bookmark-btn-flat-overlay';
                    bookmarkBtn.type = 'button';
                    bookmarkBtn.dataset.index = '';
                    ensureBlaetternBookmarkButtonMode(bookmarkBtn);
                    setBlaetternBookmarkButtonLabel(bookmarkBtn, BLAETTERN_BOOKMARK_LABEL);
                    root.appendChild(bookmarkBtn);

                    bookmarkBtn.addEventListener('click', async (ev) => {
                        ev.preventDefault();
                        ev.stopPropagation();
                        const idx = Number(bookmarkBtn.dataset.index);
                        if (!Number.isFinite(idx) || idx < 0 || idx >= getBlaetternTracks().length) return;
                        const track = getBlaetternTracks()[idx];
                        if (!track || !window.GameState || typeof window.GameState.addBookmark !== 'function') return;

                        const loreId = (isLoreMode && Number.isFinite(activeLoreId)) ? Number(activeLoreId) : null;
                        const loreMeta = loreId && window.GameState && typeof window.GameState.getLore === 'function'
                            ? window.GameState.getLore(loreId)
                            : null;
                        const bookmarkContentKey = loreId ? `lore${loreId}` : MAIN_CONTENT_KEY;
                        const bookmarkChapter = loreId ? `lore${loreId}` : CURRENT_CHAPTER;
                        const bookmarkChapterTitle = loreId
                            ? (loreMeta && loreMeta.title ? `Lore ${loreId}: ${loreMeta.title}` : `Lore ${loreId}`)
                            : CURRENT_CHAPTER_TITLE;
                        const bookmarkAudioRef = loreId
                            ? ((loreMeta && loreMeta.audio) || `assets/lore${loreId}.mp3`)
                            : 'assets/kapitel1b.mp3';
                        const bookmarkTextRef = loreId
                            ? ((loreMeta && loreMeta.text) || `assets/lore${loreId}.txt`)
                            : 'assets/kapitel1b.txt';
                        const bm = {
                            id: Date.now(),
                            chapter: bookmarkChapter,
                            chapterTitle: bookmarkChapterTitle,
                            page: CURRENT_PAGE,
                            time: track.time,
                            textPreview: (track.text || '').substring(0, 60),
                            contentKey: bookmarkContentKey,
                            loreId: loreId,
                            audioRef: bookmarkAudioRef,
                            textRef: bookmarkTextRef,
                            createdAt: Date.now()
                        };

                        const added = await window.GameState.addBookmark(bm);
                        if (added) {
                            bookmarkBtn.classList.add('saved', 'visible');
                            setBlaetternBookmarkButtonLabel(bookmarkBtn, BLAETTERN_BOOKMARK_SAVED_LABEL);
                            if (typeof updateBookmarkList === 'function') updateBookmarkList();
                            clearBlaetternBookmarkHideTimer();
                            blaetternBookmarkHideTimer = setTimeout(() => {
                                hideBlaetternBookmarkButton();
                            }, 1200);
                            return;
                        }
                        hideBlaetternBookmarkButton();
                    });

                    subtitleContainer.appendChild(root);
                    return root;
                }

                function positionBlaetternBookmarkButton(btn, lineEl, point = null, options = {}) {
                    if (!btn || !lineEl || !subtitleContainer) return;
                    ensureBlaetternBookmarkButtonMode(btn);
                    const containerRect = subtitleContainer.getBoundingClientRect();
                    const lineRect = lineEl.getBoundingClientRect();
                    const btnW = btn.offsetWidth || 118;
                    const btnH = btn.offsetHeight || 36;
                    const margin = 8;

                    if (options.lockToExisting && Number.isFinite(btn._flatLockedX) && Number.isFinite(btn._flatLockedY)) {
                        btn.style.left = `${Math.round(btn._flatLockedX)}px`;
                        btn.style.top = `${Math.round(btn._flatLockedY)}px`;
                        startBlaetternBookmarkMapLayerLoop(btn);
                        drawBlaetternBookmarkMapLayer(btn);
                        return;
                    }

                    let x = point && Number.isFinite(point.clientX)
                        ? point.clientX - (btnW / 2)
                        : lineRect.left + ((lineRect.width - btnW) / 2);
                    let y = lineRect.top - btnH - 10;
                    if (y < containerRect.top + margin) y = lineRect.bottom + 10;

                    x = Math.max(margin, Math.min(window.innerWidth - btnW - margin, x));
                    y = Math.max(margin, Math.min(window.innerHeight - btnH - margin, y));
                    btn._flatLockedX = Math.round(x);
                    btn._flatLockedY = Math.round(y);
                    btn.style.left = `${btn._flatLockedX}px`;
                    btn.style.top = `${btn._flatLockedY}px`;
                    startBlaetternBookmarkMapLayerLoop(btn);
                    drawBlaetternBookmarkMapLayer(btn);
                }

                function showBlaetternBookmarkButton(lineIndex, point = null) {
                    const root = ensureBlaetternRoot();
                    const lineEl = root.querySelector(`.blaettern-page-current .blaettern-line[data-index="${lineIndex}"]`);
                    const btn = root.querySelector('.blaettern-bookmark-btn');
                    if (!lineEl || !btn) return;
                    btn.dataset.index = String(lineIndex);
                    ensureBlaetternBookmarkButtonMode(btn);
                    setBlaetternBookmarkButtonLabel(btn, BLAETTERN_BOOKMARK_LABEL);
                    btn.classList.remove('saved');
                    btn.classList.add('visible');
                    positionBlaetternBookmarkButton(btn, lineEl, point);
                    clearBlaetternBookmarkHideTimer();
                    blaetternBookmarkHideTimer = setTimeout(() => {
                        if (!btn.classList.contains('saved')) hideBlaetternBookmarkButton();
                    }, 4000);
                }

                function renderBlaetternPageWindow() {
                    const root = ensureBlaetternRoot();
                    const refs = getBlaetternLayerRefs(root);
                    if (!refs) return;
                    renderBlaetternLayer(refs.prev, blaetternPageIndex - 1);
                    renderBlaetternLayer(refs.current, blaetternPageIndex);
                    renderBlaetternLayer(refs.next, blaetternPageIndex + 1);
                    setBlaetternLayerTransition(root, false);
                    resetBlaetternLayerTransforms(root);
                    updateBlaetternProgressBadge(root);
                    hideBlaetternBookmarkButton();
                }

                function renderBlaetternReadingPage(centerIndex) {
                    syncReadingTopFadeMask(-1);
                    if (!getBlaetternTracks().length) {
                        clearBlaetternPaginationRetryTimer();
                        subtitleContainer.innerHTML = '';
                        const emptyLine = document.createElement('div');
                        emptyLine.className = 'subtitle-line subtitle-current';
                        emptyLine.innerText = 'Warte auf Audio/Text...';
                        subtitleContainer.appendChild(emptyLine);
                        return;
                    }

                    if (!ensureBlaetternPagination()) {
                        scheduleBlaetternPaginationRetry('pagination-not-ready');
                        if (!subtitleContainer.children.length) {
                            const emptyLine = document.createElement('div');
                            emptyLine.className = 'subtitle-line subtitle-current';
                            emptyLine.innerText = 'Lade Seitenlayout...';
                            subtitleContainer.appendChild(emptyLine);
                        }
                        return;
                    }
                    clearBlaetternPaginationRetryTimer();
                    const safeIndex = Math.max(
                        0,
                        Math.min(
                            getBlaetternTracks().length - 1,
                            Number.isFinite(centerIndex) && centerIndex >= 0 ? centerIndex : 0
                        )
                    );

                    if (!blaetternSwipeAnimating && !subtitleFollowLocked) {
                        if (blaetternLastSyncedSubtitleIndex !== safeIndex) {
                            blaetternPageIndex = findBlaetternPageIndexForSubtitle(safeIndex);
                        }
                    }
                    blaetternLastSyncedSubtitleIndex = safeIndex;
                    renderBlaetternPageWindow();
                }

                function resolveBlaetternSwipeDirection(offsetPx, velocityPxPerMs) {
                    const width = getBlaetternViewportWidth();
                    if (!width || blaetternPages.length <= 1) return 0;
                    const hasPrev = blaetternPageIndex > 0;
                    const hasNext = blaetternPageIndex < blaetternPages.length - 1;
                    const turnThreshold = width * BLAETTERN_SWIPE_TURN_RATIO;

                    if (offsetPx < 0 && hasNext) {
                        if (Math.abs(offsetPx) > turnThreshold || velocityPxPerMs <= -BLAETTERN_SWIPE_VELOCITY_THRESHOLD) return 1;
                    }
                    if (offsetPx > 0 && hasPrev) {
                        if (Math.abs(offsetPx) > turnThreshold || velocityPxPerMs >= BLAETTERN_SWIPE_VELOCITY_THRESHOLD) return -1;
                    }
                    return 0;
                }

                function finishBlaetternSwipe(direction) {
                    const root = getBlaetternRoot();
                    if (!root) return;
                    const refs = getBlaetternLayerRefs(root);
                    const width = getBlaetternViewportWidth();
                    if (!refs || !width) return;

                    blaetternSwipeAnimating = true;
                    setBlaetternLayerTransition(root, true);

                    if (direction === 1) {
                        refs.current.style.transform = `translate3d(${-width}px, 0, 0)`;
                        refs.next.style.transform = 'translate3d(0, 0, 0)';
                    } else if (direction === -1) {
                        refs.prev.style.transform = 'translate3d(0, 0, 0)';
                        refs.current.style.transform = `translate3d(${width}px, 0, 0)`;
                    } else {
                        resetBlaetternLayerTransforms(root);
                    }

                    clearBlaetternSwipeCommitTimer();
                    blaetternSwipeCommitTimer = setTimeout(() => {
                        blaetternSwipeAnimating = false;
                        if (direction === 1) blaetternPageIndex = Math.min(blaetternPages.length - 1, blaetternPageIndex + 1);
                        if (direction === -1) blaetternPageIndex = Math.max(0, blaetternPageIndex - 1);
                        if (direction !== 0 && isBlaetternLayoutActive()) {
                            setSubtitleFollowLocked(true);
                        }
                        renderBlaetternPageWindow();
                        if (isBlaetternLayoutActive()) scheduleBlaetternControlsAutoHide('swipe-finish');
                    }, BLAETTERN_SWIPE_SETTLE_MS + 10);
                }

                async function handleBlaetternTimestampTap(lineIndex) {
                    if (!Number.isFinite(lineIndex) || lineIndex < 0 || lineIndex >= getBlaetternTracks().length) return;
                    if (contentSwitchInProgress) return;
                    if (Date.now() < blaetternSuppressTapUntil) return;
                    const track = getBlaetternTracks()[lineIndex];
                    if (!track) return;
                    setSubtitleFollowLocked(false, 'blaettern-tap');
                    await seekAndSyncSubtitle(window.audioPlayer, track.time, `blaettern-click:${lineIndex}`);
                    try {
                        await window.audioPlayer.play();
                    } catch (_) {
                        // ignore autoplay restrictions
                    }
                    bumpBlaetternControlsAutoHide('blaettern-tap');
                }

                function onBlaetternPointerDown(event) {
                    if (!isBlaetternLayoutActive()) return;
                    if (contentSwitchInProgress) return;
                    if (blaetternSwipeAnimating) {
                        event.preventDefault();
                        return;
                    }
                    if (event.button !== undefined && event.button !== 0) return;
                    if (event.target && typeof event.target.closest === 'function' && event.target.closest('.blaettern-bookmark-btn')) {
                        bumpBlaetternControlsAutoHide('blaettern-bookmark-touch');
                        return;
                    }

                    const targetLine = event.target && typeof event.target.closest === 'function'
                        ? event.target.closest('.blaettern-line')
                        : null;
                    const consumeTap = !blaetternControlsVisible;
                    bumpBlaetternControlsAutoHide('blaettern-touch');
                    if (consumeTap) blaetternSuppressTapUntil = Date.now() + 300;

                    hideBlaetternBookmarkButton();
                    blaetternSwipeState = {
                        pointerId: event.pointerId,
                        startX: event.clientX,
                        startY: event.clientY,
                        lastX: event.clientX,
                        lastY: event.clientY,
                        startTime: performance.now(),
                        mode: 'pending',
                        offsetPx: 0,
                        lineIndex: targetLine ? Number(targetLine.dataset.index) : -1,
                        consumeTap,
                        movedBeyondTap: false
                    };

                    if (subtitleContainer && typeof subtitleContainer.setPointerCapture === 'function') {
                        try {
                            subtitleContainer.setPointerCapture(event.pointerId);
                        } catch (_) {
                            // no-op
                        }
                    }

                    clearBlaetternLongPressTimer();
                    if (!consumeTap && targetLine && Number.isFinite(blaetternSwipeState.lineIndex) && blaetternSwipeState.lineIndex >= 0) {
                        blaetternLongPressTimer = setTimeout(() => {
                            if (!blaetternSwipeState || blaetternSwipeState.mode !== 'pending') return;
                            blaetternSwipeState.mode = 'longpress';
                            blaetternSuppressTapUntil = Date.now() + 500;
                            showBlaetternBookmarkButton(blaetternSwipeState.lineIndex, {
                                clientX: blaetternSwipeState.lastX,
                                clientY: blaetternSwipeState.lastY
                            });
                        }, BLAETTERN_LONG_PRESS_DELAY_MS);
                    }

                    event.preventDefault();
                }

                function onBlaetternPointerMove(event) {
                    if (!isBlaetternLayoutActive()) return;
                    if (!blaetternSwipeState) return;
                    if (event.pointerId !== blaetternSwipeState.pointerId) return;

                    const dx = event.clientX - blaetternSwipeState.startX;
                    const dy = event.clientY - blaetternSwipeState.startY;
                    blaetternSwipeState.lastX = event.clientX;
                    blaetternSwipeState.lastY = event.clientY;

                    if (blaetternSwipeState.mode === 'pending') {
                        if (Math.abs(dx) > 14 && Math.abs(dx) > Math.abs(dy) * 1.1) {
                            blaetternSwipeState.mode = 'swipe';
                            blaetternSwipeState.movedBeyondTap = true;
                            clearBlaetternLongPressTimer();
                        } else if (Math.hypot(dx, dy) > 9) {
                            blaetternSwipeState.movedBeyondTap = true;
                            clearBlaetternLongPressTimer();
                        }
                    }

                    if (blaetternSwipeState.mode !== 'swipe') return;
                    const root = getBlaetternRoot();
                    if (!root) return;
                    setBlaetternLayerTransition(root, false);
                    blaetternSwipeState.offsetPx = applyBlaetternSwipeOffset(root, dx);
                    event.preventDefault();
                }

                function onBlaetternPointerEnd(event) {
                    if (!isBlaetternLayoutActive()) return;
                    if (!blaetternSwipeState) return;
                    if (event.pointerId !== blaetternSwipeState.pointerId) return;

                    const localState = blaetternSwipeState;
                    blaetternSwipeState = null;
                    clearBlaetternLongPressTimer();
                    if (subtitleContainer && typeof subtitleContainer.releasePointerCapture === 'function') {
                        try {
                            subtitleContainer.releasePointerCapture(event.pointerId);
                        } catch (_) {
                            // no-op
                        }
                    }

                    if (event.type === 'pointercancel') return;

                    if (localState.mode === 'swipe') {
                        const elapsed = Math.max(1, performance.now() - localState.startTime);
                        const velocity = (localState.lastX - localState.startX) / elapsed;
                        const direction = resolveBlaetternSwipeDirection(localState.offsetPx, velocity);
                        finishBlaetternSwipe(direction);
                        event.preventDefault();
                        return;
                    }

                    if (localState.mode === 'longpress') {
                        event.preventDefault();
                        return;
                    }

                    if (localState.consumeTap) {
                        event.preventDefault();
                        return;
                    }

                    if (localState.movedBeyondTap) {
                        event.preventDefault();
                        return;
                    }

                    if (Number.isFinite(localState.lineIndex) && localState.lineIndex >= 0) {
                        handleBlaetternTimestampTap(localState.lineIndex);
                        event.preventDefault();
                    }
                }

                function clamp01(value) {
                    if (!Number.isFinite(value)) return 0;
                    if (value <= 0) return 0;
                    if (value >= 1) return 1;
                    return value;
                }

                function hexToRgb(hex) {
                    const normalized = normalizeReaderHexColor(hex, null);
                    if (!normalized) return null;
                    const raw = normalized.slice(1);
                    return {
                        r: parseInt(raw.slice(0, 2), 16),
                        g: parseInt(raw.slice(2, 4), 16),
                        b: parseInt(raw.slice(4, 6), 16)
                    };
                }

                function rgbToHex(r, g, b) {
                    const toHex = (value) => {
                        const clamped = Math.max(0, Math.min(255, Math.round(value)));
                        return clamped.toString(16).padStart(2, '0');
                    };
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                }

                function rgbToHsl(r, g, b) {
                    const rr = r / 255;
                    const gg = g / 255;
                    const bb = b / 255;
                    const max = Math.max(rr, gg, bb);
                    const min = Math.min(rr, gg, bb);
                    const delta = max - min;
                    let h = 0;
                    const l = (max + min) / 2;
                    let s = 0;

                    if (delta !== 0) {
                        s = delta / (1 - Math.abs((2 * l) - 1));
                        if (max === rr) h = 60 * (((gg - bb) / delta) % 6);
                        else if (max === gg) h = 60 * (((bb - rr) / delta) + 2);
                        else h = 60 * (((rr - gg) / delta) + 4);
                    }

                    if (!Number.isFinite(h)) h = 0;
                    if (h < 0) h += 360;
                    return { h, s: clamp01(s), l: clamp01(l) };
                }

                function hslToRgb(h, s, l) {
                    const hue = ((Number(h) % 360) + 360) % 360;
                    const sat = clamp01(s);
                    const lig = clamp01(l);
                    const c = (1 - Math.abs((2 * lig) - 1)) * sat;
                    const hh = hue / 60;
                    const x = c * (1 - Math.abs((hh % 2) - 1));
                    let r1 = 0;
                    let g1 = 0;
                    let b1 = 0;

                    if (hh >= 0 && hh < 1) { r1 = c; g1 = x; }
                    else if (hh < 2) { r1 = x; g1 = c; }
                    else if (hh < 3) { g1 = c; b1 = x; }
                    else if (hh < 4) { g1 = x; b1 = c; }
                    else if (hh < 5) { r1 = x; b1 = c; }
                    else { r1 = c; b1 = x; }

                    const m = lig - (c / 2);
                    return {
                        r: Math.round((r1 + m) * 255),
                        g: Math.round((g1 + m) * 255),
                        b: Math.round((b1 + m) * 255)
                    };
                }

                function getWheelColorAtOffset(offsetX, offsetY, radius) {
                    const safeRadius = Math.max(1, radius);
                    const distance = Math.min(1, Math.hypot(offsetX, offsetY) / safeRadius);
                    const hue = ((Math.atan2(offsetY, offsetX) * (180 / Math.PI)) + 360) % 360;
                    const saturation = 0.18 + (distance * 0.82);
                    const lightness = 0.64 - (distance * 0.24);
                    const rgb = hslToRgb(hue, saturation, lightness);
                    return rgbToHex(rgb.r, rgb.g, rgb.b);
                }

                function setReaderWheelMarkerFromHex(markerEl, wheelEl, hexColor) {
                    if (!markerEl || !wheelEl) return;
                    const rgb = hexToRgb(hexColor);
                    if (!rgb) return;
                    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                    const size = Math.min(wheelEl.clientWidth || wheelEl.width || 0, wheelEl.clientHeight || wheelEl.height || 0);
                    if (!size) return;
                    const radius = size / 2;
                    const sat = clamp01((hsl.s - 0.18) / 0.82);
                    const angle = (hsl.h * Math.PI) / 180;
                    const markerRadius = sat * radius;
                    const x = radius + (Math.cos(angle) * markerRadius);
                    const y = radius + (Math.sin(angle) * markerRadius);
                    markerEl.style.left = `${x}px`;
                    markerEl.style.top = `${y}px`;
                }

                function drawReaderGoetheColorWheel(canvasEl) {
                    if (!canvasEl) return;
                    const width = Number(canvasEl.width) || 168;
                    const height = Number(canvasEl.height) || 168;
                    const ctx = canvasEl.getContext('2d');
                    if (!ctx) return;

                    const cx = width / 2;
                    const cy = height / 2;
                    const radius = Math.min(width, height) / 2;
                    const image = ctx.createImageData(width, height);
                    const data = image.data;

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const dx = x + 0.5 - cx;
                            const dy = y + 0.5 - cy;
                            const dist = Math.hypot(dx, dy);
                            const index = (y * width + x) * 4;
                            if (dist > radius) {
                                data[index + 3] = 0;
                                continue;
                            }
                            const distNorm = dist / radius;
                            const hue = ((Math.atan2(dy, dx) * (180 / Math.PI)) + 360) % 360;
                            const saturation = 0.18 + (distNorm * 0.82);
                            const lightness = 0.64 - (distNorm * 0.24);
                            const rgb = hslToRgb(hue, saturation, lightness);
                            data[index] = rgb.r;
                            data[index + 1] = rgb.g;
                            data[index + 2] = rgb.b;
                            data[index + 3] = 255;
                        }
                    }

                    ctx.clearRect(0, 0, width, height);
                    ctx.putImageData(image, 0, 0);
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius - 0.5, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.36, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.restore();
                }

                function initReaderColorWheelControl(config) {
                    const canvasEl = document.getElementById(config.canvasId);
                    const markerEl = document.getElementById(config.markerId);
                    const previewEl = document.getElementById(config.previewId);
                    if (!canvasEl || !markerEl || !previewEl || typeof config.onPick !== 'function') {
                        return null;
                    }

                    drawReaderGoetheColorWheel(canvasEl);

                    const updatePreviewAndMarker = (hexColor) => {
                        const normalized = normalizeReaderHexColor(hexColor, null);
                        if (!normalized) return;
                        previewEl.style.background = normalized;
                        setReaderWheelMarkerFromHex(markerEl, canvasEl, normalized);
                    };

                    const pickFromClientPoint = (clientX, clientY) => {
                        const rect = canvasEl.getBoundingClientRect();
                        if (!rect.width || !rect.height) return;
                        const radius = Math.min(rect.width, rect.height) / 2;
                        const localX = clientX - (rect.left + (rect.width / 2));
                        const localY = clientY - (rect.top + (rect.height / 2));
                        const hex = getWheelColorAtOffset(localX, localY, radius);
                        config.onPick(hex);
                    };

                    let pointerActive = false;
                    const onPointerMove = (event) => {
                        if (!pointerActive) return;
                        pickFromClientPoint(event.clientX, event.clientY);
                    };
                    const onPointerUp = () => {
                        pointerActive = false;
                    };
                    canvasEl.addEventListener('pointerdown', (event) => {
                        event.preventDefault();
                        pointerActive = true;
                        pickFromClientPoint(event.clientX, event.clientY);
                    });
                    window.addEventListener('pointermove', onPointerMove);
                    window.addEventListener('pointerup', onPointerUp);
                    window.addEventListener('pointercancel', onPointerUp);

                    canvasEl.addEventListener('touchstart', (event) => {
                        if (!event.touches || !event.touches.length) return;
                        const t = event.touches[0];
                        pickFromClientPoint(t.clientX, t.clientY);
                    }, { passive: true });
                    canvasEl.addEventListener('touchmove', (event) => {
                        if (!event.touches || !event.touches.length) return;
                        const t = event.touches[0];
                        pickFromClientPoint(t.clientX, t.clientY);
                    }, { passive: true });

                    return updatePreviewAndMarker;
                }

                // --- Slider fill gradient for WebKit (Chrome/Safari/Electron) ---
                function updateSliderFill(rangeEl) {
                    // Gold fill removed  plain white track only
                    if (rangeEl) rangeEl.style.background = '';
                }

                function updateAllSliderFills() {
                    ['readerFontSizeRange', 'readerTextVolumeRange', 'readerBackgroundVolumeRange'].forEach(id => {
                        updateSliderFill(document.getElementById(id));
                    });
                }

                function initReaderSettingsControls() {
                    const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
                    layoutInputs.forEach((input) => {
                        input.addEventListener('change', () => {
                            if (!input.checked) return;
                            setReaderSentenceLayout(input.value);
                        });
                    });
                    const fontButtons = document.querySelectorAll('.reader-font-option');
                    fontButtons.forEach((button) => {
                        button.addEventListener('click', () => {
                            const nextFont = button.dataset.font;
                            if (!nextFont) return;
                            setReaderFontFamily(nextFont);
                        });
                    });

                    const rangeInput = document.getElementById('readerFontSizeRange');
                    const numberInput = document.getElementById('readerFontSizeNumber');
                    if (rangeInput) {
                        rangeInput.addEventListener('input', (event) => {
                            setReaderFontSize(event.target.value);
                            updateSliderFill(event.target);
                        });
                    }
                    if (numberInput) {
                        numberInput.addEventListener('input', (event) => {
                            setReaderFontSize(event.target.value);
                        });
                        numberInput.addEventListener('change', (event) => {
                            setReaderFontSize(event.target.value, { force: true });
                        });
                    }

                    const bindVolumeInputs = (rangeId, numberId, setter) => {
                        const rangeEl = document.getElementById(rangeId);
                        const numberEl = document.getElementById(numberId);
                        if (rangeEl) {
                            rangeEl.addEventListener('input', (event) => {
                                setter(event.target.value);
                                updateSliderFill(event.target);
                            });
                        }
                        if (numberEl) {
                            numberEl.addEventListener('input', (event) => {
                                setter(event.target.value);
                            });
                            numberEl.addEventListener('change', (event) => {
                                setter(event.target.value, { force: true });
                            });
                        }
                    };

                    bindVolumeInputs('readerTextVolumeRange', 'readerTextVolumeNumber', setReaderTextVolume);
                    bindVolumeInputs('readerBackgroundVolumeRange', 'readerBackgroundVolumeNumber', setReaderBackgroundVolume);

                    readerColorWheelSync.bg = initReaderColorWheelControl({
                        canvasId: 'readerBgColorWheel',
                        markerId: 'readerBgColorMarker',
                        previewId: 'readerBgColorPreview',
                        onPick: (hexColor) => setReaderBgColor(hexColor)
                    });

                    readerColorWheelSync.text = initReaderColorWheelControl({
                        canvasId: 'readerTextColorWheel',
                        markerId: 'readerTextColorMarker',
                        previewId: 'readerTextColorPreview',
                        onPick: (hexColor) => setReaderTextColor(hexColor)
                    });

                    const colorControls = {
                        bg: {
                            key: 'bg',
                            button: document.getElementById('readerBgColorToggleBtn'),
                            popover: document.getElementById('readerBgColorPickerPopover'),
                            sync: () => {
                                if (typeof readerColorWheelSync.bg === 'function') {
                                    readerColorWheelSync.bg(readerBgColor || getReaderFallbackBgColor());
                                }
                            }
                        },
                        text: {
                            key: 'text',
                            button: document.getElementById('readerTextColorToggleBtn'),
                            popover: document.getElementById('readerTextColorPickerPopover'),
                            sync: () => {
                                if (typeof readerColorWheelSync.text === 'function') {
                                    readerColorWheelSync.text(readerTextColor || getReaderFallbackTextColor());
                                }
                            }
                        }
                    };

                    const closeAllColorPopovers = () => {
                        Object.values(colorControls).forEach((control) => {
                            if (!control || !control.popover || !control.button) return;
                            control.popover.hidden = true;
                            control.button.setAttribute('aria-expanded', 'false');
                        });
                        readerColorPopoverState.activeKey = null;
                    };

                    const openColorPopover = (key) => {
                        const control = colorControls[key];
                        if (!control || !control.popover || !control.button) return;
                        closeAllColorPopovers();
                        control.popover.hidden = false;
                        control.button.setAttribute('aria-expanded', 'true');
                        control.sync();
                        readerColorPopoverState.activeKey = key;
                    };

                    Object.values(colorControls).forEach((control) => {
                        if (!control || !control.button || !control.popover) return;
                        control.button.addEventListener('click', (event) => {
                            event.preventDefault();
                            const shouldOpen = readerColorPopoverState.activeKey !== control.key;
                            if (shouldOpen) openColorPopover(control.key);
                            else closeAllColorPopovers();
                        });
                    });

                    document.addEventListener('click', (event) => {
                        if (!readerColorPopoverState.activeKey) return;
                        const activeControl = colorControls[readerColorPopoverState.activeKey];
                        if (!activeControl || !activeControl.button || !activeControl.popover) return;
                        const target = event.target;
                        if (activeControl.button.contains(target) || activeControl.popover.contains(target)) return;
                        closeAllColorPopovers();
                    });

                    document.addEventListener('keydown', (event) => {
                        if (event.key !== 'Escape') return;
                        if (!readerColorPopoverState.activeKey) return;
                        closeAllColorPopovers();
                    });

                    const resetColorsBtn = document.getElementById('readerColorResetBtn');
                    if (resetColorsBtn) {
                        resetColorsBtn.addEventListener('click', () => {
                            setReaderBgColor(null, { force: true });
                            setReaderTextColor(null, { force: true });
                        });
                    }

                    syncReaderSettingsUi();
                    applyReaderTextSettings({ rerender: false });
                }

                const globalVisualDimmer = window.GlobalVisualDimmer
                    ? window.GlobalVisualDimmer.init({
                        overlayId: 'sceneDimmerOverlay',
                        toggleButtonId: 'sceneDimmerToggleBtn',
                        iconFullId: 'sceneDimmerIconFull',
                        iconHalfId: 'sceneDimmerIconHalf',
                        iconCrescentId: 'sceneDimmerIconCrescent',
                        iconSunId: 'sceneDimmerIconSun'
                    })
                    : null;
                manualBackgroundDimLevel = globalVisualDimmer ? globalVisualDimmer.getLevel() : 0;
                window.visualFreezeActive = globalVisualDimmer ? globalVisualDimmer.isFrozen() : false;

                // --- GLOBAL GAME STATE ---
                // Locals aliasing globals
                // SharedAudioPlayer imported at top
                window.audioPlayer = new SharedAudioPlayer('assets/kapitel1b.mp3', 'assets/kapitel1b.txt', {
                    container: document.getElementById('subtitleContainer'),
                    volume: readerTextVolume,
                    isReadingMode: isReadingMode, // Pass initial state
                    canSeek: () => !contentSwitchInProgress,
                    onLineRender: (div, track) => {
                        // --- BOOKMARK BUTTON (mobile long-press / desktop right-click) ---
                        div.style.position = 'relative';
                        div.style.overflow = 'visible';
                        let _bmTimer = null;
                        let _bmTouchStart = null;
                        let _bmLastTouch = null;
                        let _bmLongPressReady = false;
                        let _bmDocTouchMoveHandler = null;
                        let _bmDocTouchEndHandler = null;
                        let _bmDocTouchCancelHandler = null;
                        const BOOKMARK_MAX_TOUCH_MOVE_PX = 200;
                        const BOOKMARK_LABEL = 'Lesezeichen';
                        const BOOKMARK_SAVED_LABEL = 'Gespeichert';
                        const isDesktopPointer = () => window.matchMedia('(hover: hover) and (pointer: fine)').matches;
                        const clampBookmarkCoord = (value, min, max) => Math.max(min, Math.min(max, value));
                        const rectOverlapArea = (x, y, width, height, rect) => {
                            const overlapW = Math.max(0, Math.min(x + width, rect.right) - Math.max(x, rect.left));
                            const overlapH = Math.max(0, Math.min(y + height, rect.bottom) - Math.max(y, rect.top));
                            return overlapW * overlapH;
                        };
                        const isFlatBookmarkLayout = () =>
                            subtitleContainer.classList.contains('reader-layout-flat')
                            || subtitleContainer.classList.contains('reader-layout-timestamps');
                        const setBookmarkButtonLabel = (btn, label) => {
                            if (!btn) return;
                            const labelNode = btn.querySelector('.bookmark-label');
                            if (labelNode) labelNode.textContent = label;
                            else btn.innerText = label;
                        };
                        const ensureBookmarkButtonMode = (btn, useFlatOverlay) => {
                            if (!btn) return;
                            if (useFlatOverlay) {
                                if (btn.dataset.flatOverlay !== '1') {
                                    btn.dataset.flatOverlay = '1';
                                    btn.innerHTML = '';
                                    const mapLayer = document.createElement('span');
                                    mapLayer.className = 'bookmark-map-layer';
                                    const mapCanvas = document.createElement('canvas');
                                    mapCanvas.className = 'bookmark-map-canvas';
                                    mapCanvas.setAttribute('aria-hidden', 'true');
                                    mapLayer.appendChild(mapCanvas);
                                    const overlayLayer = document.createElement('span');
                                    overlayLayer.className = 'bookmark-overlay-layer';
                                    const labelLayer = document.createElement('span');
                                    labelLayer.className = 'bookmark-label';
                                    labelLayer.textContent = BOOKMARK_LABEL;
                                    btn.appendChild(mapLayer);
                                    btn.appendChild(overlayLayer);
                                    btn.appendChild(labelLayer);
                                }
                                btn.classList.add('bookmark-btn-flat-overlay');
                            } else {
                                if (btn._flatMapRaf) {
                                    cancelAnimationFrame(btn._flatMapRaf);
                                    btn._flatMapRaf = 0;
                                }
                                btn._flatLockedX = null;
                                btn._flatLockedY = null;
                                btn.classList.remove('bookmark-btn-flat-overlay');
                                if (btn.dataset.flatOverlay === '1') {
                                    btn.dataset.flatOverlay = '0';
                                    btn.replaceChildren(document.createTextNode(BOOKMARK_LABEL));
                                }
                            }
                        };
                        const resolveSceneCanvas = () => {
                            if (typeof renderer !== 'undefined' && renderer && renderer.domElement instanceof HTMLCanvasElement) {
                                return renderer.domElement;
                            }
                            const gameCanvas = document.getElementById('gameCanvas');
                            if (gameCanvas instanceof HTMLCanvasElement) return gameCanvas;
                            const anyCanvas = document.querySelector('canvas');
                            return anyCanvas instanceof HTMLCanvasElement ? anyCanvas : null;
                        };
                        const drawFlatBookmarkMapLayer = (btn) => {
                            if (!btn || !btn.classList.contains('bookmark-btn-flat-overlay')) return;
                            const mapLayer = btn.querySelector('.bookmark-map-layer');
                            const mapCanvas = mapLayer ? mapLayer.querySelector('.bookmark-map-canvas') : null;
                            if (!(mapCanvas instanceof HTMLCanvasElement)) return;
                            const drawCtx = mapCanvas.getContext('2d');
                            if (!drawCtx) return;
                            if (!mapLayer) return;
                            const sceneCanvas = resolveSceneCanvas();
                            if (!sceneCanvas || typeof sceneCanvas.getBoundingClientRect !== 'function') {
                                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                                return;
                            }
                            try {
                                const canvasRect = sceneCanvas.getBoundingClientRect();
                                const btnRect = btn.getBoundingClientRect();
                                if (!canvasRect.width || !canvasRect.height || !btnRect.width || !btnRect.height) return;
                                const dpr = Math.max(1, window.devicePixelRatio || 1);
                                const targetW = Math.max(1, Math.round(btnRect.width * dpr));
                                const targetH = Math.max(1, Math.round(btnRect.height * dpr));
                                if (mapCanvas.width !== targetW || mapCanvas.height !== targetH) {
                                    mapCanvas.width = targetW;
                                    mapCanvas.height = targetH;
                                }
                                drawCtx.clearRect(0, 0, targetW, targetH);

                                const overlapLeft = Math.max(btnRect.left, canvasRect.left);
                                const overlapTop = Math.max(btnRect.top, canvasRect.top);
                                const overlapRight = Math.min(btnRect.right, canvasRect.right);
                                const overlapBottom = Math.min(btnRect.bottom, canvasRect.bottom);
                                if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) return;

                                const scaleX = sceneCanvas.width / canvasRect.width;
                                const scaleY = sceneCanvas.height / canvasRect.height;
                                const srcX = (overlapLeft - canvasRect.left) * scaleX;
                                const srcY = (overlapTop - canvasRect.top) * scaleY;
                                const srcW = (overlapRight - overlapLeft) * scaleX;
                                const srcH = (overlapBottom - overlapTop) * scaleY;
                                const dstX = (overlapLeft - btnRect.left) * dpr;
                                const dstY = (overlapTop - btnRect.top) * dpr;
                                const dstW = (overlapRight - overlapLeft) * dpr;
                                const dstH = (overlapBottom - overlapTop) * dpr;
                                drawCtx.drawImage(sceneCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
                            } catch (_) {
                                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                            }
                        };
                        const stopFlatBookmarkMapLayerLoop = (btn) => {
                            if (!btn || !btn._flatMapRaf) return;
                            cancelAnimationFrame(btn._flatMapRaf);
                            btn._flatMapRaf = 0;
                        };
                        const startFlatBookmarkMapLayerLoop = (btn) => {
                            if (!btn || btn._flatMapRaf) return;
                            const tick = () => {
                                if (!btn.isConnected || !btn.classList.contains('visible') || !btn.classList.contains('bookmark-btn-flat-overlay')) {
                                    btn._flatMapRaf = 0;
                                    return;
                                }
                                drawFlatBookmarkMapLayer(btn);
                                btn._flatMapRaf = requestAnimationFrame(tick);
                            };
                            tick();
                        };
                        const collectLineTextRects = (lineEl, containerRect) => {
                            const rects = [];
                            if (!lineEl) return rects;
                            for (const node of lineEl.childNodes) {
                                if (node.nodeType !== Node.TEXT_NODE) continue;
                                if (!(node.textContent || '').trim()) continue;
                                const range = document.createRange();
                                range.selectNodeContents(node);
                                for (const rect of range.getClientRects()) {
                                    if (rect.width <= 0 || rect.height <= 0) continue;
                                    if (rect.bottom < containerRect.top || rect.top > containerRect.bottom) continue;
                                    rects.push(rect);
                                }
                            }
                            return rects;
                        };
                        const collectSubtitleTextRects = () => {
                            const rects = [];
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            subtitleContainer.querySelectorAll('.subtitle-line').forEach((lineEl) => {
                                rects.push(...collectLineTextRects(lineEl, containerRect));
                            });
                            if (subtitleRecenterBtn && subtitleRecenterBtn.offsetParent !== null) {
                                const recenterRect = subtitleRecenterBtn.getBoundingClientRect();
                                if (recenterRect.width > 0 && recenterRect.height > 0) rects.push(recenterRect);
                            }
                            return { rects, containerRect };
                        };
                        const getPointerPoint = (event) => {
                            if (!event) return null;
                            if (event.touches && event.touches.length > 0) {
                                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
                            }
                            if (event.changedTouches && event.changedTouches.length > 0) {
                                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
                            }
                            if (event.clientX !== undefined && event.clientY !== undefined) {
                                return { clientX: event.clientX, clientY: event.clientY };
                            }
                            return null;
                        };
                        const clearLongPressTracking = () => {
                            if (_bmDocTouchMoveHandler) {
                                document.removeEventListener('touchmove', _bmDocTouchMoveHandler);
                                _bmDocTouchMoveHandler = null;
                            }
                            if (_bmDocTouchEndHandler) {
                                document.removeEventListener('touchend', _bmDocTouchEndHandler);
                                _bmDocTouchEndHandler = null;
                            }
                            if (_bmDocTouchCancelHandler) {
                                document.removeEventListener('touchcancel', _bmDocTouchCancelHandler);
                                _bmDocTouchCancelHandler = null;
                            }
                            _bmTouchStart = null;
                            _bmLastTouch = null;
                            _bmLongPressReady = false;
                        };
                        const getLongPressMovement = () => {
                            if (!_bmTouchStart) return { pointerDistance: 0, scrollDistance: 0 };
                            const lastPoint = _bmLastTouch || _bmTouchStart;
                            const dx = lastPoint.clientX - _bmTouchStart.clientX;
                            const dy = lastPoint.clientY - _bmTouchStart.clientY;
                            return {
                                pointerDistance: Math.hypot(dx, dy),
                                scrollDistance: Math.abs(subtitleContainer.scrollTop - _bmTouchStart.scrollTop)
                            };
                        };
                        const isLongPressBlockedByMovement = () => {
                            const movement = getLongPressMovement();
                            return movement.pointerDistance > BOOKMARK_MAX_TOUCH_MOVE_PX
                                || movement.scrollDistance > BOOKMARK_MAX_TOUCH_MOVE_PX;
                        };
                        const cancelLongPress = () => {
                            if (_bmTimer) {
                                clearTimeout(_bmTimer);
                                _bmTimer = null;
                            }
                            clearLongPressTracking();
                        };
                        const finalizeLongPress = () => {
                            if (!_bmTouchStart) {
                                cancelLongPress();
                                return;
                            }
                            const triggerPoint = _bmLastTouch || _bmTouchStart;
                            const shouldShow = _bmLongPressReady && !isLongPressBlockedByMovement();
                            cancelLongPress();
                            if (shouldShow) {
                                showBookmarkButton({ clientX: triggerPoint.clientX, clientY: triggerPoint.clientY });
                            }
                        };
                        const updateLongPressMovement = (event) => {
                            if (!_bmTouchStart) return;
                            const point = getPointerPoint(event);
                            if (!point) return;
                            _bmLastTouch = { clientX: point.clientX, clientY: point.clientY };
                            if (isLongPressBlockedByMovement()) {
                                cancelLongPress();
                            }
                        };
                        const positionBookmarkButton = (btn, options = {}) => {
                            const useFlatOverlay = isFlatBookmarkLayout();
                            ensureBookmarkButtonMode(btn, useFlatOverlay);
                            const lineRect = div.getBoundingClientRect();
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            if (!lineRect.width || !lineRect.height || !containerRect.width || !containerRect.height) return;
                            const btnWidth = btn.offsetWidth || 0;
                            const btnHeight = btn.offsetHeight || 0;

                            if (useFlatOverlay) {
                                const lockToExisting = !!options.lockToExisting;
                                if (lockToExisting && Number.isFinite(btn._flatLockedX) && Number.isFinite(btn._flatLockedY)) {
                                    btn.style.left = `${Math.round(btn._flatLockedX)}px`;
                                    btn.style.top = `${Math.round(btn._flatLockedY)}px`;
                                    startFlatBookmarkMapLayerLoop(btn);
                                    drawFlatBookmarkMapLayer(btn);
                                    return;
                                }
                                const lineTextRects = collectLineTextRects(div, containerRect);
                                const anchorRect = lineTextRects.length > 0 ? lineTextRects[0] : lineRect;
                                const edgeMargin = 6;
                                const x = clampBookmarkCoord(anchorRect.left, edgeMargin, Math.max(edgeMargin, window.innerWidth - btnWidth - edgeMargin));
                                const y = clampBookmarkCoord(anchorRect.top - btnHeight - 6, edgeMargin, Math.max(edgeMargin, window.innerHeight - btnHeight - edgeMargin));
                                btn._flatLockedX = Math.round(x);
                                btn._flatLockedY = Math.round(y);
                                btn.style.left = `${btn._flatLockedX}px`;
                                btn.style.top = `${btn._flatLockedY}px`;
                                startFlatBookmarkMapLayerLoop(btn);
                                drawFlatBookmarkMapLayer(btn);
                                return;
                            }

                            stopFlatBookmarkMapLayerLoop(btn);
                            btn._flatLockedX = null;
                            btn._flatLockedY = null;

                            // -- NEW POSITIONING LOGIC --
                            if (options.clientX !== undefined && options.clientY !== undefined && options.clientX !== null && options.clientY !== null) {
                                let x = options.clientX - (btnWidth / 2);
                                let y = options.clientY - 200; // 200px above

                                // Fallback if too close to top (<150px space) or offscreen
                                if (y < 150) {
                                    y = options.clientY + 200; // 200px below
                                }

                                // Prevent horizontal clipping
                                const margin = 8;
                                x = clampBookmarkCoord(x, containerRect.left + margin, containerRect.right - btnWidth - margin);

                                btn.style.left = `${Math.round(x - lineRect.left)}px`;
                                btn.style.top = `${Math.round(y - lineRect.top)}px`;
                                return;
                            }

                            // Fallback if no coordinates (shouldn't happen with updated showBookmarkButton)
                            const margin = 8;
                            const anchorRect = lineRect;
                            btn.style.left = `${Math.round(anchorRect.right + margin - lineRect.left)}px`;
                            btn.style.top = `${Math.round(anchorRect.top - lineRect.top)}px`;
                        };

                        const showBookmarkButton = (options = {}) => {
                            let btn = div.querySelector('.bookmark-btn');
                            if (!btn) {
                                btn = document.createElement('button');
                                btn.className = 'bookmark-btn';
                                setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                btn.addEventListener('click', async (ev) => {
                                    ev.stopPropagation();
                                    ev.preventDefault();
                                    btn.classList.remove('pop');
                                    void btn.offsetWidth;
                                    btn.classList.add('pop');
                                    setTimeout(() => btn.classList.remove('pop'), 220);
                                    const loreId = (isLoreMode && Number.isFinite(activeLoreId)) ? Number(activeLoreId) : null;
                                    const loreMeta = loreId && window.GameState && typeof window.GameState.getLore === 'function'
                                        ? window.GameState.getLore(loreId)
                                        : null;
                                    const bookmarkContentKey = loreId ? `lore${loreId}` : MAIN_CONTENT_KEY;
                                    const bookmarkChapter = loreId ? `lore${loreId}` : CURRENT_CHAPTER;
                                    const bookmarkChapterTitle = loreId
                                        ? (loreMeta && loreMeta.title ? `Lore ${loreId}: ${loreMeta.title}` : `Lore ${loreId}`)
                                        : CURRENT_CHAPTER_TITLE;
                                    const bookmarkAudioRef = loreId
                                        ? ((loreMeta && loreMeta.audio) || `assets/lore${loreId}.mp3`)
                                        : 'assets/kapitel1b.mp3';
                                    const bookmarkTextRef = loreId
                                        ? ((loreMeta && loreMeta.text) || `assets/lore${loreId}.txt`)
                                        : 'assets/kapitel1b.txt';
                                    const bm = {
                                        id: Date.now(),
                                        chapter: bookmarkChapter,
                                        chapterTitle: bookmarkChapterTitle,
                                        page: CURRENT_PAGE,
                                        time: track.time,
                                        textPreview: (track.text || '').substring(0, 60),
                                        contentKey: bookmarkContentKey,
                                        loreId: loreId,
                                        audioRef: bookmarkAudioRef,
                                        textRef: bookmarkTextRef,
                                        createdAt: Date.now()
                                    };
                                    if (window.GameState && window.GameState.addBookmark) {
                                        const added = await window.GameState.addBookmark(bm);
                                        if (added) {
                                            btn.classList.add('saved');
                                            setBookmarkButtonLabel(btn, BOOKMARK_SAVED_LABEL);
                                            positionBookmarkButton(btn, { lockToExisting: true, clientX: options.clientX, clientY: options.clientY });
                                            setTimeout(() => {
                                                btn.classList.remove('visible', 'saved');
                                                stopFlatBookmarkMapLayerLoop(btn);
                                                ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                                                setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                                btn._flatLockedX = null;
                                                btn._flatLockedY = null;
                                            }, 1200);
                                        } else {
                                            stopFlatBookmarkMapLayerLoop(btn);
                                            btn.classList.remove('visible');
                                        }
                                    }
                                });
                                div.appendChild(btn);
                            }
                            ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                            if (!btn.classList.contains('saved')) setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                            subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((otherBtn) => {
                                if (otherBtn !== btn) {
                                    otherBtn.classList.remove('visible');
                                    stopFlatBookmarkMapLayerLoop(otherBtn);
                                    otherBtn._flatLockedX = null;
                                    otherBtn._flatLockedY = null;
                                }
                            });
                            btn.classList.add('visible');
                            positionBookmarkButton(btn, { lockToExisting: false, clientX: options.clientX, clientY: options.clientY });
                            // Auto-hide after 4 seconds
                            setTimeout(() => {
                                if (!btn.classList.contains('saved')) {
                                    btn.classList.remove('visible');
                                    stopFlatBookmarkMapLayerLoop(btn);
                                    btn._flatLockedX = null;
                                    btn._flatLockedY = null;
                                }
                            }, 4000);
                        };

                        const startLongPress = (e) => {
                            if (isDesktopPointer()) return;
                            cancelLongPress();
                            const point = getPointerPoint(e);
                            if (!point) return;
                            _bmTouchStart = {
                                clientX: point.clientX,
                                clientY: point.clientY,
                                scrollTop: subtitleContainer.scrollTop
                            };
                            _bmLastTouch = { clientX: point.clientX, clientY: point.clientY };
                            _bmLongPressReady = false;
                            _bmDocTouchMoveHandler = (event) => updateLongPressMovement(event);
                            _bmDocTouchEndHandler = () => finalizeLongPress();
                            _bmDocTouchCancelHandler = () => cancelLongPress();
                            document.addEventListener('touchmove', _bmDocTouchMoveHandler, { passive: true });
                            document.addEventListener('touchend', _bmDocTouchEndHandler, { passive: true });
                            document.addEventListener('touchcancel', _bmDocTouchCancelHandler, { passive: true });

                            _bmTimer = setTimeout(() => {
                                _bmTimer = null;
                                if (!_bmTouchStart) return;
                                if (isLongPressBlockedByMovement()) {
                                    cancelLongPress();
                                    return;
                                }
                                _bmLongPressReady = true;
                            }, 600);
                        };
                        div.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            startLongPress(e);
                        });
                        div.addEventListener('contextmenu', (e) => {
                            if (!isDesktopPointer()) return;
                            e.preventDefault();
                            e.stopPropagation();
                            cancelLongPress();
                            showBookmarkButton({ clientX: e.clientX, clientY: e.clientY });
                        });
                        div.addEventListener('touchstart', startLongPress, { passive: true });
                        div.addEventListener('mouseup', cancelLongPress);
                        div.addEventListener('mouseleave', cancelLongPress);
                        div.addEventListener('touchend', finalizeLongPress);
                        div.addEventListener('touchcancel', cancelLongPress);
                    }
                });

                // --- BOOKMARK SEEK ON LOAD ---
                const bmTarget = sessionStorage.getItem('bookmark_seek_target');
                if (bmTarget) {
                    sessionStorage.removeItem('bookmark_seek_target');
                    try {
                        const target = JSON.parse(bmTarget);
                        const time = Number(target && target.time);
                        if (Number.isFinite(time) && time >= 0) {
                            console.log(`[Bookmark] Seeking to bookmarked time: ${time}s`);
                            setTimeout(async () => {
                                try {
                                    const targetPage = (target && typeof target.page === 'string' && target.page) ? target.page : CURRENT_PAGE;
                                    const targetContentKey = resolveBookmarkContentKey(target);
                                    const isLoreTarget = /^lore\d+$/i.test(targetContentKey);
                                    if (targetPage !== CURRENT_PAGE && !isLoreTarget) {
                                        console.warn('[Bookmark] Ignored stale on-load bookmark target for other page.', targetPage);
                                        return;
                                    }

                                    const ready = await ensureBookmarkContentForCurrentPage(target, 'bookmark:on-load');
                                    if (!ready) {
                                        console.warn('[Bookmark] Could not activate bookmark target content on load.', target);
                                        return;
                                    }

                                    if (window.audioPlayer && window.audioPlayer.seekToTime) {
                                        await window.audioPlayer.seekToTime(time, { autoplay: true });
                                    }
                                } catch (e) {
                                    console.warn('[Bookmark] Failed to apply on-load bookmark target:', e);
                                }
                            }, 1500); // Slightly longer delay for SharedAudioPlayer init
                        }
                    } catch (e) {
                        console.warn('[Bookmark] Failed to parse seek target:', e);
                    }
                }
                const player = window.audioPlayer;

                // Hook into SharedAudioPlayer's renderLines to sync the top fade mask
                const originalRenderLines = player.renderLines.bind(player);
                player.renderLines = function (centerIndex) {
                    const resolvedIndex = Number.isFinite(centerIndex)
                        ? centerIndex
                        : (Number.isFinite(player.currentSubtitleIndex) ? player.currentSubtitleIndex : 0);
                    const safeIndex = Math.max(0, resolvedIndex);
                    if (isReadingMode && readerSentenceLayout === READER_LAYOUT_BLAETTERN) {
                        renderBlaetternReadingPage(safeIndex);
                        return;
                    }
                    originalRenderLines(safeIndex);
                    syncReadingTopFadeMask(safeIndex);
                };
                initReaderSettingsControls();
                let subtitleFollowLocked = false;
                let suppressFollowLockUntil = 0;

                function updateRecenterButtonVisibility() {
                    if (!subtitleRecenterBtn) return;
                    const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
                    syncRecenterButtonMount(isMobileLayout);
                    const show = isReadingMode && subtitleFollowLocked;
                    if (!show) {
                        subtitleRecenterBtn.style.setProperty('display', 'none', 'important');
                        subtitleRecenterBtn.setAttribute('aria-hidden', 'true');
                        return;
                    }

                    subtitleRecenterBtn.style.setProperty('display', 'inline-flex', 'important');
                    subtitleRecenterBtn.setAttribute('aria-hidden', 'false');
                    requestAnimationFrame(positionRecenterButton);
                }

                function setSubtitleFollowLocked(nextLocked) {
                    subtitleFollowLocked = !!nextLocked;
                    if (!subtitleFollowLocked && isBlaetternLayoutActive()) {
                        blaetternLastSyncedSubtitleIndex = -1;
                    }
                    // SharedAudioPlayer checks this flag before auto-scroll.
                    subtitleContainer.dataset.isDragging = subtitleFollowLocked ? 'true' : 'false';
                    updateRecenterButtonVisibility();
                }

                function syncRecenterButtonMount(isMobileLayout = window.matchMedia('(max-width: 768px)').matches) {
                    if (!subtitleRecenterBtn) return;

                    if (isBlaetternLayoutActive()) {
                        if (subtitleRecenterBtn.parentElement !== document.body) {
                            document.body.appendChild(subtitleRecenterBtn);
                        }
                        subtitleRecenterBtn.style.position = 'fixed';
                        return;
                    }

                    if (isMobileLayout) {
                        if (subtitleRecenterBtn.parentElement !== document.body) {
                            // Mobile keeps viewport-fixed placement.
                            document.body.appendChild(subtitleRecenterBtn);
                        }
                        subtitleRecenterBtn.style.position = 'fixed';
                        return;
                    }

                    const desktopHost = document.getElementById('audioControls');
                    if (desktopHost) {
                        if (subtitleRecenterBtn.parentElement !== desktopHost) {
                            // Desktop: reuse the same flex flow as the existing control icons.
                            desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                        } else if (desktopHost.firstElementChild !== subtitleRecenterBtn) {
                            desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                        }
                    }
                    subtitleRecenterBtn.style.position = 'static';
                    subtitleRecenterBtn.style.left = '';
                    subtitleRecenterBtn.style.top = '';
                }

                function isMobileRecenterZoneActive() {
                    if (!subtitleRecenterBtn) return false;
                    if (!window.matchMedia('(max-width: 768px)').matches) return false;
                    const btnStyle = window.getComputedStyle(subtitleRecenterBtn);
                    return btnStyle.display !== 'none' && isReadingMode && subtitleFollowLocked;
                }

                function eventPointInMobileRecenterZone(e) {
                    if (!isMobileRecenterZoneActive()) return false;
                    if (!e) return false;

                    const point = Number.isFinite(e.clientX) && Number.isFinite(e.clientY)
                        ? { x: e.clientX, y: e.clientY }
                        : (e.changedTouches && e.changedTouches.length > 0
                            ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }
                            : (e.touches && e.touches.length > 0
                                ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
                                : null));
                    if (!point) return false;

                    const rect = subtitleRecenterBtn.getBoundingClientRect();
                    if (rect.width <= 0 || rect.height <= 0) return false;
                    const centerX = rect.left + (rect.width * 0.5);
                    const centerY = rect.top + (rect.height * 0.5);
                    const dx = point.x - centerX;
                    const dy = point.y - centerY;
                    return (dx * dx + dy * dy) <= (RECENTER_MOBILE_RADIUS_PX * RECENTER_MOBILE_RADIUS_PX);
                }

                function positionRecenterButton() {
                    if (!subtitleRecenterBtn || subtitleRecenterBtn.style.display === 'none') return;

                    const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
                    syncRecenterButtonMount(isMobileLayout);
                    const isBlaetternLayout = isBlaetternLayoutActive();
                    const btnRect = subtitleRecenterBtn.getBoundingClientRect();
                    const gap = 10;

                    if (isBlaetternLayout) {
                        const subtitleRect = subtitleContainer.getBoundingClientRect();
                        const controlsRect = audioControlsEl ? audioControlsEl.getBoundingClientRect() : null;
                        let left = subtitleRect.left + (subtitleRect.width - btnRect.width) * 0.5;
                        let top = subtitleRect.bottom - btnRect.height - gap;

                        if (controlsRect && controlsRect.top > 0) {
                            top = Math.min(top, controlsRect.top - btnRect.height - gap);
                        }

                        left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
                        top = Math.max(subtitleRect.top + 6, Math.min(window.innerHeight - btnRect.height - 6, top));
                        subtitleRecenterBtn.style.left = `${left}px`;
                        subtitleRecenterBtn.style.top = `${top}px`;
                        return;
                    }

                    if (!isMobileLayout) return;

                    const anchorRect = fullscreenBtn ? fullscreenBtn.getBoundingClientRect() : null;
                    if (!anchorRect) return;

                    let left = anchorRect.left + (anchorRect.width - btnRect.width) / 2;
                    let top = anchorRect.top - btnRect.height - gap;

                    if (isMobileLayout) {
                        const subtitleRect = subtitleContainer.getBoundingClientRect();
                        const targetCenterY = subtitleRect.top + subtitleRect.height * 0.5;
                        top = targetCenterY - btnRect.height * 0.5;
                    }

                    left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
                    top = Math.max(6, Math.min(window.innerHeight - btnRect.height - 6, top));

                    subtitleRecenterBtn.style.left = `${left}px`;
                    subtitleRecenterBtn.style.top = `${top}px`;
                }

                function recenterToCurrentTimestamp() {
                    const tracks = getActiveSubtitleTracks();
                    if (!tracks || tracks.length === 0) {
                        setSubtitleFollowLocked(false);
                        return;
                    }

                    const fallbackIndex = findSubtitleIndexForTime(player.currentTime || 0);
                    const safeIndex = Math.max(
                        0,
                        Math.min(
                            tracks.length - 1,
                            Number.isFinite(player.currentSubtitleIndex) && player.currentSubtitleIndex >= 0
                                ? player.currentSubtitleIndex
                                : fallbackIndex
                        )
                    );

                    setSubtitleFollowLocked(false);
                    suppressFollowLockUntil = Date.now() + 450;
                    isDown = false;
                    subtitleContainer.dataset.isDragging = 'false';
                    subtitleContainer.dataset.wasDragging = 'false';
                    player.currentSubtitleIndex = safeIndex;
                    if (isBlaetternLayoutActive()) blaetternLastSyncedSubtitleIndex = -1;
                    player.renderLines(safeIndex);

                    if (isBlaetternLayoutActive()) {
                        bumpBlaetternControlsAutoHide('blaettern-recenter');
                        return;
                    }

                    const activeEl = subtitleContainer.children[safeIndex];
                    if (activeEl && typeof player.smoothScrollTo === 'function') {
                        player.smoothScrollTo(activeEl);
                    }
                }

                let lastRecenterActivationAt = 0;
                let suppressSubtitleClickUntil = 0;
                function handleRecenterActivate(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    const now = Date.now();
                    if (now - lastRecenterActivationAt < 260) return;
                    lastRecenterActivationAt = now;
                    // Avoid delayed mobile ghost clicks hitting subtitle lines after recenter tap.
                    const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
                    suppressSubtitleClickUntil = isMobileLayout ? now + 600 : now;
                    recenterToCurrentTimestamp();
                }

                if (subtitleRecenterBtn) {
                    subtitleRecenterBtn.addEventListener('pointerdown', handleRecenterActivate);
                    subtitleRecenterBtn.addEventListener('touchstart', handleRecenterActivate, { passive: false });
                    subtitleRecenterBtn.addEventListener('click', handleRecenterActivate);
                }

                window.addEventListener('resize', () => {
                    positionRecenterButton();
                    markBlaetternPaginationDirty();
                    if (isBlaetternLayoutActive()) {
                        const idx = Number.isFinite(player.currentSubtitleIndex) ? player.currentSubtitleIndex : 0;
                        player.renderLines(Math.max(0, idx));
                    }
                });
                window.addEventListener('orientationchange', () => {
                    positionRecenterButton();
                    markBlaetternPaginationDirty();
                    if (isBlaetternLayoutActive()) {
                        const idx = Number.isFinite(player.currentSubtitleIndex) ? player.currentSubtitleIndex : 0;
                        player.renderLines(Math.max(0, idx));
                    }
                });

                subtitleContainer.addEventListener('click', (e) => {
                    const subtitleLine = e.target && e.target.closest ? e.target.closest('.subtitle-line') : null;
                    if (!subtitleLine) return;
                    if (contentSwitchInProgress) {
                        liminalTrace('ui:subtitle-click:blocked', { reason: 'contentSwitchInProgress' });
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                        return;
                    }
                    if (eventPointInMobileRecenterZone(e)) {
                        liminalTrace('ui:subtitle-click:blocked', { reason: 'mobileRecenterZone' });
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                        handleRecenterActivate(e);
                        return;
                    }
                    if (Date.now() < suppressSubtitleClickUntil) {
                        liminalTrace('ui:subtitle-click:blocked', { reason: 'suppressSubtitleClickUntil' });
                        e.preventDefault();
                        e.stopPropagation();
                        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
                        return;
                    }
                    liminalTrace('ui:subtitle-click:ok');
                    setSubtitleFollowLocked(false);
                }, true);

                // PRELOAD IMMEDIATELY - WRAPPED
                try {
                    if (window.audioPlayer && window.audioPlayer.audio) {
                        window.audioPlayer.audio.preload = "auto";
                        // window.audioPlayer.audio.load(); 
                        console.log("Liminal Audio Preloading...");
                    }
                } catch (e) { console.warn("Liminal Preload Failed", e); }

                // Initialize Game
                (async () => {
                    try {
                        // 2. Load Audio State
                        const savedState = PlayerStateManager.getState('liminal_library');
                        if (savedState && savedState.sentenceTime > 0) {
                            player.audio.currentTime = savedState.sentenceTime;
                        }

                        // 3. Init Visibility Manage - DISABLED (Bug suspected)
                        // AudioVisibilityManager.init(player.audio);

                    } catch (e) {
                        console.error("Game Init Error:", e);
                    }
                })();

                // --- UI HELPERS ---
                function updateReadingModeUI() {
                    if (!isReadingMode && globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                        isReadingMode = true;
                    }

                    // Sync with Shared Player
                    if (window.audioPlayer && typeof window.audioPlayer.setReadingMode === 'function') {
                        window.audioPlayer.setReadingMode(isReadingMode);
                    }

                    if (isReadingMode) {
                        uiContainer.classList.add('reading-mode');
                        localStorage.setItem('gameboy_reading_mode', 'true');
                        isCenteringCamera = true;
                    } else {
                        clearBlaetternPaginationRetryTimer();
                        setSubtitleFollowLocked(false);
                        uiContainer.classList.remove('reading-mode');
                        localStorage.setItem('gameboy_reading_mode', 'false');
                    }

                    if (modeToggleBtn) {
                        const nextModeLabel = isReadingMode ? 'Spielmodus aktivieren' : 'Lesemodus aktivieren';
                        modeToggleBtn.title = nextModeLabel;
                        modeToggleBtn.setAttribute('aria-label', nextModeLabel);
                    }
                    markBlaetternPaginationDirty();
                    syncBlaetternUiState(`mode-switch:${isReadingMode ? 'reading' : 'game'}`);
                    if (window.audioPlayer && typeof window.audioPlayer.renderLines === 'function') {
                        const idx = Number.isFinite(window.audioPlayer.currentSubtitleIndex)
                            ? window.audioPlayer.currentSubtitleIndex
                            : 0;
                        window.audioPlayer.renderLines(Math.max(0, idx));
                    }
                    updateRecenterButtonVisibility();
                }

                function isPlayerTransportPaused() {
                    if (!player || !player.audio) return true;
                    if (typeof player.audio.isTransportPaused === 'function') {
                        return player.audio.isTransportPaused();
                    }
                    return !!player.paused;
                }

                // --- EVENT LISTENERS ---
                async function handleAudioToggleClick() {
                    if (contentSwitchInProgress) {
                        liminalTrace('ui:play-toggle:blocked', { reason: 'contentSwitchInProgress' });
                        return;
                    }
                    const wantsPlay = isPlayerTransportPaused();
                    liminalTrace('ui:play-toggle:click', {
                        wantsPlay,
                        paused: !!player.paused,
                        transportPaused: isPlayerTransportPaused(),
                        iconPlay: iconPlay.style.display,
                        iconPause: iconPause.style.display
                    });
                    if (wantsPlay) {
                        iconPlay.style.display = 'none';
                        iconPause.style.display = 'block';
                        try {
                            await player.play();
                            liminalTrace('ui:play-toggle:play-called');
                        } catch (e) {
                            liminalDebugNote('toggle-error', e && e.message ? e.message : String(e));
                            liminalTrace('ui:play-toggle:play-error', { message: e && e.message ? e.message : String(e) });
                        }
                        setTimeout(updateIcons, 120);
                    } else {
                        player.pause();
                        liminalTrace('ui:play-toggle:pause-called');
                        updateIcons();
                    }
                }

                document.getElementById('audioToggleBtn').addEventListener('click', () => {
                    handleAudioToggleClick();
                });

                document.getElementById('skipBackBtn').addEventListener('click', () => {
                    if (contentSwitchInProgress) return;
                    markUiInteraction('btn:skip-back');
                    skipBySecondsInLiminal(-15);
                });
                document.getElementById('skipForwardBtn').addEventListener('click', () => {
                    if (contentSwitchInProgress) return;
                    markUiInteraction('btn:skip-forward');
                    skipBySecondsInLiminal(15);
                });

                modeToggleBtn.addEventListener('click', () => {
                    // In frozen mode: reset dimmer to off + switch to game mode
                    if (globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                        globalVisualDimmer.setLevel(0, { forceEmit: true });
                        isReadingMode = false;
                    } else {
                        isReadingMode = !isReadingMode;
                    }
                    updateReadingModeUI();
                    markUiInteraction(isReadingMode ? 'btn:reading-mode' : 'btn:game-mode');
                });

                document.querySelectorAll('#audioControls button, #nextChapterBtn, #chapterMenu .menu-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const name = el.id || el.className || 'ui';
                        liminalDebugNote('ui-click', String(name));
                    });
                });

                if (audioControlsEl) {
                    audioControlsEl.addEventListener('pointerdown', () => {
                        if (isBlaetternLayoutActive()) bumpBlaetternControlsAutoHide('controls-pointerdown');
                    });
                    audioControlsEl.addEventListener('click', () => {
                        if (isBlaetternLayoutActive()) bumpBlaetternControlsAutoHide('controls-click');
                    });
                }

                // Auto-Resume when Lore ends or Transition
                // SharedAudioPlayer ruft this.onEnded() auf wenn Audio endet.
                // Zustzlich addEventListener als Fallback falls SCAudioAdapter DOM-Events feuert.
                let _endedHandled = false;
                function handleAudioEnded() {
                    if (_endedHandled) return;
                    _endedHandled = true;
                    setTimeout(() => { _endedHandled = false; }, 500);

                    if (isLoreMode) {
                        liminalDebugNote('audio-ended', 'lore -> restore main');
                        liminalTrace('audio:ended:lore');
                        window.restoreMainAudio({ saveCurrent: false });
                        return;
                    }

                    // MAIN CHAPTER ENDED
                    // NOTE: SCAudioAdapter kann currentTime nach 'ended' auf 0 zurcksetzen,
                    // daher isCurrentContentCompleted() NICHT verwenden (reachedAudioEnd wrde false liefern).
                    const tracks = getActiveSubtitleTracks();
                    const subtitleIdx = getActiveSubtitleIndex();
                    const textFinished = tracks.length === 0 || subtitleIdx >= tracks.length - 1;
                    liminalDebugNote('audio-ended', `main idx=${subtitleIdx}/${tracks.length} textFinished=${textFinished} reading=${isReadingMode}`);
                    liminalTrace('audio:ended:main', {
                        textFinished: !!textFinished,
                        subtitleIndex: subtitleIdx,
                        subtitleCount: tracks.length,
                        readingMode: !!isReadingMode
                    });

                    clearContentState(MAIN_CONTENT_KEY);

                    if (isReadingMode) {
                        transitionToNextChapter();
                    } else {
                        const btn = document.getElementById('nextChapterBtn');
                        if (btn) btn.classList.add('visible');
                    }
                }
                // Primr: SharedAudioPlayer.onEnded (garantiert aufgerufen)
                player.onEnded = handleAudioEnded;
                // Fallback: DOM-Event auf dem Audio-Element
                player.audio.addEventListener('ended', handleAudioEnded);

                // Global Transition Logic
                window.transitionToNextChapter = async function () {
                    const overlay = document.getElementById('transitionOverlay');
                    if (overlay) overlay.classList.add('active');
                    await waitForContentSwitchIdle('transition:next-chapter');
                    await saveCurrentContentState({ reason: 'transition:next-chapter' });

                    // Mark autoplay intent so the next chapter auto-plays in reading mode
                    const targetPageKey = 'kapitel1c';
                    markChapterAutoplayIntent(targetPageKey, 'auto', 'chapter-transition');
                    writeStateHandoff(targetPageKey);

                    // Fade Audio
                    const fade = setInterval(() => {
                        if (player.volume > 0.05) player.volume -= 0.05;
                        else { clearInterval(fade); player.pause(); }
                    }, 100);

                    setTimeout(() => {
                        // Transition to Chapter 1c (Steingasse)
                        window.location.href = 'index.html?chapter=kapitel1c';
                    }, 2000);
                };

                const nextBtn = document.getElementById('nextChapterBtn');
                if (nextBtn) nextBtn.addEventListener('click', () => {
                    nextBtn.classList.remove('visible');
                    transitionToNextChapter();
                });

                // RESTORE READING MODE STATE - MOVED TO TOP (Line 196)
                // ALWAYS update UI to sync player state
                updateReadingModeUI();

                // --- DRAG TO SCROLL LOGIC ---

                // SMART MASK LOGIC (Opacity on scroll)
                subtitleContainer.addEventListener('scroll', () => {
                    if (subtitleContainer.scrollTop > 10) {
                        subtitleContainer.classList.add('scrolled-state');
                    } else {
                        subtitleContainer.classList.remove('scrolled-state');
                    }
                });

                let isDown = false;
                let startY;
                let scrollTop;
                let lastMoveY = 0;
                let lastMoveTime = 0;
                let swipeVelocity = 0;
                let momentumAnimId = null;

                function cancelMomentum() {
                    if (momentumAnimId) {
                        cancelAnimationFrame(momentumAnimId);
                        momentumAnimId = null;
                    }
                }

                const handleDown = (e) => {
                    if (isBlaetternLayoutActive()) return;
                    cancelMomentum();
                    isDown = true;
                    subtitleContainer.dataset.isDragging = 'false';
                    subtitleContainer.dataset.wasDragging = 'false';
                    const pageY = e.pageY || e.touches[0].pageY;
                    startY = pageY - subtitleContainer.offsetTop;
                    scrollTop = subtitleContainer.scrollTop;
                    lastMoveY = pageY;
                    lastMoveTime = performance.now();
                    swipeVelocity = 0;
                    subtitleContainer.style.cursor = 'grabbing';
                };

                const handleMove = (e) => {
                    if (isBlaetternLayoutActive()) return;
                    if (!isDown) return;
                    e.preventDefault();
                    const pageY = e.pageY || e.touches[0].pageY;
                    const y = pageY - subtitleContainer.offsetTop;
                    const walk = (y - startY) * 1.0;

                    // Track velocity for momentum
                    const now = performance.now();
                    const elapsed = now - lastMoveTime;
                    if (elapsed > 0) {
                        const instantVelocity = (pageY - lastMoveY) / elapsed;
                        swipeVelocity = swipeVelocity * 0.6 + instantVelocity * 0.4;
                    }
                    lastMoveY = pageY;
                    lastMoveTime = now;

                    if (Math.abs(walk) > 5) {
                        subtitleContainer.dataset.isDragging = 'true';
                        subtitleContainer.dataset.wasDragging = 'true';
                        if (isReadingMode && Date.now() >= suppressFollowLockUntil) {
                            setSubtitleFollowLocked(true);
                        }
                        subtitleContainer.scrollTop = scrollTop - walk;
                    }
                };

                const handleUp = () => {
                    if (isBlaetternLayoutActive()) return;
                    isDown = false;
                    subtitleContainer.dataset.isDragging = subtitleFollowLocked ? 'true' : 'false';
                    subtitleContainer.style.cursor = 'auto';

                    // Start momentum animation if velocity is significant
                    const velocityPxPerMs = swipeVelocity;
                    let velocityPxPerSec = -velocityPxPerMs * 1000 * 1.2; // Moderate amplify
                    const MAX_VELOCITY = 5000;
                    const MIN_VELOCITY = 15;
                    velocityPxPerSec = Math.max(-MAX_VELOCITY, Math.min(MAX_VELOCITY, velocityPxPerSec));

                    if (Math.abs(velocityPxPerSec) > MIN_VELOCITY) {
                        let lastFrame = performance.now();
                        const animateMomentum = (now) => {
                            const dt = (now - lastFrame) / 1000;
                            lastFrame = now;

                            subtitleContainer.scrollTop += velocityPxPerSec * dt;
                            velocityPxPerSec *= Math.pow(0.96, dt * 60); // Gentler friction for longer coast

                            if (Math.abs(velocityPxPerSec) < 0.5) {
                                momentumAnimId = null;
                                return;
                            }

                            momentumAnimId = requestAnimationFrame(animateMomentum);
                        };
                        momentumAnimId = requestAnimationFrame(animateMomentum);
                    }
                };

                subtitleContainer.addEventListener('mousedown', handleDown);
                subtitleContainer.addEventListener('touchstart', handleDown, { passive: true });
                subtitleContainer.addEventListener('mouseleave', handleUp);
                subtitleContainer.addEventListener('mouseup', handleUp);
                subtitleContainer.addEventListener('touchend', handleUp);
                subtitleContainer.addEventListener('touchcancel', handleUp);
                subtitleContainer.addEventListener('mousemove', handleMove);
                subtitleContainer.addEventListener('touchmove', handleMove, { passive: false });
                subtitleContainer.addEventListener('pointerdown', onBlaetternPointerDown);
                subtitleContainer.addEventListener('pointermove', onBlaetternPointerMove);
                subtitleContainer.addEventListener('pointerup', onBlaetternPointerEnd);
                subtitleContainer.addEventListener('pointercancel', onBlaetternPointerEnd);



                function updateIcons() {
                    const transportPaused = isPlayerTransportPaused();
                    if (transportPaused) {
                        iconPlay.style.display = 'block'; iconPause.style.display = 'none';
                    } else {
                        iconPlay.style.display = 'none'; iconPause.style.display = 'block';
                    }
                    liminalTrace('icon:sync', {
                        paused: !!player.paused,
                        transportPaused,
                        iconPlay: iconPlay.style.display,
                        iconPause: iconPause.style.display,
                        currentTime: Number(((player && player.currentTime) || 0).toFixed(3))
                    });
                }
                player.audio.addEventListener('play', updateIcons);
                player.audio.addEventListener('pause', updateIcons);
                player.audio.addEventListener('ended', updateIcons);
                player.audio.addEventListener('loadedmetadata', updateIcons);
                updateIcons();

                // --- FULLSCREEN LOGIC ---
                const iconFsEnter = document.getElementById('iconFsEnter');
                const iconFsExit = document.getElementById('iconFsExit');
                function getFullscreenElementSafe() {
                    return document.fullscreenElement || document.webkitFullscreenElement || null;
                }

                function isFullscreenSupported() {
                    const root = document.documentElement;
                    return !!(
                        document.fullscreenEnabled ||
                        document.webkitFullscreenEnabled ||
                        root.requestFullscreen ||
                        root.webkitRequestFullscreen
                    );
                }

                function requestFullscreenSafe() {
                    const root = document.documentElement;
                    if (root.requestFullscreen) return root.requestFullscreen();
                    if (root.webkitRequestFullscreen) return Promise.resolve(root.webkitRequestFullscreen());
                    return Promise.reject(new Error('Fullscreen API not supported'));
                }

                function exitFullscreenSafe() {
                    if (document.exitFullscreen) return document.exitFullscreen();
                    if (document.webkitExitFullscreen) return Promise.resolve(document.webkitExitFullscreen());
                    return Promise.resolve();
                }

                function syncFullscreenUi() {
                    if (getFullscreenElementSafe()) {
                        iconFsEnter.style.display = 'none';
                        iconFsExit.style.display = 'block';
                    } else {
                        iconFsEnter.style.display = 'block';
                        iconFsExit.style.display = 'none';
                    }
                    positionRecenterButton();
                }

                fullscreenBtn.addEventListener('click', async () => {
                    if (!isFullscreenSupported()) {
                        console.warn('[Fullscreen] Not supported on this device.');
                        syncFullscreenUi();
                        return;
                    }

                    try {
                        if (!getFullscreenElementSafe()) {
                            await requestFullscreenSafe();
                        } else {
                            await exitFullscreenSafe();
                        }
                    } catch (err) {
                        console.warn(`Error attempting to toggle fullscreen: ${err && err.message ? err.message : err}`);
                    } finally {
                        syncFullscreenUi();
                    }
                });

                document.addEventListener('fullscreenchange', syncFullscreenUi);
                document.addEventListener('webkitfullscreenchange', syncFullscreenUi);
                document.addEventListener('fullscreenerror', syncFullscreenUi);
                document.addEventListener('webkitfullscreenerror', syncFullscreenUi);

                // --- FREE LOOK CONTROLS ---
                const mouse = { x: 0, y: 0 };
                let targetMouseX = 0; // Target look direction (screen X normalized)
                let targetMouseY = 0; // Target look direction (screen Y normalized)
                let isLookingAtClickTarget = false; // True when camera should rotate toward click
                // let isCenteringCamera = false; // Moved to global scope

                function syncLookTargetsToCamera() {
                    if (!camera || !camera.quaternion) return;
                    euler.setFromQuaternion(camera.quaternion);
                    mouse.x = Math.max(-1, Math.min(1, -euler.y / 1.5));
                    mouse.y = Math.max(-1, Math.min(1, -euler.x / 0.5));
                    targetMouseX = mouse.x;
                    targetMouseY = mouse.y;
                }

                // Desktop: Mouse move controls camera look
                document.addEventListener('mousemove', (event) => {
                    // Disabled in reading mode
                    if (player && player.isReadingMode) return;

                    // DISABLED when camera is panning to a click target
                    if (cameraLookTarget) return;

                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = (event.clientY / window.innerHeight) * 2 - 1;
                    targetMouseX = mouse.x;
                    targetMouseY = mouse.y;
                });

                // --- MOBILE TOUCH CONTROLS ---
                let touchStartX = 0;
                let touchStartY = 0;
                let touchStartMouseX = 0;
                let touchStartMouseY = 0;
                let isTouchDragging = false;
                let isTouchValid = true; // FIX: Default true so clicks work from start
                let touchMovedForTap = false;
                let touchStartedOnUi = false;

                // Helper: Check if touch is on UI elements
                function isTouchOnUI(event) {
                    const target = event && event.target;
                    const el = target && target.nodeType === 1
                        ? target
                        : (target && target.parentElement ? target.parentElement : null);
                    if (!el || typeof el.closest !== 'function') return false;
                    const subtitleHit = !!el.closest('#subtitleContainer');
                    return !!(
                        el.closest('#audioControls') ||
                        el.closest('.audio-btn') ||
                        el.closest('#archiveModal') ||
                        el.closest('.menu-item') ||
                        (isReadingMode && subtitleHit) ||
                        el.closest('#nextChapterBtn') ||
                        el.closest('#loading')
                    );
                }

                document.addEventListener('touchstart', (event) => {
                    // Disabled in reading mode
                    if (player && player.isReadingMode) return;

                    if (!isTouchValid && performance.now() - lastUiInteractionAt > 1200) {
                        liminalCause('C08_TOUCHFLAGS_STUCK', `touchstart with stale invalid flag (${(performance.now() - lastUiInteractionAt).toFixed(0)}ms)`);
                    }

                    if (event.touches.length !== 1) {
                        isTouchValid = false;
                        isTouchDragging = false;
                        liminalDebugNote('touchstart-skip', `multi-touch:${event.touches.length}`);
                        return;
                    }

                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        const startedInDeadzone = touch.clientY >= getUiDeadzoneTop();
                        const worldLockReason = getWorldInputLockReason();

                        // PERFORMANCE FIX: Check UI collision ONCE at start
                        if (worldLockReason) {
                            isTouchValid = false;
                            touchStartedOnUi = true;
                            markUiInteraction(`touchstart-world-lock:${worldLockReason}`);
                            liminalCause('C04_WORLD_BLOCKED_TOUCH', `touchstart-world-lock:${worldLockReason}`);
                            return;
                        }
                        if (isTouchOnUI(event) || startedInDeadzone) {
                            isTouchValid = false;
                            touchStartedOnUi = true;
                            markUiInteraction(startedInDeadzone ? 'touchstart-deadzone' : 'touchstart-ui');
                            return;
                        }

                        const touchedEl = document.elementFromPoint(touch.clientX, touch.clientY);
                        const startedOnRenderer = isRendererElement(event.target) || isRendererElement(touchedEl);
                        if (!startedOnRenderer) {
                            isTouchValid = false;
                            touchStartedOnUi = true;
                            markUiInteraction('touchstart-not-renderer');
                            liminalCause('C04_WORLD_BLOCKED_TOUCH', 'touchstart-not-renderer');
                            return;
                        }

                        isTouchValid = true;
                        touchStartedOnRenderer = true;

                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        touchStartMouseX = mouse.x;
                        touchStartMouseY = mouse.y;
                        isTouchDragging = false;
                    }
                }, { passive: true });

                document.addEventListener('touchmove', (event) => {
                    // Disabled in reading mode
                    if (player && player.isReadingMode) return;

                    // Optimization: Early exit if touch started on UI
                    if (!isTouchValid) return;
                    if (event.touches.length !== 1) return;

                    if (event.touches.length === 1) {
                        const touch = event.touches[0];

                        const deltaX = touch.clientX - touchStartX;
                        const deltaY = touch.clientY - touchStartY;

                        // Only treat as drag if moved more than 10 pixels
                        if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                            isTouchDragging = true;
                            touchMovedForTap = true;

                            // CANCEL any auto-pan when user swipes
                            cameraLookTarget = null;

                            // Swipe-to-look: Map drag delta to mouse position (INVERTED)
                            const sensitivity = 0.004;
                            mouse.x = Math.max(-1, Math.min(1, touchStartMouseX - deltaX * sensitivity));
                            mouse.y = Math.max(-1, Math.min(1, touchStartMouseY - deltaY * sensitivity));
                            targetMouseX = mouse.x;
                            targetMouseY = mouse.y;
                        }
                    }
                }, { passive: true });

                // Prevent pinch-zoom from desynchronizing viewport/camera calibration.
                document.addEventListener('touchmove', (event) => {
                    if (event.touches && event.touches.length > 1) event.preventDefault();
                }, { passive: false });

                // --- TEXTURES & MATERIALS ---
                function createWoodTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#2a1a10';
                    ctx.fillRect(0, 0, 512, 512);
                    for (let i = 0; i < 100; i++) {
                        ctx.strokeStyle = `rgba(0,0,0, ${Math.random() * 0.2})`; ctx.lineWidth = Math.random() * 3;
                        ctx.beginPath(); ctx.moveTo(Math.random() * 512, 0); ctx.lineTo(Math.random() * 512, 512); ctx.stroke();
                    }
                    return new THREE.CanvasTexture(canvas);
                }
                function createCarpetTexture() {
                    const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 512, 512);
                    const imgData = ctx.getImageData(0, 0, 512, 512);
                    for (let i = 0; i < imgData.data.length; i += 4) {
                        const noise = (Math.random() - 0.5) * 15; imgData.data[i] += noise + 10;
                        imgData.data[i + 1] += noise + 10; imgData.data[i + 2] += noise + 10;
                    }
                    ctx.putImageData(imgData, 0, 0);
                    const t = new THREE.CanvasTexture(canvas); t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(4, 10); return t;
                }
                let woodMaterial, floorMaterial, wallMaterial, bookMat, bulbMat, cordMat;
                let sharedPlaneGeo, sharedShelfGeo, sharedPlankGeo, sharedBookGeo, sharedBulbGeo, sharedCordGeo;
                let sharedShelfGeoLeft, sharedShelfGeoRight;
                let sharedPlankGeoLeft, sharedPlankGeoRight;

                if (!window.fallback2DMode && THREE) {
                    woodMaterial = new THREE.MeshStandardMaterial({ map: createWoodTexture(), roughness: 0.8, color: 0x5c4033 });
                    floorMaterial = new THREE.MeshStandardMaterial({ map: createCarpetTexture(), roughness: 0.9, metalness: 0.1 });
                    wallMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
                    bookMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 });
                    bulbMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    cordMat = new THREE.MeshBasicMaterial({ color: 0x111 });

                    // variables declared in outer scope

                    // --- SHARED GEOMETRIES (Performance Fix) ---
                    sharedPlaneGeo = new THREE.PlaneGeometry(config.roomWidth, config.segmentLength);

                    sharedShelfGeoLeft = new THREE.BoxGeometry(config.shelfDepth, config.roomHeight, config.segmentLength);
                    sharedShelfGeoRight = new THREE.BoxGeometry(config.shelfDepth, config.roomHeight, config.segmentLength);

                    sharedPlankGeoLeft = new THREE.BoxGeometry(1.2, 0.05, config.segmentLength);
                    sharedPlankGeoRight = new THREE.BoxGeometry(1.2, 0.05, config.segmentLength);

                    // --- EXPLICIT SHELF CULLING (Keep ONLY inward-facing wall) ---
                    try {
                        const idxL = sharedShelfGeoLeft.index.array;
                        const newL = [];
                        for (let i = 0; i < 6; i++) newL.push(idxL[i]); // Keep +X (Right) face for Left Wall
                        sharedShelfGeoLeft.setIndex(newL); sharedShelfGeoLeft.clearGroups();

                        const idxR = sharedShelfGeoRight.index.array;
                        const newR = [];
                        for (let i = 6; i < 12; i++) newR.push(idxR[i]); // Keep -X (Left) face for Right Wall
                        sharedShelfGeoRight.setIndex(newR); sharedShelfGeoRight.clearGroups();
                    } catch (e) { }

                    // --- EXPLICIT PLANK CULLING (Keep Front Edge, Top, Bottom) ---
                    try {
                        const idxPL = sharedPlankGeoLeft.index.array;
                        const newPL = [];
                        for (let i = 0; i < 6; i++) newPL.push(idxPL[i]);   // Keep +X (Right edge) 
                        for (let i = 12; i < 24; i++) newPL.push(idxPL[i]); // Keep +Y (Top), -Y (Bottom)
                        sharedPlankGeoLeft.setIndex(newPL); sharedPlankGeoLeft.clearGroups();

                        const idxPR = sharedPlankGeoRight.index.array;
                        const newPR = [];
                        for (let i = 6; i < 12; i++) newPR.push(idxPR[i]);  // Keep -X (Left edge)
                        for (let i = 12; i < 24; i++) newPR.push(idxPR[i]); // Keep +Y (Top), -Y (Bottom)
                        sharedPlankGeoRight.setIndex(newPR); sharedPlankGeoRight.clearGroups();
                    } catch (e) { }

                    sharedBookGeo = new THREE.BoxGeometry(1, 1, 1);

                    // --- GLOBAL BOOK GEOMETRY REDUCTION (6 faces -> 2 faces) ---
                    // By keeping only the spine (+X, indices 0-5) and the front cover (+Z, indices 24-29)
                    // we save 66% of geometry rendering overhead per book for ALL devices.
                    try {
                        const oldIdx = sharedBookGeo.index.array;
                        const newIdx = [];
                        for (let i = 0; i < 6; i++) newIdx.push(oldIdx[i]);
                        for (let i = 24; i < 30; i++) newIdx.push(oldIdx[i]);
                        sharedBookGeo.setIndex(newIdx);
                        sharedBookGeo.clearGroups();
                    } catch (e) {
                        console.warn("Global book geometry reduction failed:", e);
                    }

                    sharedBulbGeo = new THREE.SphereGeometry(0.1, 16, 16);
                    sharedCordGeo = new THREE.CylinderGeometry(0.01, 0.01, 3);
                }

                // --- CLASSES ---
                class YellowLight {
                    constructor(zPos) {
                        this.position = new THREE.Vector3(0, 3.5, zPos);
                        this.group = new THREE.Group();
                        this.group.position.copy(this.position);
                        const bulb = new THREE.Mesh(sharedBulbGeo, bulbMat);
                        this.group.add(bulb);
                        this.light = new THREE.PointLight(0xffaa00, 40, 15);
                        this.light.castShadow = !isIOSSafari; // Disable on iOS
                        this.group.add(this.light);
                        const cord = new THREE.Mesh(sharedCordGeo, cordMat);
                        cord.position.y = 1.5;
                        this.group.add(cord);
                        this.baseIntensity = 40;
                        this.seed = Math.random() * 100;
                    }
                    update(time, playerZ) {
                        const flicker = Math.sin(time * 20) * 0.05 + Math.random() * 0.1;

                        // Distance Fade Logic
                        // FIX: Use World Position for distance check
                        const worldPos = new THREE.Vector3();
                        this.group.getWorldPosition(worldPos);
                        const dist = Math.abs(worldPos.z - playerZ);

                        const fadeStart = 40; // Starts fading in at 40m
                        const fadeEnd = 20;   // Full brightness at 20m

                        // Normalized Fade: 0 at fadeStart, 1 at fadeEnd
                        // Clamp between 0 and 1
                        let fade = (fadeStart - dist) / (fadeStart - fadeEnd);
                        fade = Math.max(0, Math.min(1, fade));

                        // Apply Fade to Intensity
                        // If fade is 0 (far away), light is OFF.
                        // If fade is 1 (close), light is FULL.
                        const currentBase = this.baseIntensity * fade;

                        this.light.intensity = currentBase + flicker * 10 * fade; // Flicker scales with intensity
                        this.light.distance = 15 * fade; // Also scale range to avoid pop-in

                        this.group.rotation.x = Math.cos(time * 0.3 + this.seed) * 0.03;
                        this.group.rotation.z = Math.sin(time * 0.5 + this.seed) * 0.03;
                    }
                    reset() {
                        // FIX: Do NOT update position. Parent Group move handles it.
                        // Just reset intensity logic states if needed.
                        this.light.intensity = 0; // Start off
                    }
                    dispose() {
                        // Traverse to dispose geometries inside the group (bulb, cord)
                        // FIX: DO NOT DISPOSE SHARED GEOMETRIES.
                        this.light.intensity = this.baseIntensity + flicker * 10 + boost;
                        this.group.rotation.x = Math.cos(time * 0.3 + this.seed) * 0.03;
                        this.group.rotation.z = Math.sin(time * 0.5 + this.seed) * 0.03;
                    }
                }

                // --- GLOWING LORE BOOK STATE ---
                // Note: We use GameState.state.collectedLore.length for global tracking, not a local counter
                let glowingBookCounter = 0;       // ID generator
                const activeGlowingBooks = [];    // Currently spawned books
                const SHIMMER_BASE_VOLUME = 0.4;
                const shimmerSound = new SCAudioAdapter('sc-widget-shimmer');
                shimmerSound.src = getSCUrl('assets/shimmer.mp3');
                shimmerSound.volume = SHIMMER_BASE_VOLUME * readerBackgroundVolume;
                let lastShimmerAt = 0;
                // One-shot SFX should not auto-resume after visibility changes.
                if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
                    window.AudioVisibilityManager.unregister(shimmerSound);
                }

                function applyBackgroundSfxVolume(reason = 'unspecified') {
                    shimmerSound.volume = Math.max(0, Math.min(1, SHIMMER_BASE_VOLUME * readerBackgroundVolume));
                    liminalDebugNote('bg-sfx', `${reason} shimmer=${shimmerSound.volume.toFixed(3)}`);
                }
                applyBackgroundSfxVolume('init');

                function allowAuxSfxPlaybackLiminal() {
                    const p = window.audioPlayer;
                    if (!p || !p.audio) return true;
                    const primaryPlaying = (typeof p.audio.isProbablyPlaying === 'function')
                        ? p.audio.isProbablyPlaying()
                        : !p.paused;
                    return !primaryPlaying && !contentSwitchInProgress && !document.hidden;
                }

                // Helper function to get global collected lore count
                function getGlobalCollectedLoreCount() {
                    if (window.GameState && window.GameState.state && window.GameState.state.collectedLore) {
                        return window.GameState.state.collectedLore.length;
                    }
                    return 0;
                }

                // Material for glowing books
                const glowBookMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf5c542,
                    emissive: 0xf5c542,
                    emissiveIntensity: 0.5,
                    roughness: 0.8,
                    metalness: 0.1
                });

                class GlowingBook {
                    constructor(zPos, side) {
                        this.id = glowingBookCounter++;
                        this.collected = false;
                        this.missed = false; // NEW: Track if player walked past without collecting
                        this.side = side; // 'left' or 'right'

                        // Book geometry (thin box for spine)
                        const geo = new THREE.BoxGeometry(0.6, 0.5, 0.08);
                        this.mesh = new THREE.Mesh(geo, glowBookMaterial.clone());

                        // Position: eye level (camera at 1.6m), slightly higher for visibility
                        // X offset: just 5cm (0.05m) towards center so book pops out slightly
                        // Y = 1.68 (1.4 shelf + 0.025 halfPlank + 0.25 halfBook + 0.005 margin)
                        const xPos = side === 'left' ? -2.45 : 2.45;
                        this.mesh.position.set(xPos, 1.68, zPos);
                        this.mesh.frustumCulled = false;

                        this.baseEmissive = 0.5;
                    }

                    update(time, playerZ, playerX) {
                        if (this.collected) return;

                        // FIX: Use world position (meshGroup may have moved)
                        const worldPos = new THREE.Vector3();
                        this.mesh.getWorldPosition(worldPos);
                        const distZ = Math.abs(worldPos.z - playerZ);
                        const distX = Math.abs(worldPos.x - playerX);

                        // Debug: log position every 60 frames
                        if (Math.random() < 0.016) { // ~1 per second at 60fps
                            console.log(`Book ${this.id}: worldZ=${worldPos.z.toFixed(1)}, playerZ=${playerZ.toFixed(1)}, dist=${distZ.toFixed(1)}`);
                        }

                        // Proximity glow intensification
                        if (distZ < 8 && distX < 3) {
                            const pulse = Math.sin(time * 3) * 0.15;
                            this.mesh.material.emissiveIntensity = 0.8 + pulse;
                        } else {
                            this.mesh.material.emissiveIntensity = this.baseEmissive;
                        }
                    }

                    collect() {
                        if (this.collected) return;
                        this.collected = true;
                        this.mesh.visible = false;
                    }

                    reset(newZ, newSide) {
                        // For pooling: reposition and reset state
                        this.collected = false;
                        this.mesh.visible = true;
                        this.side = newSide;
                        const xPos = newSide === 'left' ? -2.5 : 2.5;
                        this.mesh.position.set(xPos, 1.5, newZ);
                        this.mesh.material.emissiveIntensity = this.baseEmissive;
                    }
                }

                class HallwaySegment {
                    constructor(zStart, length, isPreload = false, onReady = null) {
                        this.zStart = zStart;
                        this.originalZStart = zStart; // Store for consistent local positioning
                        this.length = length;
                        this.isPreload = !!isPreload;
                        this.meshGroup = new THREE.Group();
                        this.lights = [];

                        // 1. Floor & Ceiling
                        // Use Shared Geometries!
                        const floor = new THREE.Mesh(sharedPlaneGeo, floorMaterial);
                        floor.rotation.x = -Math.PI / 2; floor.position.z = zStart - length / 2; floor.receiveShadow = !isIOSSafari;
                        floor.frustumCulled = false; // FIX: Prevent Abyss
                        this.meshGroup.add(floor);

                        const ceiling = new THREE.Mesh(sharedPlaneGeo, wallMaterial);
                        ceiling.rotation.x = Math.PI / 2; ceiling.position.y = config.roomHeight; ceiling.position.z = zStart - length / 2;
                        ceiling.frustumCulled = false; // FIX: Prevent Abyss
                        this.meshGroup.add(ceiling);

                        // 2. Shelves
                        const leftShelf = new THREE.Mesh(sharedShelfGeoLeft, woodMaterial);
                        leftShelf.position.set(-3.2, config.roomHeight / 2, zStart - length / 2); leftShelf.castShadow = !isIOSSafari; leftShelf.receiveShadow = !isIOSSafari;
                        leftShelf.frustumCulled = false; // FIX: Prevent Abyss
                        this.meshGroup.add(leftShelf);

                        const rightShelf = new THREE.Mesh(sharedShelfGeoRight, woodMaterial);
                        rightShelf.position.set(3.2, config.roomHeight / 2, zStart - length / 2); rightShelf.castShadow = !isIOSSafari; rightShelf.receiveShadow = !isIOSSafari;
                        rightShelf.frustumCulled = false; // FIX: Prevent Abyss
                        this.meshGroup.add(rightShelf);

                        // 3. Plank Levels
                        const levels = 9;
                        for (let i = 0; i < levels; i++) {
                            const y = (config.roomHeight / levels) * i + 0.4;

                            const pLeft = new THREE.Mesh(sharedPlankGeoLeft, woodMaterial);
                            pLeft.position.set(-2.6, y, zStart - length / 2);
                            pLeft.castShadow = !isIOSSafari; pLeft.receiveShadow = !isIOSSafari; // FIX: BLOCK LIGHT (Disable on iOS)
                            this.meshGroup.add(pLeft);

                            const pRight = new THREE.Mesh(sharedPlankGeoRight, woodMaterial);
                            pRight.position.set(2.6, y, zStart - length / 2);
                            pRight.castShadow = !isIOSSafari; pRight.receiveShadow = !isIOSSafari; // FIX: BLOCK LIGHT (Disable on iOS)
                            this.meshGroup.add(pRight);
                        }

                        // 4. Books (InstancedMesh)
                        this.createBooks(zStart, length, levels, isPreload, onReady);

                        // 5. Light (One per segment)
                        const light = new YellowLight(zStart - length / 2);
                        this.lights.push(light);
                        this.meshGroup.add(light.group);

                        // 6. Dust (Segment-Local)
                        this.createDust(length);

                        scene.add(this.meshGroup);
                    }

                    createDust(length) {
                        // ~80 particles per segment (approx half global density distributed)
                        const count = isIOSSafari ? 30 : 80;
                        const geo = new THREE.BufferGeometry();
                        const positions = new Float32Array(count * 3);
                        this.dustSpeeds = new Float32Array(count);

                        for (let i = 0; i < count; i++) {
                            // Local positions relative to segment center (0,0,0 is at floor, zStart-length/2)
                            // But WAIT: meshGroup origin is (0,0,0). 
                            // Floor is at zStart - length/2. 
                            // Let's check meshGroup structure again.
                            // Elements are added at Absolute World Coords? No.
                            // floor.position.z = zStart - length / 2;
                            // Yes, children have 'absolute' coords relative to a (0,0,0) group.

                            // So Dust must be placed within [zStart - length, zStart]
                            const z = this.zStart - Math.random() * length;
                            const x = (Math.random() - 0.5) * (config.roomWidth - 1); // Stay inside walls
                            const y = Math.random() * config.roomHeight;

                            positions[i * 3] = x;
                            positions[i * 3 + 1] = y;
                            positions[i * 3 + 2] = z;
                            this.dustSpeeds[i] = 0.05 + Math.random() * 0.1;
                        }
                        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                        // Re-create texture here or reuse? Reuse is better but for safety defining inline or global helper.
                        // Defining simple canvas texture helper:
                        if (!window.dustTex) {
                            const c = document.createElement('canvas'); c.width = 32; c.height = 32;
                            const ctx = c.getContext('2d');
                            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                            g.addColorStop(0, 'rgba(255,255,255,1)');
                            g.addColorStop(1, 'rgba(255,255,255,0)');
                            ctx.fillStyle = g; ctx.fillRect(0, 0, 32, 32);
                            window.dustTex = new THREE.CanvasTexture(c);
                        }

                        const mat = new THREE.PointsMaterial({
                            color: 0xaaaaaa, size: 0.05, map: window.dustTex,
                            transparent: true, opacity: 0.3,
                            depthWrite: false, blending: THREE.AdditiveBlending
                        });

                        this.dustMesh = new THREE.Points(geo, mat);
                        this.dustMesh.frustumCulled = false;
                        this.meshGroup.add(this.dustMesh);
                    }

                    update(delta, time, playerPos) {
                        // Update Lights
                        this.lights.forEach(l => l.update(time, playerPos.z)); // Pass playerZ for light fade

                        // Update Dust
                        if (this.dustMesh) {
                            const pos = this.dustMesh.geometry.attributes.position.array;
                            for (let i = 0; i < pos.length / 3; i++) {
                                pos[i * 3 + 1] -= this.dustSpeeds[i] * delta * 2.0; // Fall speed
                                if (pos[i * 3 + 1] < 0) {
                                    pos[i * 3 + 1] = config.roomHeight;
                                }
                            }
                            this.dustMesh.geometry.attributes.position.needsUpdate = true;
                        }
                    }

                    createBooks(zStart, length, levels) {
                        this.glowingBook = null;
                        const segmentIndex = Math.abs(Math.round(zStart / length));
                        // Count uncollected active books
                        const uncollectedBooks = activeGlowingBooks.filter(b => !b.collected && !b.missed).length;
                        const globalLoreCount = getGlobalCollectedLoreCount();
                        if (segmentIndex % 5 === 0 && segmentIndex > 0 && globalLoreCount < 5 && uncollectedBooks < 1) {
                            const side = Math.random() > 0.5 ? 'left' : 'right';
                            this.glowingBook = new GlowingBook(zStart - length / 2, side);
                            this.meshGroup.add(this.glowingBook.mesh);
                            activeGlowingBooks.push(this.glowingBook);
                        }
                    }

                    reset(newZStart) {
                        // FIX: Calculate offset BEFORE updating this.zStart
                        const currentZStart = this.zStart; // This tracks where it currently is logically
                        const offset = newZStart - currentZStart;

                        this.zStart = newZStart;

                        // Move everything by offset
                        this.meshGroup.position.z += offset;

                        // Reset Lights
                        // FIX: Do NOT pass newZ. Light position is relative and static.
                        this.lights.forEach(l => l.reset());

                        // Reset Books
                        this.resetBooks();

                        // Handle Glowing Book for recycled segment
                        // Remove old book if it was collected or missed
                        if (this.glowingBook && (this.glowingBook.collected || this.glowingBook.missed)) {
                            // Remove from active list
                            const idx = activeGlowingBooks.indexOf(this.glowingBook);
                            if (idx > -1) activeGlowingBooks.splice(idx, 1);
                            // Remove mesh
                            this.meshGroup.remove(this.glowingBook.mesh);
                            this.glowingBook = null;
                        }

                        // Try to spawn a new glowing book (same logic as constructor)
                        const globalLoreCount = getGlobalCollectedLoreCount();
                        if (!this.glowingBook && globalLoreCount < 5) {
                            const segmentIndex = Math.abs(Math.round(newZStart / this.length));
                            const uncollectedBooks = activeGlowingBooks.filter(b => !b.collected && !b.missed).length;
                            if (segmentIndex % 5 === 0 && segmentIndex > 0 && uncollectedBooks < 1) {
                                const side = Math.random() > 0.5 ? 'left' : 'right';
                                // FIX: Use ORIGINAL constructor zStart for local coordinates
                                // This matches how floor, shelves, and other segment objects are positioned
                                const localZ = this.originalZStart - this.length / 2;
                                this.glowingBook = new GlowingBook(localZ, side);
                                this.meshGroup.add(this.glowingBook.mesh);
                                // Force matrix update so getWorldPosition works immediately
                                this.glowingBook.mesh.updateMatrixWorld(true);
                                activeGlowingBooks.push(this.glowingBook);

                                // Debug: log actual world position
                                const debugPos = new THREE.Vector3();
                                this.glowingBook.mesh.getWorldPosition(debugPos);
                                console.log(`Spawned book: local=(${localZ}), world=(${debugPos.z.toFixed(1)}), target=(${(newZStart - this.length / 2).toFixed(1)})`);
                            }
                        }

                        // force update
                        this.meshGroup.updateMatrixWorld(true);
                    }

                    createBooks(zStart, length, levels, isPreload, onReady) {
                        // User requested to NOT reduce book count, but instead reduce geometry faces (applied to sharedBookGeo)
                        const bookCount = 6000;
                        // SAVE REFERENCES for Reset
                        this.bookCount = bookCount;
                        this.isPreload = !!isPreload;
                        if (!this.meshBooks) {
                            this.meshBooks = new THREE.InstancedMesh(sharedBookGeo, bookMat, bookCount);
                            this.meshBooks.castShadow = true; this.meshBooks.receiveShadow = true;
                            this.meshBooks.frustumCulled = false; // FIX: Prevent invisible books
                            this.meshGroup.add(this.meshBooks);
                        }
                        this.meshBooks.count = 0; // Hide all initially

                        this.resetBooks = () => {
                            // Correct Z of InstancedMesh?
                            // It is child of meshGroup. If Group moves, it moves.
                            // But book positions are calculated in LOCAL space or WORLD space?
                            // in `processBatch`: dummy.position.set(..., currentZ)
                            // currentZ starts at zStart. 
                            // If meshGroup moved, currentZ (local) should validly be relative?
                            // Wait. In constructor: `floor.position.z = zStart - length/2`.
                            // If `meshGroup` is at (0,0,0) initially.
                            // Objects are at world Z.
                            // If we now move meshGroup.position.z by -50.
                            // Objects move -50. 
                            // So Reset Logic:
                            // 1. Move MeshGroup.
                            // 2. Generate books using RELATIVE coords?
                            // Currently logic uses `zStart` (Absolute).
                            // This is improper for grouping.
                            // BUT converting to relative is risky big refactor.

                            // Alternative:
                            // Just update `zStart` in this closure?
                            // New generator run.
                            if (typeof this.pauseBookGeneration === 'function') {
                                this.pauseBookGeneration();
                            }
                            this.meshBooks.count = 0;
                            this.startBookGeneration();
                        };

                        // We need to allow restarting generation.
                        this.startBookGeneration = () => {
                            const dummy = new THREE.Object3D();
                            const color = new THREE.Color();
                            const bookColors = [0x4a3c31, 0x2f1e15, 0x6e2c2c, 0x1a2e1f, 0x0d0d0d, 0x5c5040];

                            // Calculate Z range relative to GROUP position?
                            // The group has moved to `newZStart`.
                            // Objects inside are defined at `oldZStart`.
                            // Moving group shifts them to `newZStart`.
                            // So we should generate books at `oldZStart` coordinates? 
                            // Yes. If we use `zStart` (original) it works.

                            let globalIndex = 0;
                            const workQueue = [];
                            this.bookBuildRaf = null;
                            this.bookBuildPaused = false;
                            // Use 'local' start (original zStart) 
                            // because Group translation handles current World Pos.
                            const localZStart = zStart;

                            // 1. Prepare Queue
                            for (let side of [-1, 1]) {
                                const shelfX = side * 2.6;
                                for (let i = 0; i < levels; i++) {
                                    workQueue.push({ side, shelfX, levelIndex: i });
                                }
                            }

                            this.pauseBookGeneration = () => {
                                this.bookBuildPaused = true;
                                if (this.bookBuildRaf !== null) {
                                    cancelAnimationFrame(this.bookBuildRaf);
                                    this.bookBuildRaf = null;
                                }
                            };

                            this.resumeBookGeneration = () => {
                                if (!this.bookBuildPaused) return;
                                this.bookBuildPaused = false;
                                if (workQueue.length === 0 || globalIndex >= this.bookCount) return;
                                if (this.bookBuildRaf === null) {
                                    this.bookBuildRaf = requestAnimationFrame(processBatch);
                                }
                            };

                            const processBatch = () => {
                                // Keep preload alive even if coming from another page with freeze enabled.
                                const freezeBypassDuringBoot = this.isPreload && !hasStartedGame;
                                const shouldPauseForFreeze = window.visualFreezeActive && !freezeBypassDuringBoot;
                                if (this.bookBuildPaused || shouldPauseForFreeze) {
                                    this.bookBuildPaused = true;
                                    this.bookBuildRaf = null;
                                    return;
                                }

                                // Stop if we are reset again? (version check?)
                                if (workQueue.length === 0 || globalIndex >= this.bookCount) {
                                    this.bookBuildPaused = false;
                                    this.bookBuildRaf = null;
                                    if (onReady) {
                                        onReady();
                                        onReady = null; // Prevent re-triggering during Recycle/Reset!
                                    }
                                    return;
                                }
                                // ... (Same logic)
                                const batchSize = isPreload ? 60 : 5;
                                for (let b = 0; b < batchSize; b++) {
                                    if (workQueue.length === 0) break;
                                    const task = workQueue.shift();
                                    if (task.levelIndex >= 6) continue;
                                    const y = (config.roomHeight / levels) * task.levelIndex + 0.7;
                                    if (y > config.roomHeight - 0.5) continue;

                                    let currentZ = localZStart;
                                    const endZ = localZStart - length;

                                    while (currentZ > endZ) {
                                        if (globalIndex >= this.bookCount) break;
                                        // ... Generation ...
                                        const height = 0.5 + Math.random() * 0.3;
                                        const thick = 0.05 + Math.random() * 0.08;
                                        const depth = 0.7 + Math.random() * 0.15;
                                        const gap = 0.03;

                                        if (Math.random() > 0.02) {
                                            const xOffset = (Math.random() - 0.5) * 0.1;
                                            // Coordinates are "Local" (relative to original zStart)
                                            dummy.position.set(task.shelfX + xOffset, y - 0.3 + height / 2, currentZ - thick / 2);
                                            dummy.scale.set(depth, height, thick);
                                            dummy.rotation.set(0, 0, 0);
                                            let zRot = 0;
                                            if (task.side === 1) {
                                                // Rotate 180 deg around Z:
                                                // Spine (+X) flips to (-X) facing the shelf center.
                                                // Cover (+Z) stays (+Z) facing the player.
                                                zRot = Math.PI;
                                            }
                                            dummy.rotation.z = zRot + (Math.random() - 0.5) * 0.08;
                                            dummy.rotation.y += (Math.random() - 0.5) * 0.08;
                                            dummy.updateMatrix();
                                            this.meshBooks.setMatrixAt(globalIndex, dummy.matrix);

                                            // Color
                                            color.setHex(bookColors[Math.floor(Math.random() * bookColors.length)]);
                                            color.r += (Math.random() - 0.5) * 0.1;
                                            // ...
                                            this.meshBooks.setColorAt(globalIndex, color);
                                            globalIndex++;
                                            currentZ -= (thick + gap);
                                        } else {
                                            currentZ -= (0.05 + Math.random() * 0.15);
                                        }
                                    }
                                }
                                this.meshBooks.count = globalIndex;
                                this.meshBooks.instanceMatrix.needsUpdate = true;
                                if (this.meshBooks.instanceColor) this.meshBooks.instanceColor.needsUpdate = true;
                                this.bookBuildRaf = requestAnimationFrame(processBatch);
                            };
                            processBatch();
                        };

                        this.startBookGeneration();
                    }

                    dispose() {
                        // 1. Dispose Lights
                        this.lights.forEach(l => l.dispose());

                        // 2. Dispose Geometries
                        // FIX: DO NOT DISPOSE SHARED GEOMETRIES.

                        // 3. Remove from Scene
                        scene.remove(this.meshGroup);
                    }
                }

                // --- GAME LOOP ---
                const segments = [];
                // const segmentPool = []; // REMOVED: Proper recycling uses the active list directly
                const segmentLength = config.segmentLength;

                function updateSegments(playerZ) {
                    // Ensure we have 4 segments initially (handled by preload) but check just in case
                    if (segments.length < 4) {
                        const lastZ = segments.length > 0 ? segments[segments.length - 1].zStart : 10;
                        addSegment(lastZ - segmentLength);
                        return;
                    }

                    const lastSeg = segments[segments.length - 1];
                    const firstSeg = segments[0];

                    // Recycle trigger: Player passed the first segment's end (plus buffer)
                    // firstSeg covers [zStart - 20, zStart]. Center is zStart - 10.
                    // If playerZ < firstSeg.zStart - segmentLength - 5 (approx)
                    // e.g. zStart=0. Range [-20, 0]. Player at -25.
                    if (playerZ < firstSeg.zStart - segmentLength - 5) {
                        // RECYCLE: Take first segment, reset it to new position at end
                        const newZ = lastSeg.zStart - segmentLength;

                        // console.log(`Recycling Segment: Moving from ${firstSeg.zStart} to ${newZ}`);

                        firstSeg.reset(newZ);

                        // Move from front to back of array
                        segments.shift();
                        segments.push(firstSeg);
                    }
                }

                function addSegment(zStart) {
                    const seg = new HallwaySegment(zStart, segmentLength);
                    segments.push(seg);
                }

                let clock = null;
                let velocity = null;
                if (!window.fallback2DMode && THREE) {
                    clock = new THREE.Clock();
                    velocity = new THREE.Vector3();
                }
                const move = { f: false, b: false, l: false, r: false };
                let animationLoopRunning = false;
                let hasStartedGame = false;

                function setSegmentGenerationPaused(paused) {
                    for (const seg of segments) {
                        if (!seg) continue;
                        if (!hasStartedGame && seg.isPreload) continue;
                        if (paused && typeof seg.pauseBookGeneration === 'function') {
                            seg.pauseBookGeneration();
                        } else if (!paused && typeof seg.resumeBookGeneration === 'function') {
                            seg.resumeBookGeneration();
                        }
                    }
                }

                function applyVisualFreezeState(frozen) {
                    window.visualFreezeActive = !!frozen;
                    if (window.visualFreezeActive) {
                        setSegmentGenerationPaused(true);
                        return;
                    }
                    setSegmentGenerationPaused(false);
                    if (hasStartedGame && !document.hidden) {
                        if (clock) clock.getDelta(); // Discard stale frame delta after resume.
                        startAnimationLoop();
                    }
                }

                if (globalVisualDimmer) {
                    globalVisualDimmer.onChange(({ level, frozen }) => {
                        manualBackgroundDimLevel = level;
                        applyReaderDimmerTint();
                        applyVisualFreezeState(frozen);

                        if (frozen && !isReadingMode) {
                            isReadingMode = true;
                            updateReadingModeUI();
                        }
                    });
                }
                applyVisualFreezeState(window.visualFreezeActive);
                applyReaderDimmerTint();
                if (globalVisualDimmer && globalVisualDimmer.isFrozen() && !isReadingMode) {
                    isReadingMode = true;
                    updateReadingModeUI();
                }


                // Click-to-Move State
                let moveTarget = null;
                let cameraLookTarget = null; // 3D point camera should smoothly look at
                let raycaster = null;
                let groundPlane = null;
                if (!window.fallback2DMode && THREE) {
                    raycaster = new THREE.Raycaster();
                    groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Plane y=0 (facing up)
                }
                let uiInteractionStarted = false;
                let lastUiInteractionAt = 0;
                const UI_CLICK_SUPPRESS_MS = 700;
                let suppressWorldInputUntil = 0;
                let lastDeadzoneTop = null;
                let touchStartedOnRenderer = false;

                function getWorldInputLockReason() {
                    const archiveModal = document.getElementById('archiveModal');
                    if (archiveModal && archiveModal.classList.contains('visible')) return 'archive-modal';

                    const overlay = document.getElementById('transitionOverlay');
                    if (overlay && overlay.classList.contains('active')) return 'transition-overlay';

                    const loadingScreen = document.getElementById('loading-screen');
                    if (loadingScreen) {
                        const style = window.getComputedStyle(loadingScreen);
                        if (style.display !== 'none' && style.visibility !== 'hidden' && Number(style.opacity || '1') > 0.01) {
                            return 'loading-screen';
                        }
                    }
                    return '';
                }

                function isRendererElement(target) {
                    if (window.fallback2DMode || !target || !renderer || !renderer.domElement) return false;
                    if (target === renderer.domElement) return true;
                    return !!(target.nodeType === 1 && renderer.domElement.contains(target));
                }

                function markUiInteraction(reason = 'ui') {
                    lastUiInteractionAt = performance.now();
                    suppressWorldInputUntil = lastUiInteractionAt + UI_CLICK_SUPPRESS_MS;
                    uiInteractionStarted = true;
                    cameraLookTarget = null;
                    isLookingAtClickTarget = false;
                    isCenteringCamera = false;
                    isTouchDragging = false;
                    touchMovedForTap = false;
                    touchStartedOnUi = true;
                    touchStartedOnRenderer = false;
                    isTouchValid = false;
                    syncLookTargetsToCamera();
                    liminalDebugNote('ui-hit', reason);
                }

                function isUiClickTarget(target) {
                    const el = target && target.nodeType === 1
                        ? target
                        : (target && target.parentElement ? target.parentElement : null);
                    if (!el || typeof el.closest !== 'function') return false;
                    const subtitleHit = !!el.closest('#subtitleContainer');
                    return !!(
                        el.closest('#audioControls') ||
                        el.closest('.audio-btn') ||
                        el.closest('#archiveModal') ||
                        el.closest('.menu-item') ||
                        (isReadingMode && subtitleHit) ||
                        el.closest('#nextChapterBtn') ||
                        el.closest('#loading')
                    );
                }

                function getUiDeadzoneTop() {
                    const tops = [];
                    const controls = document.getElementById('audioControls');
                    const ui = document.getElementById('audioPlayerUI');
                    const subtitle = document.getElementById('subtitleContainer');

                    if (controls) {
                        tops.push(controls.getBoundingClientRect().top - 8);
                    }
                    if (window.innerWidth <= 768 && isReadingMode && subtitle) {
                        tops.push(subtitle.getBoundingClientRect().top - 12);
                    }
                    if (window.innerWidth <= 768 && isReadingMode && ui) {
                        tops.push(ui.getBoundingClientRect().top - 8);
                    }

                    if (tops.length === 0) {
                        const fallback = window.innerHeight - 160;
                        if (lastDeadzoneTop !== null && Math.abs(fallback - lastDeadzoneTop) > 60) {
                            liminalCause('C07_DEADZONE_LAYOUT_DRIFT', `fallback ${lastDeadzoneTop.toFixed(1)} -> ${fallback.toFixed(1)}`);
                        }
                        lastDeadzoneTop = fallback;
                        return fallback;
                    }
                    const resolved = Math.max(0, Math.min(...tops));
                    if (lastDeadzoneTop !== null && Math.abs(resolved - lastDeadzoneTop) > 60) {
                        liminalCause('C07_DEADZONE_LAYOUT_DRIFT', `${lastDeadzoneTop.toFixed(1)} -> ${resolved.toFixed(1)}`);
                    }
                    lastDeadzoneTop = resolved;
                    return resolved;
                }

                function isPointInsideUi(clientX, clientY) {
                    const roots = [
                        document.getElementById('audioControls'),
                        document.getElementById('nextChapterBtn'),
                        document.getElementById('archiveModal'),
                        document.getElementById('chapterMenu')
                    ];
                    if (isReadingMode) {
                        roots.push(document.getElementById('subtitleContainer'));
                    }
                    for (const root of roots) {
                        if (!root) continue;
                        const r = root.getBoundingClientRect();
                        if (clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom) {
                            return true;
                        }
                    }
                    return false;
                }

                function bindUiInputShield() {
                    const roots = [
                        document.getElementById('audioControls'),
                        document.getElementById('nextChapterBtn'),
                        document.getElementById('archiveModal'),
                        document.getElementById('chapterMenu')
                    ];
                    if (isReadingMode) {
                        roots.push(document.getElementById('subtitleContainer'));
                    }
                    const shieldEvents = ['pointerdown', 'touchstart', 'touchend', 'click'];
                    const onShield = (event) => {
                        const targetInfo = event.target && event.target.id ? event.target.id : (event.target && event.target.className ? String(event.target.className) : event.type);
                        markUiInteraction(`shield:${event.type}:${targetInfo}`);
                    };

                    for (const root of roots) {
                        if (!root) continue;
                        for (const ev of shieldEvents) {
                            root.addEventListener(ev, onShield, true);
                        }
                    }
                }
                bindUiInputShield();

                document.addEventListener('pointerdown', (event) => {
                    const worldLockReason = getWorldInputLockReason();
                    if (worldLockReason) {
                        markUiInteraction(`pointerdown-world-lock:${worldLockReason}`);
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', `pointerdown-world-lock:${worldLockReason}`);
                        return;
                    }
                    const isUiHit = isUiClickTarget(event.target) || isPointInsideUi(event.clientX, event.clientY) || event.clientY >= getUiDeadzoneTop();
                    if (isUiHit) {
                        markUiInteraction(`pointerdown-ui:${event.clientY}`);
                    } else {
                        uiInteractionStarted = false;
                    }
                }, true);

                document.addEventListener('click', (event) => {
                    const worldLockReason = getWorldInputLockReason();
                    if (worldLockReason) {
                        markUiInteraction(`click-world-lock:${worldLockReason}`);
                        liminalCause('C02_WORLD_BLOCKED_CLICK', `world-lock:${worldLockReason}`);
                        return;
                    }

                    if (performance.now() < suppressWorldInputUntil) {
                        uiInteractionStarted = false;
                        liminalDebugNote('world-click-skip', 'suppressed-window');
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'suppressed-window');
                        return;
                    }

                    const isMobile = window.innerWidth <= 768;
                    if (isMobile) {
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'mobile-click-path-disabled');
                        return;
                    }

                    const sinceUiInteraction = performance.now() - lastUiInteractionAt;
                    if (isMobile && sinceUiInteraction < UI_CLICK_SUPPRESS_MS) {
                        uiInteractionStarted = false;
                        liminalDebugNote('world-click-skip', 'mobile-ui-window');
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'mobile-ui-window');
                        return;
                    }

                    if (uiInteractionStarted) {
                        uiInteractionStarted = false;
                        liminalDebugNote('world-click-skip', 'ui-started');
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'ui-started');
                        return;
                    }

                    // Use elementFromPoint for reliable detection (works with pointer events)
                    const clickedEl = document.elementFromPoint(event.clientX, event.clientY);

                    // Ignore clicks on UI elements
                    if (isUiClickTarget(clickedEl) || event.clientY >= getUiDeadzoneTop()) {
                        markUiInteraction('click-ui-target');
                        console.log("Click ignored: UI element");
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'click-ui-target');
                        return;
                    }

                    if (isMobile && (!renderer || clickedEl !== renderer.domElement)) {
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'mobile-not-renderer');
                        return;
                    }

                    // DISABLED in reading mode
                    if (player.isReadingMode) {
                        console.log("Click-to-move disabled in reading mode");
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'reading-mode');
                        return;
                    }

                    // If this was a touch drag (swipe), don't trigger click-to-move
                    if (isTouchDragging) {
                        console.log("Click ignored: was a drag gesture");
                        isTouchDragging = false;
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'drag-gesture');
                        return;
                    }

                    // CHECK DEADZONE (Bottom Screen - Mobile Buttons)
                    // If click is in the bottom 80px (approx UI height), IGNOR
                    if (event.clientY >= getUiDeadzoneTop()) {
                        console.log("Ignored Click in UI Deadzone");
                        liminalCause('C02_WORLD_BLOCKED_CLICK', 'deadzone');
                        return;
                    }

                    liminalCause('C01_WORLD_PATH_CLICK', `x=${event.clientX} y=${event.clientY}`);
                    trySetMoveTargetFromScreenPoint(event.clientX, event.clientY, false);
                });

                function trySetMoveTargetFromScreenPoint(clientX, clientY, isMobileTap) {
                    if (window.fallback2DMode) return;
                    const worldLockReason = getWorldInputLockReason();
                    if (worldLockReason) {
                        liminalDebugNote('move-skip', `world-lock:${worldLockReason}`);
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', `move-skip:world-lock:${worldLockReason}`);
                        return;
                    }

                    const sinceUi = performance.now() - lastUiInteractionAt;
                    if (performance.now() < suppressWorldInputUntil) {
                        liminalDebugNote('move-skip', 'suppressed-window');
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'move-skip:suppressed-window');
                        return;
                    }
                    if (clientY >= getUiDeadzoneTop() || isPointInsideUi(clientX, clientY)) {
                        liminalDebugNote('move-skip', 'ui-deadzone-boundary');
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'move-skip:ui-deadzone-boundary');
                        return;
                    }

                    // Calculate click position in normalized coordinates
                    const clickScreenX = (clientX / window.innerWidth) * 2 - 1;
                    const clickScreenY = (clientY / window.innerHeight) * 2 - 1;
                    const clickMouse = new THREE.Vector2();
                    clickMouse.x = clickScreenX;
                    clickMouse.y = -clickScreenY; // Flip Y for Three.js

                    raycaster.setFromCamera(clickMouse, camera);

                    // Check intersection with Scene Objects
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    let target = null;

                    for (let i = 0; i < intersects.length; i++) {
                        if (intersects[i].object.type === 'Points') continue;
                        target = intersects[i].point;
                        break;
                    }

                    // Fallback to Ground Plane
                    if (!target) {
                        const groundTarget = new THREE.Vector3();
                        if (raycaster.ray.intersectPlane(groundPlane, groundTarget)) {
                            target = groundTarget;
                        }
                    }

                    if (target) {
                        if (isPointInsideUi(clientX, clientY) || clientY >= getUiDeadzoneTop()) {
                            liminalCause('C05_MOVE_SET_FROM_UI_REGION', `x=${clientX} y=${clientY}`);
                        }
                        if (sinceUi < UI_CLICK_SUPPRESS_MS + 30) {
                            liminalCause('C06_MOVE_SET_RECENT_UI_WINDOW', `sinceUi=${sinceUi.toFixed(0)}ms`);
                        }
                        if (isMobileTap) {
                            cameraLookTarget = target.clone();
                        }

                        // Clamp X to hallway bounds for movement
                        if (target.x < -2.5) target.x = -2.5;
                        if (target.x > 2.5) target.x = 2.5;

                        // NO BACKWARDS MOVEMENT
                        if (target.z > camera.position.z + 2.0) {
                            console.log("Ignored Backwards Click");
                            cameraLookTarget = null; // Don't look at backwards target
                            liminalDebugNote('move-skip', 'backwards-target');
                            return;
                        }

                        // Set movement Target
                        moveTarget = new THREE.Vector3(target.x, camera.position.y, target.z);
                        liminalDebugNote('move-set', `${isMobileTap ? 'tap' : 'click'} x=${target.x.toFixed(2)} z=${target.z.toFixed(2)}`);
                        console.log("Moving to:", moveTarget, "Looking at:", cameraLookTarget);
                    }
                }

                document.addEventListener('touchend', (event) => {
                    if (player && player.isReadingMode) {
                        liminalDebugNote('touchend-skip', 'reading-mode');
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'reading-mode');
                        touchStartedOnRenderer = false;
                        return;
                    }
                    if (window.innerWidth > 768) return;
                    const worldLockReason = getWorldInputLockReason();
                    if (worldLockReason) {
                        markUiInteraction(`touchend-world-lock:${worldLockReason}`);
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', `world-lock:${worldLockReason}`);
                        return;
                    }
                    if (isUiClickTarget(event.target)) {
                        markUiInteraction('touchend-event-target-ui');
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'event-target-ui');
                        return;
                    }
                    if (performance.now() < suppressWorldInputUntil) {
                        liminalDebugNote('touchend-skip', 'suppressed-window');
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'suppressed-window');
                        touchStartedOnRenderer = false;
                        return;
                    }

                    // Ignore UI-origin touches and drag gestures
                    if (!isTouchValid || touchStartedOnUi || isTouchDragging || touchMovedForTap) {
                        const sinceUi = performance.now() - lastUiInteractionAt;
                        liminalDebugNote('touchend-skip', `flags valid=${isTouchValid} ui=${touchStartedOnUi} drag=${isTouchDragging} moved=${touchMovedForTap}`);
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', `flags valid=${isTouchValid} ui=${touchStartedOnUi} drag=${isTouchDragging} moved=${touchMovedForTap}`);
                        if (!touchStartedOnUi && !isTouchDragging && !touchMovedForTap && !isTouchValid && sinceUi > 1200) {
                            liminalCause('C08_TOUCHFLAGS_STUCK', `isTouchValid=false sinceUi=${sinceUi.toFixed(0)}ms`);
                        }
                        isTouchDragging = false;
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        return;
                    }

                    if (!event.changedTouches || event.changedTouches.length === 0) return;
                    const touch = event.changedTouches[0];

                    if (isPointInsideUi(touch.clientX, touch.clientY)) {
                        markUiInteraction('touchend-point-ui');
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'point-inside-ui');
                        return;
                    }

                    // Ignore taps in control deadzone
                    if (touch.clientY >= getUiDeadzoneTop()) {
                        liminalDebugNote('touchend-skip', 'deadzone');
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'deadzone');
                        return;
                    }

                    const touchedEl = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (isUiClickTarget(touchedEl)) {
                        markUiInteraction('touchend-ui-target');
                        touchStartedOnRenderer = false;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'touchedEl-ui-target');
                        return;
                    }
                    if (!touchStartedOnRenderer) {
                        liminalDebugNote('touchend-skip', 'start-not-renderer');
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'start-not-renderer');
                        return;
                    }
                    if (!isRendererElement(touchedEl)) {
                        liminalDebugNote('touchend-skip', 'not-renderer');
                        touchMovedForTap = false;
                        touchStartedOnUi = false;
                        touchStartedOnRenderer = false;
                        isTouchValid = true;
                        liminalCause('C04_WORLD_BLOCKED_TOUCH', 'not-renderer');
                        return;
                    }

                    liminalCause('C03_WORLD_PATH_TOUCH', `x=${touch.clientX} y=${touch.clientY}`);
                    trySetMoveTargetFromScreenPoint(touch.clientX, touch.clientY, true);
                    isTouchDragging = false;
                    touchMovedForTap = false;
                    touchStartedOnUi = false;
                    touchStartedOnRenderer = false;
                    isTouchValid = true;
                }, { passive: true });
                document.addEventListener('keydown', (e) => {
                    // Debug: Log key code and Mode
                    // console.log("Keydown:", e.code, "ReadingMode:", isReadingMode);
                    const code = e.code;
                    if (code === 'KeyW' || code === 'ArrowUp') move.f = true;
                    if (code === 'KeyS' || code === 'ArrowDown') move.b = true;
                    if (code === 'KeyA' || code === 'ArrowLeft') { move.l = true; console.log("Move Left START"); }
                    if (code === 'KeyD' || code === 'ArrowRight') { move.r = true; console.log("Move Right START"); }
                });
                document.addEventListener('keyup', (e) => {
                    const code = e.code;
                    if (code === 'KeyW' || code === 'ArrowUp') move.f = false;
                    if (code === 'KeyS' || code === 'ArrowDown') move.b = false;
                    if (code === 'KeyA' || code === 'ArrowLeft') move.l = false;
                    if (code === 'KeyD' || code === 'ArrowRight') move.r = false;
                });

                // --- LORE MODE FUNCTIONS (Glowing Books) ---
                // Uses existing isLoreMode and mainAudioState from line ~725

                // --- LORE MODE ---
                // (Global window.startLoreMode defined above is used)

                // --- INIT & PRELOAD ---
                console.log("DEBUG: Initialization Complete. Starting Preload...");

                // 1. Initial Segments Preload
                let loadedSegments = 0;
                // User Request: Start at Meter 3.00 -> Need segment at +10 to cover start (Range 0 to 10)
                const initialZ = [10, 0, -10, -20];
                const totalToLoad = initialZ.length;

                function checkPreloadComplete() {
                    loadedSegments++;
                    // console.log(`DEBUG: Loaded Segments: ${loadedSegments} / ${totalToLoad}`);
                    // Update Loading Bar or Logic here if needed
                    if (loadedSegments >= totalToLoad) {
                        console.log("DEBUG: Preload Complete. Starting Game.");
                        startGame();
                    }
                }

                // Create initial segments with High Priority (Preload Mode)
                if (!window.fallback2DMode && THREE) {
                    initialZ.forEach(z => {
                        segments.push(new HallwaySegment(z, segmentLength, true, checkPreloadComplete));
                    });
                } else {
                    console.log("DEBUG: Fallback Mode active. Skipping 3D preload.");
                    startGame();
                }

                function startGame() {
                    hasStartedGame = true;

                    // Hide 'Click to Start' and Loading Screens
                    const loadingText = document.getElementById('loading');
                    if (loadingText) loadingText.style.display = 'none';

                    const loadingScreen = document.getElementById('loading-screen');
                    if (loadingScreen) loadingScreen.style.display = 'none';

                    // Show Game UI immediately
                    if (uiContainer) uiContainer.style.display = 'flex';
                    if (isReadingMode && isBlaetternLayoutSelected()) {
                        scheduleBlaetternPaginationRetry('ui-visible');
                    }
                    if (window.audioPlayer && typeof window.audioPlayer.renderLines === 'function') {
                        const idx = Number.isFinite(window.audioPlayer.currentSubtitleIndex)
                            ? window.audioPlayer.currentSubtitleIndex
                            : 0;
                        window.audioPlayer.renderLines(Math.max(0, idx));
                    }

                    // SAFETY SYNC: Force Reading Mode State
                    if (window.audioPlayer && isReadingMode) {
                        window.audioPlayer.setReadingMode(true);
                    }

                    if (mainChapterAutoplayIntent.shouldAutoplay) {
                        liminalDebugNote('autoplay', `boot start source=${mainChapterAutoplayIntent.source} reason=${mainChapterAutoplayIntent.reason}`);
                        verifyPlaybackStarted(3, 320).then(started => {
                            liminalDebugNote('autoplay', `boot result started=${started}`);
                            updateIcons();
                        });
                    } else {
                        liminalDebugNote('autoplay', `suppressed policy=${mainChapterAutoplayIntent.policy} reason=${mainChapterAutoplayIntent.reason}`);
                        updateIcons();
                    }

                    // Init Dust - REMOVED Global System (now in segments)
                    // if (!dustSystem) ...

                    // FIX: Force Shader Compilation to prevent initial stutter
                    try {
                        if (!window.fallback2DMode && renderer) renderer.compile(scene, camera);
                    } catch (e) {
                        console.warn("Shader compilation failed:", e);
                    }

                    // ============================================
                    // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
                    // ============================================
                    let wasAmbientPlaying = false;
                    let wasPlayerPlaying = false;
                    let visibilityResumeToken = 0;
                    window.gamePaused = false; // Flag for Game Loop

                    document.addEventListener('visibilitychange', () => {
                        const token = ++visibilityResumeToken;
                        if (document.hidden) {
                            // APP BACKGROUNDED -> PAUSE ALL
                            window.gamePaused = true;
                            saveCurrentContentState({ preferCachedTime: true, reason: 'visibility:hidden' });
                            liminalDebugNote('visibility', 'hidden');

                            if (typeof ambientAudio !== 'undefined') {
                                wasAmbientPlaying = (typeof ambientAudio.isProbablyPlaying === 'function')
                                    ? ambientAudio.isProbablyPlaying()
                                    : !ambientAudio.paused;
                                ambientAudio.pause();
                                liminalDebugNote('ambient', `pause hidden (wasPlaying=${wasAmbientPlaying})`);
                            } else {
                                wasAmbientPlaying = false;
                            }

                            if (typeof audioPlayer !== 'undefined') {
                                wasPlayerPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                                    ? audioPlayer.isProbablyPlaying()
                                    : !audioPlayer.paused;
                                audioPlayer.pause();
                                liminalDebugNote('player', `pause hidden (wasPlaying=${wasPlayerPlaying})`);
                            } else {
                                wasPlayerPlaying = false;
                            }

                        } else {
                            // APP FOREGROUND -> RESUME
                            window.gamePaused = false;
                            liminalDebugNote('visibility', 'visible');
                            if (!window.visualFreezeActive) {
                                startAnimationLoop();
                            }
                            // Discard accumulated clock time on resume
                            if (typeof clock !== 'undefined') clock.getDelta();

                            setTimeout(() => {
                                if (token !== visibilityResumeToken || document.hidden) return;
                                if (contentSwitchInProgress) {
                                    liminalDebugNote('visibility', 'resume skipped (content switch active)');
                                    return;
                                }
                                if (wasAmbientPlaying && typeof ambientAudio !== 'undefined') {
                                    ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                                    wasAmbientPlaying = false;
                                    liminalDebugNote('ambient', 'resume on visible');
                                }
                                if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                                    audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                                    wasPlayerPlaying = false;
                                    liminalDebugNote('player', 'resume on visible');
                                }
                            }, 100);
                        }
                    });

                    window.addEventListener('pagehide', () => {
                        visibilityResumeToken += 1;
                        saveCurrentContentState({ preferCachedTime: true, reason: 'pagehide' });
                        if (typeof ambientAudio !== 'undefined') ambientAudio.pause();
                        if (typeof audioPlayer !== 'undefined') audioPlayer.pause();
                        liminalDebugNote('lifecycle', 'pagehide');
                    });

                    // Start Animation Loop only after preload
                    startAnimationLoop();
                }

                // Global Animation State
                let headBob = 0;
                // let dustSystem = null; // Removed

                // Handle Window Resize
                window.addEventListener('resize', () => {
                    syncViewport();
                });

                // Animate
                let lastFrameTime = performance.now();
                let frameCount = 0;
                let fpsLogTimer = 0;

                function startAnimationLoop() {
                    if (animationLoopRunning || window.visualFreezeActive) return;
                    animationLoopRunning = true;
                    lastFrameTime = performance.now();
                    requestAnimationFrame(animate);
                }

                function animate() {
                    if (window.visualFreezeActive) {
                        animationLoopRunning = false;
                        return;
                    }

                    // FPS Diagnostic
                    const now = performance.now();
                    const frameDelta = now - lastFrameTime;
                    lastFrameTime = now;
                    frameCount++;
                    fpsLogTimer += frameDelta;
                    if (fpsLogTimer > 3000) {
                        console.log(`[Performance] Avg FPS: ${(frameCount / 3).toFixed(1)}, Last Frame: ${frameDelta.toFixed(1)}ms`);
                        frameCount = 0;
                        fpsLogTimer = 0;
                    }

                    // Check Pause
                    if (window.gamePaused) {
                        requestAnimationFrame(animate);
                        return;
                    }

                    requestAnimationFrame(animate);

                    try {
                        const delta = clock ? Math.min(clock.getDelta(), 0.05) : 0.05; // Cap at 0.05 (20fps min) to prevent huge jumps
                        const time = clock ? clock.getElapsedTime() : (performance.now() / 1000);
                        const worldLockReason = getWorldInputLockReason();
                        const lookSuppressed = (!isReadingMode) && (!!worldLockReason || performance.now() < suppressWorldInputUntil);

                        if (!window.fallback2DMode) {
                            // Free Look
                            // If we have a 3D look target, smoothly rotate camera toward it
                            if (lookSuppressed) {
                                cameraLookTarget = null;
                                isLookingAtClickTarget = false;
                                syncLookTargetsToCamera();
                            } else if (cameraLookTarget) {
                                // Calculate direction from camera to 3D target point
                                const lookDir = new THREE.Vector3();
                                lookDir.subVectors(cameraLookTarget, camera.position).normalize();

                                // Calculate target yaw and pitch from direction
                                // Forward is -Z, so yaw = atan2(x, -z)
                                const targetYaw = Math.atan2(lookDir.x, -lookDir.z);
                                const targetPitch = Math.asin(-lookDir.y);

                                // Get current camera angles
                                euler.setFromQuaternion(camera.quaternion);

                                // EXTREMELY SLOW interpolation for gentle pan
                                const lookEase = 0.1 * delta;
                                euler.y += (targetYaw - euler.y) * lookEase;
                                euler.x += (targetPitch - euler.x) * lookEase;
                                euler.z = 0;

                                // Apply rotation
                                camera.quaternion.setFromEuler(euler);

                                // Update mouse.x/y to match current camera direction
                                // So swipe continues from current orientation
                                mouse.x = -euler.y / 1.5;
                                mouse.y = -euler.x / 0.5;
                                targetMouseX = mouse.x;
                                targetMouseY = mouse.y;

                                // Stop when close enough to target
                                if (Math.abs(targetYaw - euler.y) < 0.02 && Math.abs(targetPitch - euler.x) < 0.02) {
                                    cameraLookTarget = null;
                                }
                            } else if (isCenteringCamera) {
                                // Mobile Reading Mode Recenter
                                // Smoothly interpolate X to 0 and Yaw to 0

                                // 1. Position X -> 0
                                camera.position.x += (0 - camera.position.x) * 2.0 * delta;

                                // 2. Rotation Y -> 0 (Look Straight)
                                euler.setFromQuaternion(camera.quaternion);
                                // Shortest path angle
                                let diff = 0 - euler.y;
                                if (diff > Math.PI) diff -= Math.PI * 2;
                                if (diff < -Math.PI) diff += Math.PI * 2;

                                euler.y += diff * 2.0 * delta;
                                euler.x += (0 - euler.x) * 2.0 * delta; // Also level pitch
                                euler.z = 0;
                                camera.quaternion.setFromEuler(euler);

                                // Update mouse state to match
                                mouse.x = 0;
                                mouse.y = 0;
                                targetMouseX = 0;
                                targetMouseY = 0;

                                // Stop if close
                                if (Math.abs(camera.position.x) < 0.05 && Math.abs(diff) < 0.05) {
                                    isCenteringCamera = false;
                                }
                            } else {
                                // Normal mouse/swipe-based camera control
                                const targetPitch = -mouse.y * 0.5;
                                const targetYaw = -mouse.x * 1.5;
                                const ease = 5.0 * delta;
                                euler.setFromQuaternion(camera.quaternion);
                                euler.x += (targetPitch - euler.x) * ease;
                                euler.y += (targetYaw - euler.y) * ease;
                                euler.z = 0;
                                camera.quaternion.setFromEuler(euler);
                            }

                            // movement constants
                            // movement constants
                            // movement constants
                            // USER: REQUESTED 25% SLOWER than 200 => 150
                            const baseAccel = 150.0;
                            const gameSpeed = baseAccel * 0.15;
                            // Click Speed removed (Unified)

                            // SYNCED: Reading Speed = Game Speed
                            const readingSpeed = gameSpeed;

                            const isReading = isReadingMode; // Use global state

                            const input = new THREE.Vector3();

                            // 1. GLOBAL PHYSICS (Friction / Gravity) - Applied in BOTH modes
                            velocity.x -= velocity.x * 10.0 * delta;
                            velocity.z -= velocity.z * 10.0 * delta;
                            velocity.y -= 9.8 * 100.0 * delta;

                            if (isReading) {
                                // READING MODE: Auto-Walk Forward (Global Z)
                                // Ignore User Input
                                input.set(0, 0, -1); // Purely forward along hallway

                                // Auto-Center X (Smooth drift to 0)
                                // "Trgheit der Richtungsjustierung"
                                const centerX = 0;
                                const distToCenter = centerX - camera.position.x;
                                const centerForce = distToCenter * 0.5 * delta; // Adjust 0.5 for smoothness
                                camera.position.x += centerForce;

                                // Apply Velocity for Z
                                velocity.add(input.multiplyScalar(readingSpeed * delta));

                            } else {
                                // GAME MODE

                                // 2. Input Vectors

                                // 2. Input Vectors
                                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                                forward.y = 0; forward.normalize();
                                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                                right.y = 0; right.normalize();

                                input.set(0, 0, 0);
                                if (move.f) input.add(forward);
                                // if (move.b) input.sub(forward); // Backwards disabled in general config
                                if (move.r) input.add(right);
                                if (move.l) input.sub(right);

                                // 3. Apply Velocity (Manual vs Auto)
                                if (input.length() > 0) {
                                    input.normalize();
                                    velocity.add(input.multiplyScalar(gameSpeed * delta));
                                    // Cancel Auto-Move on manual input
                                    moveTarget = null;
                                    cameraLookTarget = null;
                                } else if (moveTarget) {
                                    // CLICK-TO-MOVE LOGIC
                                    const sinceUi = performance.now() - lastUiInteractionAt;
                                    const worldLockReason = getWorldInputLockReason();
                                    if (worldLockReason) {
                                        liminalDebugNote('move-skip', `loop-world-lock:${worldLockReason}`);
                                        liminalCause('C04_WORLD_BLOCKED_TOUCH', `loop-world-lock:${worldLockReason}`);
                                        moveTarget = null;
                                        cameraLookTarget = null;
                                        velocity.x = 0;
                                        velocity.z = 0;
                                    } else {
                                        if (sinceUi < UI_CLICK_SUPPRESS_MS + 50) {
                                            liminalCause('C06_MOVE_SET_RECENT_UI_WINDOW', `loop-consume sinceUi=${sinceUi.toFixed(0)}ms`);
                                        }
                                        const dx = moveTarget.x - camera.position.x;
                                        const dz = moveTarget.z - camera.position.z;
                                        const dist = Math.sqrt(dx * dx + dz * dz);

                                        // FIX: Stop Looking earlier to prevent swing/spin at singularity
                                        if (dist < 2.0) {
                                            cameraLookTarget = null;
                                        }

                                        if (dist < 0.2) {
                                            moveTarget = null;
                                            cameraLookTarget = null;
                                            velocity.set(0, 0, 0); // Full stop
                                            // Skip remaining movement logic this frame
                                        } else {
                                            const moveDir = new THREE.Vector3(dx, 0, dz).normalize();

                                            // UNIFIED SPEED: Use gameSpeed for click movement too.
                                            // Direct World Space addition (since velocity is World Space)
                                            velocity.add(moveDir.multiplyScalar(gameSpeed * delta));
                                        }
                                    }
                                }

                                // 4. Move Controls (Direct Physics Integration)
                                camera.position.x += velocity.x * delta;
                                camera.position.z += velocity.z * delta; // Allow forward/back calc first

                                // DISALLOW BACKWARDS MOVEMENT (Global +Z is "Back")
                                // User: "negative meter forbidden" / "backwards movement forbidden"
                                if (velocity.z > 0) velocity.z = 0;

                                // Prevent drifting back if position tries to increase
                                // (Double safety: clamp delta position change?)
                                // No, velocity clamp is smoother. But let's check position delta too just in case.
                                // Accessing last frame? No need, velocity controls it.

                                camera.position.y += (velocity.y * delta);

                                // 5. Floor Collision
                                if (camera.position.y < 1.6) {
                                    velocity.y = 0;
                                    camera.position.y = 1.6;
                                }

                                // 6. Wall Collision (Clamp X)
                                // Strictly clamp X to hallway bounds to prevent wall clipping
                                camera.position.x = Math.max(-2.5, Math.min(2.5, camera.position.x));
                            }

                            // Friction
                            velocity.multiplyScalar(1.0 - 5.0 * delta);
                            camera.position.add(velocity.clone().multiplyScalar(delta));

                            // HEAD BOBBING (Half speed, Half amplitude of previous)
                            // Previous: delta * 12, Amp 0.025
                            // New: delta * 6, Amp 0.0125
                            if (velocity.length() > 0.5) {
                                headBob += delta * 6;
                                camera.position.y = 1.6 + Math.sin(headBob) * 0.0125;
                            } else {
                                // Return to neutral
                                camera.position.y += (1.6 - camera.position.y) * 5.0 * delta;
                            }

                            // Dust Update (Global) - REMOVED
                            // if (dustSystem) ...

                            // Bounds
                            // Global Safety Clamp (Runs for both modes)
                            // Slightly wider than 1.8 to allow movement but prevent wall clipping
                            // Fixed at 1.95 (just before shelves at ~2.4)
                            if (camera.position.x < -1.95) camera.position.x = -1.95;
                            if (camera.position.x > 1.95) camera.position.x = 1.95;

                            updateSegments(camera.position.z);
                            segments.forEach(seg => {
                                // Unified update call
                                seg.update(delta, time, camera.position);
                            });

                            // Update Glowing Books and check proximity
                            activeGlowingBooks.forEach(book => {
                                if (!book.collected && !book.missed) {
                                    book.update(time, camera.position.z, camera.position.x);

                                    // Proximity collection check (ALWAYS allow, even if lore is playing - chaining!)
                                    if (true) {
                                        // FIX: Use WORLD position, not local position (meshGroup may have moved)
                                        const worldPos = new THREE.Vector3();
                                        book.mesh.getWorldPosition(worldPos);
                                        const distZ = Math.abs(worldPos.z - camera.position.z);
                                        const distX = Math.abs(worldPos.x - camera.position.x);
                                        const SCENE_NAME = 'liminal_library';
                                        const alreadyCollected = !!(
                                            window.GameState
                                            && typeof window.GameState.isLightCollected === 'function'
                                            && window.GameState.isLightCollected(SCENE_NAME, book.id)
                                        );

                                        // USER: Reduce distance to 1.5m (from 3) and 1.0m (from 2)
                                        if (distZ < 1.5 && distX < 1.0 && !alreadyCollected) {
                                            // Collect!
                                            book.collect();
                                            // Collect - use GameState for global lore tracking!
                                            // DON'T increment local counter - GameState handles which lore is next globally

                                            // Register in GameState (GLOBAL - same logic as marketplace)
                                            if (window.GameState && window.GameState.collectLight) {
                                                window.GameState.collectLight(SCENE_NAME, book.id).then(newLoreId => {
                                                    if (newLoreId) {
                                                        const now = Date.now();
                                                        if (now - lastShimmerAt > 400) {
                                                            lastShimmerAt = now;
                                                            shimmerSound.pause();
                                                            shimmerSound.currentTime = 0;
                                                            if (allowAuxSfxPlaybackLiminal()) {
                                                                shimmerSound.play().catch(() => { });
                                                            }
                                                        }
                                                        console.log("[GameState] Collected Book -> Unlocked Lore:", newLoreId);
                                                        // Refresh archive menu so new lore appears immediately
                                                        if (typeof renderArchive === 'function') renderArchive();
                                                        // Start lore audio with the GLOBAL lore ID (not local counter!)
                                                        startLoreMode(newLoreId);
                                                    } else {
                                                        // All lore already unlocked
                                                        console.log("All lore already unlocked");
                                                    }
                                                });
                                            }
                                        }
                                        // Check if player walked past without collecting (book is now behind player)
                                        // Use world position for this check too
                                        else if (worldPos.z > camera.position.z + 5) {
                                            // Missed! Mark as missed but don't count towards collection
                                            book.missed = true;
                                            book.mesh.visible = false;
                                            console.log(`Book ${book.id} missed (player walked past)`);
                                        }
                                    }
                                }
                            });


                            // Update Subtitles
                            // SharedAudioPlayer handles this internally via events, but for 3D sync we rely on DOM updates
                            // No manual render call needed if SharedAudioPlayer updates innerHTML
                            if (window.audioPlayer && window.audioPlayer.onTimeUpdate) {
                                // window.audioPlayer.onTimeUpdate(); // It binds to timeupdate event
                            }

                            if (renderer) renderer.render(scene, camera);

                            // Update Debug HUD
                            const debugEl = document.getElementById('debugHUD');
                            if (debugEl) {
                                const globalLore = getGlobalCollectedLoreCount();
                                debugEl.innerText = `Pos Z: ${camera.position.z.toFixed(2)} | Segments: ${segments.length} | Lore: ${globalLore}/5`;
                            }

                        } // end if (!window.fallback2DMode)
                    } catch (err) {
                        console.error("Animation Loop Crash:", err);
                    }
                }

                function workQueueSize() {
                    let count = 0;
                    // Not easily accessible, but we can verify performance
                    return "Active";
                }
                // animate(); // Moved to startGame()

                // --- MENU LOGIC ---
                const archiveModal = document.getElementById('archiveModal');
                const bookBtn = document.getElementById('bookBtn');
                const closeArchiveBtn = document.getElementById('closeArchiveBtn');
                const chapter1Btn = document.getElementById('chapter1Btn');
                const loreList = document.getElementById('loreList');

                // SAVE / LOAD LOGIC
                const btnSave = document.getElementById('btnSaveData');
                const btnLoad = document.getElementById('btnLoadData');
                const fileInput = document.getElementById('fileInputSave');

                if (btnSave) {
                    btnSave.addEventListener('click', () => {
                        if (!window.GameState) return;
                        const json = window.GameState.exportState();
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'liminal_save_' + Date.now() + '.json';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    });
                }

                if (btnLoad) {
                    btnLoad.addEventListener('click', () => {
                        if (fileInput) fileInput.click();
                    });
                }

                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            if (window.GameState) {
                                // Explicitly import via GameState
                                const success = await window.GameState.importState(ev.target.result);
                                if (success) {
                                    alert("Save Data Imported Successfully! Reloading...");
                                    window.location.reload();
                                } else {
                                    alert("Invalid Save File.");
                                }
                            }
                        };
                        reader.readAsText(file);
                    });
                }

                if (bookBtn) {
                    bookBtn.addEventListener('click', () => {
                        if (typeof renderArchive === 'function') renderArchive();
                        archiveModal.classList.add('visible');
                    });
                }
                if (closeArchiveBtn) {
                    closeArchiveBtn.addEventListener('click', () => {
                        archiveModal.classList.remove('visible');
                    });
                }
                if (chapter1Btn) {
                    chapter1Btn.addEventListener('click', async () => {
                        console.log("Returning to Chapter 1...");
                        await waitForContentSwitchIdle('chapter-menu:to-1');
                        await saveCurrentContentState({ reason: 'chapter-menu:to-1' });
                        markChapterAutoplayIntent('kapitel1', 'manual', 'chapter-menu');
                        writeStateHandoff('kapitel1');
                        window.location.href = 'index.html';
                    });
                }

                // Chapter 1b (Resume)
                const chapter1bBtn = document.getElementById('chapter1bBtn');
                if (chapter1bBtn) {
                    // Initialize visually
                    chapter1bBtn.classList.remove('locked');

                    chapter1bBtn.addEventListener('click', () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        if (isLoreMode) {
                            window.restoreMainAudio();
                        } else {
                            // Unpause if needed
                            if (player && player.audio && player.audio.paused) {
                                player.play();
                            }
                        }
                    });
                }

                // Chapter 1c
                const chapter1cBtn = document.getElementById('chapter1cBtn');
                if (chapter1cBtn) {
                    chapter1cBtn.addEventListener('click', async () => {
                        console.log("Going to Chapter 1c...");
                        await waitForContentSwitchIdle('chapter-menu:to-1c');
                        await saveCurrentContentState({ reason: 'chapter-menu:to-1c' });
                        markChapterAutoplayIntent('kapitel1c', 'manual', 'chapter-menu');
                        writeStateHandoff('kapitel1c');
                        window.location.href = 'index.html?chapter=kapitel1c';
                    });
                }
                function triggerUiHaptic(pattern = 8) {
                    if (typeof navigator === 'undefined' || typeof navigator.vibrate !== 'function') return;
                    navigator.vibrate(pattern);
                }
                // --- ARCHIVE TAB SWITCHING ---
                function initArchiveTabs() {
                    const tabs = Array.from(document.querySelectorAll('.archive-tab'));
                    const panels = Array.from(document.querySelectorAll('.archive-tab-content'));
                    const tabsBar = document.querySelector('.archive-tabs');
                    const archiveFooter = document.querySelector('#archiveModal .archive-footer');
                    const primaryInhaltBtn = document.getElementById('archivePrimaryInhaltBtn');
                    const primarySettingsBtn = document.getElementById('archivePrimarySettingsBtn');
                    const settingsPanel = document.querySelector('.archive-tab-content[data-tab="einstellungen"]');
                    let lastContentTab = 'kapitel';

                    const setPrimaryMode = (mode) => {
                        const normalized = mode === 'einstellungen' ? 'einstellungen' : 'inhalt';

                        if (primaryInhaltBtn) primaryInhaltBtn.classList.toggle('active', normalized === 'inhalt');
                        if (primarySettingsBtn) primarySettingsBtn.classList.toggle('active', normalized === 'einstellungen');
                        if (tabsBar) tabsBar.style.display = normalized === 'inhalt' ? '' : 'none';
                        if (archiveFooter) archiveFooter.style.display = normalized === 'inhalt' ? '' : 'none';
                    };

                    const showContentTab = (target, activeTab = null) => {
                        tabs.forEach((t) => t.classList.remove('active'));
                        panels.forEach((p) => p.classList.remove('active'));

                        const matchedTab = activeTab || tabs.find((t) => t.getAttribute('data-tab') === target) || null;
                        if (matchedTab) {
                            matchedTab.classList.add('active');
                            lastContentTab = matchedTab.getAttribute('data-tab') || lastContentTab;
                        }

                        const panel = document.querySelector(`.archive-tab-content[data-tab="${lastContentTab}"]`);
                        if (panel) panel.classList.add('active');
                        if (lastContentTab === 'lesezeichen') renderBookmarks();
                    };

                    const showSettingsPanel = () => {
                        tabs.forEach((t) => t.classList.remove('active'));
                        panels.forEach((p) => p.classList.remove('active'));
                        if (settingsPanel) settingsPanel.classList.add('active');
                        if (typeof syncReaderSettingsUi === 'function') syncReaderSettingsUi();
                    };

                    tabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            triggerUiHaptic(7);
                            tab.classList.remove('pressed');
                            // Force reflow so the press animation retriggers on repeated clicks.
                            void tab.offsetWidth;
                            tab.classList.add('pressed');
                            setTimeout(() => tab.classList.remove('pressed'), 170);
                            const target = tab.getAttribute('data-tab');
                            setPrimaryMode('inhalt');
                            showContentTab(target, tab);
                        });
                    });

                    if (primaryInhaltBtn) {
                        primaryInhaltBtn.addEventListener('click', () => {
                            triggerUiHaptic(7);
                            setPrimaryMode('inhalt');
                            showContentTab(lastContentTab);
                        });
                    }

                    if (primarySettingsBtn) {
                        primarySettingsBtn.addEventListener('click', () => {
                            triggerUiHaptic(7);
                            setPrimaryMode('einstellungen');
                            showSettingsPanel();
                        });
                    }

                    const initiallyActiveTab = tabs.find((tab) => tab.classList.contains('active'));
                    if (initiallyActiveTab) {
                        lastContentTab = initiallyActiveTab.getAttribute('data-tab') || 'kapitel';
                    }
                    setPrimaryMode('inhalt');
                    showContentTab(lastContentTab, initiallyActiveTab || undefined);
                }
                initArchiveTabs();

                // --- BOOKMARK RENDERING ---
                function renderBookmarks() {
                    const list = document.getElementById('bookmarkList');
                    if (!list) return;
                    list.innerHTML = '';

                    if (!window.GameState) return;
                    const bookmarks = window.GameState.getBookmarks();

                    if (bookmarks.length === 0) return;

                    bookmarks.forEach(bm => {
                        const item = document.createElement('div');
                        item.className = 'menu-item bookmark-item';

                        const mainText = document.createElement('div');
                        mainText.className = 'item-main-text';
                        const timeStr = window.GameState.formatBookmarkTime(bm.time);
                        mainText.innerText = `${bm.chapterTitle}  ${timeStr}`;

                        const subText = document.createElement('div');
                        subText.className = 'item-sub-text';
                        subText.innerText = bm.textPreview || '';

                        const delBtn = document.createElement('button');
                        delBtn.className = 'bookmark-delete-btn';
                        delBtn.innerHTML = '&times;';
                        delBtn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            await window.GameState.removeBookmark(bm.id);
                            renderBookmarks();
                        });

                        item.appendChild(mainText);
                        item.appendChild(subText);
                        item.appendChild(delBtn);

                        item.addEventListener('click', async () => {
                            document.getElementById('archiveModal').classList.remove('visible');
                            const targetPage = (typeof bm.page === 'string' && bm.page) ? bm.page : CURRENT_PAGE;
                            const targetContentKey = resolveBookmarkContentKey(bm);
                            const isLoreBookmark = /^lore\d+$/i.test(targetContentKey);
                            if (targetPage === CURRENT_PAGE || isLoreBookmark) {
                                const reason = isLoreBookmark
                                    ? `bookmark:${bm.id}:lore-local`
                                    : `bookmark:${bm.id}:same-page`;
                                const ready = await ensureBookmarkContentForCurrentPage(bm, reason);
                                if (!ready) {
                                    console.warn('[Bookmark] Could not activate target content on current page.', bm);
                                    return;
                                }
                                if (window.audioPlayer && window.audioPlayer.seekToTime) {
                                    await window.audioPlayer.seekToTime(bm.time, { autoplay: true });
                                }
                            } else {
                                await waitForContentSwitchIdle('bookmark:cross-page');
                                await saveCurrentContentState({ reason: 'bookmark:navigate' });
                                sessionStorage.setItem('bookmark_seek_target', JSON.stringify(bm));
                                const key = resolveBookmarkPageKey(targetPage);
                                markChapterAutoplayIntent(key, 'manual', 'bookmark');
                                writeStateHandoff(key);
                                window.location.href = targetPage;
                            }
                        });

                        list.appendChild(item);
                    });
                }

                function renderArchive() {
                    const list = document.getElementById('loreList');
                    list.innerHTML = '';

                    if (!window.GameState) return;

                    const db = window.GameState.getAllLore();
                    const collectedIds = window.GameState.state.collectedLore;

                    if (collectedIds.length > 0) {
                        collectedIds.sort((a, b) => a - b).forEach(id => {
                            const content = db[id];
                            if (!content) return;

                            const item = document.createElement('div');
                            item.className = 'menu-item';

                            // Active State
                            if (isLoreMode && activeLoreId === id) {
                                item.classList.add('active');
                            }

                            const mainText = document.createElement('div');
                            mainText.className = 'item-main-text';
                            mainText.innerText = content.title;

                            const subText = document.createElement('div');
                            subText.className = 'item-sub-text';
                            subText.innerText = content.duration;

                            item.appendChild(mainText);
                            item.appendChild(subText);

                            item.addEventListener('click', () => {
                                document.getElementById('archiveModal').classList.remove('visible');
                                startLoreMode(id);
                            });
                            list.appendChild(item);
                        });
                    }
                }

                // --- RESIZE HANDLER (Fixes Fullscreen FOV) ---
                window.addEventListener('resize', () => {
                    syncViewport();
                    console.log(`Resized to ${window.innerWidth}x${window.innerHeight}`);
                });
                window.addEventListener('orientationchange', syncViewport, { passive: true });
                document.addEventListener('fullscreenchange', syncViewport);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', syncViewport, { passive: true });
                    window.visualViewport.addEventListener('scroll', syncViewport, { passive: true });
                }


            } catch (err) {
                console.error("FATAL ERROR IN MODULE:", err);
            }
        })();
    </script>
</body>

</html>
