<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heidelberg RPG</title>
    <!-- SoundCloud Widget API & System -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="assets/js/SoundCloudURLs.js"></script>
    <script src="assets/js/shared-game-systems.js"></script>
    <script src="assets/js/PlayerStateManager.js"></script>
    <script src="assets/js/ChapterAutoplayIntent.js"></script>
    <script src="assets/js/AudioVisibilityManager.js"></script>
    <script src="assets/js/SCAudioAdapter.js"></script> <!-- Adapter AFTER Managers so it can register itself -->
    <script src="assets/js/GlobalVisualDimmer.js"></script>
    <!-- Main Stylesheet (extracted during refactoring) -->
    <link rel="stylesheet" href="assets/css/main.css">
    <!-- Critical inline CSS for loading screen (above-the-fold) -->
    <style>
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #444;
            font-family: 'Segoe UI', system-ui, sans-serif;
            transition: opacity 1s ease;
        }

        #loading-screen .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .subtitle-current {
            font-weight: 500 !important;
        }

        #subtitleRecenterBtn {
            position: fixed;
            top: -9999px;
            left: -9999px;
            display: none;
            pointer-events: auto;
            opacity: 0.92;
            z-index: 2600;
        }

        #subtitleRecenterBtn svg {
            width: 22px;
            height: 22px;
        }

        #subtitleRecenterMobileRadius {
            position: fixed;
            width: 500px;
            height: 500px;
            left: -9999px;
            top: -9999px;
            display: none;
            pointer-events: none;
            border: none;
            border-radius: 50%;
            background: transparent;
            box-shadow: none;
            z-index: 2598;
        }
    </style>
</head>

<body>



    <!-- LOADING SCREEN (über ALLEM) -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING...</p>
    </div>

    <!-- SVG Filter Definitionen -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1"
        xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- PAL Filter: Horizontal Blur + leichte Farbverschiebung -->
            <filter id="pal-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.6 0" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="
                    0.9 0.1 0.0 0 0
                    0.0 0.9 0.1 0 0
                    0.0 0.0 0.9 0 0
                    0   0   0   1 0" result="colored" />
            </filter>

            <!-- Glitch Filter: Turbulenz Displacement -->
            <!-- Glitch Filter: Turbulenz Displacement -->
            <filter id="glitch-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.002 0.005" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="baseFrequency" dur="60s" values="0.002 0.005;0.005 0.01;0.002 0.005"
                        repeatCount="indefinite" />
                    <animate attributeName="seed" dur="3s" values="0;100;0" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R"
                    yChannelSelector="G" />
            </filter>
        </defs>
    </svg>

    <!-- DropZone removed for Electron App -->

    <div id="processingInfo">
        <div class="spinner"></div>
        <div>Verarbeite Karte...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>

    <!-- MAIN GAME AREA -->
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="crtOverlay"></div>
    </div>

    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer">
            <!-- Dynamisch generierte Zeilen -->
        </div>

        <!-- Next Chapter Button (Hidden by default) -->
        <button id="nextChapterBtn">Weiter</button>

        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn" tabindex="-1">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" tabindex="-1">
                    <!-- Resize Book Button by ~20% (scale 0.8 or smaller SVG) -->
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                </button>

                <button id="readingModeBtn" class="audio-btn" title="Lesemodus aktivieren" tabindex="-1"
                    aria-label="Lesemodus aktivieren">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="sceneDimmerToggleBtn" class="audio-btn" title="Hintergrund abdunkeln" tabindex="-1"
                    aria-label="Hintergrunddimmer aus">
                    <svg id="sceneDimmerIconFull" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="8"></circle>
                        <circle cx="12" cy="12" r="6" fill="white" stroke="none"></circle>
                    </svg>
                    <svg id="sceneDimmerIconHalf" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="8"></circle>
                        <path d="M12 4a8 8 0 0 0 0 16z" fill="white" stroke="none"></path>
                    </svg>
                    <svg id="sceneDimmerIconCrescent" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <path d="M16.5 4.5A8 8 0 1 0 16.5 19A6.8 6.8 0 1 1 16.5 4.5Z" fill="white" stroke="white">
                        </path>
                    </svg>
                    <svg id="sceneDimmerIconSun" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="4" fill="white" stroke="none"></circle>
                        <path d="M12 2v3"></path>
                        <path d="M12 19v3"></path>
                        <path d="M2 12h3"></path>
                        <path d="M19 12h3"></path>
                        <path d="M4.9 4.9l2.1 2.1"></path>
                        <path d="M17 17l2.1 2.1"></path>
                        <path d="M19.1 4.9L17 7"></path>
                        <path d="M7 17l-2.1 2.1"></path>
                    </svg>
                </button>
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild" tabindex="-1">
                    <!-- ENTER FULLSCREEN (Corners pointing OUT) -->
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square">
                        <path d="M7 10V7h3" />
                        <path d="M17 10V7h-3" />
                        <path d="M17 14v3h-3" />
                        <path d="M7 14v3h3" />
                    </svg>
                    <!-- EXIT FULLSCREEN (Corners pointing IN) -->
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square" style="display:none;">
                        <path d="M4 14h6v6" />
                        <path d="M20 14h-6v6" />
                        <path d="M20 10h-6V4" />
                        <path d="M4 10h6V4" />
                    </svg>
                </button>
                <button id="subtitleRecenterBtn" class="audio-btn" title="Text auf aktuelle Stelle zentrieren"
                    aria-label="Text auf aktuelle Stelle zentrieren" tabindex="-1" type="button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 7h10" />
                        <path d="M3 12h10" />
                        <path d="M3 17h10" />
                        <path d="M14 12h7" />
                        <path d="M18 9l3 3-3 3" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <div id="sceneDimmerOverlay" aria-hidden="true"></div>

    <!-- ARCHIVE MODAL (INHALT) -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title">Inhalt</div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>

            <div class="archive-tabs">
                <button class="archive-tab active" data-tab="kapitel">Kapitel</button>
                <button class="archive-tab" data-tab="lore">Lore</button>
                <button class="archive-tab" data-tab="lesezeichen">Lesezeichen</button>
            </div>

            <div class="archive-tab-content active" data-tab="kapitel">
                <!-- KAPITEL -->
                <div class="col-left" id="chapterList" style="flex:1;">
                    <!-- Hardcoded Chapter 1 -->
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Der Marktplatz</div>
                    </div>

                    <!-- Chapter 1b -->
                    <div class="menu-item" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Liminal Library</div>
                    </div>

                    <!-- Chapter 1c -->
                    <div class="menu-item" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse</div>
                    </div>
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lore">
                <!-- LORE -->
                <div class="col-left" id="loreList" style="flex:1;">
                    <!-- Dynamisch gefüllt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lesezeichen">
                <!-- LESEZEICHEN -->
                <div id="bookmarkList" style="width:100%;">
                    <!-- Dynamisch gefüllt -->
                </div>
            </div>
            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; display: flex; gap: 20px; justify-content: center;">
                <button id="btnSaveData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">SAVE
                    (Export)</button>
                <button id="btnLoadData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">LOAD
                    (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <!-- Shared Game Systems (Particle, Cloud, YellowLight) for code sharing - LOADED IN HEAD -->

    <script>
        // ============================================
        // SETUP & FILTER LOGIK
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const controlsHint = document.getElementById('controlsHint');



        const processingInfo = document.getElementById('processingInfo');
        const gameWrapper = document.getElementById('gameWrapper');

        // PAL + CRT Effekte permanent aktiviert
        console.log("Applying Visual Fixes..."); // DEBUG
        gameWrapper.classList.add('effect-pal');
        gameWrapper.classList.add('effect-crt');

        // Turbulenz für Glitch laufend aktualisieren für "Randomness"
        // const turb = document.querySelector('#glitch-filter feTurbulence');
        // const disp = document.querySelector('#glitch-filter feDisplacementMap');

        // Glitch Loop: Manchmal stärker, manchmal schwächer
        // setInterval(() => {
        //     if (Math.random() > 0.95) {
        //         // Kurzer starker Glitch
        //         disp.setAttribute('scale', (Math.random() * 30 + 10).toString());
        //         turb.setAttribute('seed', Math.floor(Math.random() * 100).toString());
        //         setTimeout(() => {
        //             disp.setAttribute('scale', '4'); // Zurück zu subtil
        //         }, 100);
        //     }
        // }, 500);

        let gameReady = false;
        const SCENE_NAME = 'marktplatz'; // Added SCENE_NAME
        let bgImage = null;
        let foregroundImage = null;
        let spriteReady = false;
        let collisionData = [];   // true = Wand
        let foregroundData = [];  // true = Vordergrund (verdeckt Spieler)
        let flowData = [];        // true = Magischer Fluss (Grün)
        let magentaPixels = [];
        let cyanPixels = new Set();
        let greenPixels = [];     // Zum Verstecken
        let yellowLights = [];    // Lore Lights (Global)
        let autoWalkPath = [];
        let autoWalkIndex = 0;
        // isReadingMode is defined later in AUDIO & SUBTITLE SYSTEM

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================
        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        let GameState = null; // Will be loaded dynamically

        let mainAudioState = { time: 0, wasPlaying: false, tracks: [] };
        let activeLoreId = null;
        let activeLightSourceId = null;
        let isLoreMode = false;
        let isMenuTriggeredLore = false;
        let loreResumeTimeout = null;
        const MAIN_CONTENT_KEY = 'kapitel1';
        let contentSwitchInProgress = false;
        let contentSwitchToken = 0;
        const mainChapterAutoplayIntent = window.ChapterAutoplayIntent
            ? window.ChapterAutoplayIntent.consume(MAIN_CONTENT_KEY, { defaultPolicy: 'auto' })
            : { policy: 'auto', shouldAutoplay: true, source: 'fallback', reason: 'intent-missing' };

        function markChapterAutoplayIntent(targetPageKey, policy = 'auto', reason = '') {
            if (!window.ChapterAutoplayIntent || !targetPageKey) return;
            if (policy === 'manual') {
                window.ChapterAutoplayIntent.markManual(targetPageKey, MAIN_CONTENT_KEY, reason || 'chapter-menu');
                return;
            }
            window.ChapterAutoplayIntent.markAuto(targetPageKey, MAIN_CONTENT_KEY, reason || 'auto-transition');
        }

        const loreData = {
            audio: {},
            text: {},
            resumeTimes: {}
        };

        // ============================================
        // DEBUG (disabled in production UI)
        // ============================================
        const indexDebug = {
            lastSave: null
        };

        function indexDebugNote() { }

        function writeStateHandoff(targetPageKey) {
            try {
                if (!window.PlayerStateManager || typeof window.PlayerStateManager.exportStates !== 'function') return;
                const states = window.PlayerStateManager.exportStates();
                const payload = {
                    from: MAIN_CONTENT_KEY,
                    to: targetPageKey,
                    at: Date.now(),
                    states
                };
                sessionStorage.setItem('gb_state_handoff', JSON.stringify(payload));
                sessionStorage.setItem('gb_handoff_expect', String(targetPageKey || ''));
                indexDebugNote('handoff-out', `to=${targetPageKey} states=${Object.keys(states).length}`);
            } catch (e) {
                indexDebugNote('handoff-out-error', e && e.message ? e.message : String(e));
            }
        }

        function mergeIncomingStateHandoff(expectedTargetKey) {
            try {
                const raw = sessionStorage.getItem('gb_state_handoff');
                const expected = sessionStorage.getItem('gb_handoff_expect');
                if (!raw || !window.PlayerStateManager) {
                    if (expected && expected === expectedTargetKey) {
                        indexDebugNote('handoff-in-missing', `expected=${expectedTargetKey}`);
                        sessionStorage.removeItem('gb_handoff_expect');
                    }
                    return;
                }

                const payload = JSON.parse(raw);
                if (!payload || payload.to !== expectedTargetKey || !payload.states || typeof payload.states !== 'object') {
                    return;
                }

                let merged = 0;
                for (const [key, incoming] of Object.entries(payload.states)) {
                    if (!incoming || typeof incoming !== 'object') continue;
                    const current = window.PlayerStateManager.getState(key);
                    const incomingStamp = Number(incoming.lastUpdate || 0);
                    const currentStamp = Number((current && current.lastUpdate) || 0);
                    if (current && currentStamp > incomingStamp) continue;

                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: Number.isFinite(incoming.sentenceIndex) ? incoming.sentenceIndex : 0,
                            sentenceTime: Number.isFinite(incoming.sentenceTime) ? incoming.sentenceTime : 0,
                            wasPlaying: !!incoming.wasPlaying
                        });
                        merged++;
                    }
                }

                sessionStorage.removeItem('gb_state_handoff');
                sessionStorage.removeItem('gb_handoff_expect');
                indexDebugNote('handoff-in', `from=${payload.from || '-'} merged=${merged}`);
            } catch (e) {
                indexDebugNote('handoff-in-error', e && e.message ? e.message : String(e));
            }
        }

        mergeIncomingStateHandoff(MAIN_CONTENT_KEY);

        // Initialize GameState
        (async function initGameState() {
            try {
                const module = await import('./assets/js/GameState.js');
                GameState = module.GameState;
                window.GameState = GameState; // Global Ref
                await GameState.init();
                console.log("[Index] GameState Loaded & Initialized");

                // Populate loreData for compatibility (audio + text)
                const db = GameState.getAllLore();
                for (const [id, content] of Object.entries(db)) {
                    loreData.audio[id] = content.audio;
                    // Pre-fetch text for reliability
                    try {
                        const res = await fetch(content.text);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`[Init] Pre-loaded text for lore ${id}`);
                        }
                    } catch (e) {
                        console.warn(`[Init] Could not pre-load text for lore ${id}:`, e);
                    }
                }
            } catch (e) {
                console.error("Failed to load GameState:", e);
            }
        })();

        // kapitel1.mp3 als Haupt-Audio
        window.mainAudioUrl = 'assets/kapitel1.mp3';

        // Unlock Logic Wrapper
        async function unlockLoreItem(id) {
            if (!GameState) return;
            const newUnlock = await GameState.unlockLore(id);
            if (newUnlock) {
                const item = GameState.getLore(id);
                showNotification(`Eintrag freigeschaltet: ${item ? item.title : 'Unbekannt'}`);
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('controlsHint');
            if (el) {
                el.innerText = msg;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
        }

        // --- ARCHIVE TAB SWITCHING ---
        function initArchiveTabs() {
            const tabs = document.querySelectorAll('.archive-tab');
            const panels = document.querySelectorAll('.archive-tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    panels.forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    const target = tab.getAttribute('data-tab');
                    const panel = document.querySelector(`.archive-tab-content[data-tab="${target}"]`);
                    if (panel) panel.classList.add('active');
                    if (target === 'lesezeichen') renderBookmarks();
                });
            });
        }
        initArchiveTabs();

        // --- BOOKMARK RENDERING ---
        const CURRENT_PAGE = 'index.html';
        const CURRENT_CHAPTER = '1a';
        const CURRENT_CHAPTER_TITLE = 'Der Marktplatz';

        function renderBookmarks() {
            const list = document.getElementById('bookmarkList');
            if (!list) return;
            list.innerHTML = '';

            if (!window.GameState) return;
            const bookmarks = window.GameState.getBookmarks();

            if (bookmarks.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bookmark-empty-msg';
                empty.innerText = 'Keine Lesezeichen gesetzt';
                list.appendChild(empty);
                return;
            }

            bookmarks.forEach(bm => {
                const item = document.createElement('div');
                item.className = 'menu-item bookmark-item';

                const mainText = document.createElement('div');
                mainText.className = 'item-main-text';
                const timeStr = window.GameState.formatBookmarkTime(bm.time);
                mainText.innerText = `${bm.chapterTitle} · ${timeStr}`;

                const subText = document.createElement('div');
                subText.className = 'item-sub-text';
                subText.innerText = bm.textPreview || '';

                const delBtn = document.createElement('button');
                delBtn.className = 'bookmark-delete-btn';
                delBtn.innerHTML = '&times;';
                delBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await window.GameState.removeBookmark(bm.id);
                    renderBookmarks();
                });

                item.appendChild(mainText);
                item.appendChild(subText);
                item.appendChild(delBtn);

                item.addEventListener('click', async () => {
                    document.getElementById('archiveModal').classList.remove('visible');
                    if (bm.page === CURRENT_PAGE) {
                        await seekAndSyncSubtitle(bm.time, `bookmark:${bm.id}`);
                        if (audioPlayer.paused) {
                            try { await audioPlayer.play(); } catch (_) { }
                        }
                    } else {
                        await waitForContentSwitchIdle('bookmark:cross-page');
                        await saveCurrentContentState({ reason: 'bookmark:navigate' });
                        sessionStorage.setItem('bookmark_seek_target', JSON.stringify({
                            time: bm.time, id: bm.id
                        }));
                        const keyMap = {
                            'index.html': 'kapitel1',
                            'liminal library.html': 'liminal_library',
                            'index3.html': 'kapitel1c'
                        };
                        const key = keyMap[bm.page] || 'kapitel1';
                        markChapterAutoplayIntent(key, 'manual', 'bookmark');
                        writeStateHandoff(key);
                        window.location.href = bm.page;
                    }
                });

                list.appendChild(item);
            });
        }

        // --- MENU LOGIC ---
        function renderArchive() {
            const list = document.getElementById('loreList');
            list.innerHTML = '';

            if (!window.GameState) return;

            const db = window.GameState.getAllLore();
            const collectedIds = window.GameState.state.collectedLore;

            if (collectedIds.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'menu-item locked';
                empty.innerText = 'Keine Lore gefunden';
                list.appendChild(empty);
            } else {
                collectedIds.sort((a, b) => a - b).forEach(id => {
                    const content = db[id];
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'menu-item';

                    if (isLoreMode && activeLoreId === id) {
                        item.classList.add('active');
                    }

                    const mainText = document.createElement('div');
                    mainText.className = 'item-main-text';
                    mainText.innerText = content.title;

                    const subText = document.createElement('div');
                    subText.className = 'item-sub-text';
                    subText.innerText = content.duration;

                    item.appendChild(mainText);
                    item.appendChild(subText);

                    item.addEventListener('click', () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        startLoreMode(id, true);
                    });
                    list.appendChild(item);
                });
            }
            // (Chapter Logic continues inside renderArchive)

            // Chapter Logic (Left Column)
            const ch1 = document.getElementById('chapter1Btn');
            if (ch1) {
                const newCh1 = ch1.cloneNode(true);
                ch1.parentNode.replaceChild(newCh1, ch1);

                newCh1.addEventListener('click', () => {
                    console.log("Loading Chapter 1...");
                    document.getElementById('archiveModal').classList.remove('visible');

                    // 1. RE-LOAD MAP 'platz3.png' (Only if needed)
                    // If we are already here, do not reload map! 
                    // processMap(mapImg); // REMOVED to prevent reload

                    // 2. Audio Logic
                    if (isLoreMode) {
                        // If listening to Lore, switch back to Chapter
                        restoreMainAudio();
                    } else {
                        // If already in Chapter mode, maybe just unpause?
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        }
                    }
                });
            }

            // Chapter 1b Logic
            const ch1b = document.getElementById('chapter1bBtn');
            if (ch1b) {
                // Remove old listeners by cloning (if any exist spread from updates)
                const newCh1b = ch1b.cloneNode(true);
                ch1b.parentNode.replaceChild(newCh1b, ch1b);

                newCh1b.addEventListener('click', async () => {
                    console.log("Loading Chapter 1b...");
                    await waitForContentSwitchIdle('chapter-menu:to-1b');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1b' });
                    markChapterAutoplayIntent('liminal_library', 'manual', 'chapter-menu');
                    writeStateHandoff('liminal_library');
                    window.location.href = 'liminal library.html';
                });
            }

            // Chapter 1c Logic
            const ch1c = document.getElementById('chapter1cBtn');
            if (ch1c) {
                const newCh1c = ch1c.cloneNode(true);
                ch1c.parentNode.replaceChild(newCh1c, ch1c);

                newCh1c.addEventListener('click', async () => {
                    console.log("Loading Chapter 1c...");
                    await waitForContentSwitchIdle('chapter-menu:to-1c');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1c' });
                    markChapterAutoplayIntent('kapitel1c', 'manual', 'chapter-menu');
                    writeStateHandoff('kapitel1c');
                    window.location.href = 'index3.html';
                });
            }
        }

        // LEGACY - DEACTIVATED
        // LEGACY REMOVED

        // EVENT LISTENERS FOR ARCHIVE
        document.getElementById('bookBtn').addEventListener('click', () => {
            renderArchive();
            document.getElementById('archiveModal').classList.add('visible');
        });

        document.getElementById('closeArchiveBtn').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('visible');
        });

        // SAVE / LOAD LOGIC
        const btnSave = document.getElementById('btnSaveData');
        const btnLoad = document.getElementById('btnLoadData');
        const fileInput = document.getElementById('fileInputSave');

        if (btnSave) {
            btnSave.addEventListener('click', () => {
                if (!window.GameState) return;
                const json = window.GameState.exportState();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'liminal_save_' + Date.now() + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        if (btnLoad) {
            btnLoad.addEventListener('click', () => {
                if (fileInput) fileInput.click();
            });
        }

        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (window.GameState) {
                        const success = await window.GameState.importState(ev.target.result);
                        if (success) {
                            alert("Save Data Imported Successfully! Reloading...");
                            window.location.reload();
                        } else {
                            alert("Invalid Save File.");
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        // YellowLight class - now loaded from assets/js/shared-game-systems.js

        // Click-to-Move für Mobile
        let moveTarget = null; // {x, y} oder null

        // ============================================
        // PARTIKEL SYSTEM
        // ============================================
        const particles = [];
        const NUM_PARTICLES = 300; // Reduziert um 50%
        let particleSprite = null;

        // Spotlight-System: Sammelt Lichtquellen mit Richtung und Intensität
        let nearbyLights = []; // {x, y, intensity}

        // Dust-Particles: Staubwolken beim Laufen
        const dustParticles = [];

        // Screen-Shake bei Kollision
        let screenShake = 0;

        // Wolken-System (Parallax, selten)
        const clouds = [];
        const MAX_CLOUDS = 3;
        let cloudSpawnTimer = 0;

        // Cloud class and initClouds() - now loaded from assets/js/shared-game-systems.js

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        const footstepSound = new SCAudioAdapter();
        footstepSound.src = getSCUrl('assets/footsteps.mp3');
        footstepSound.volume = 0.024; // +20% from 0.02

        const shimmerSound = new SCAudioAdapter();
        shimmerSound.src = getSCUrl('assets/shimmer.mp3');
        shimmerSound.volume = 0.4;
        // One-shot SFX should not auto-resume after visibility changes.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(shimmerSound);
        }
        let lastShimmerLightId = null;
        let footstepPlaying = false;

        let audioUnlocked = false;

        // createGlowSprite(), Particle class, and initParticles()
        // now loaded from assets/js/shared-game-systems.js

        // ============================================
        // LORE PERSISTENCE - Uses GameState module
        // ============================================
        // NOTE: LoreSystem object was REMOVED (redundant with GameState.js)
        // All lore persistence is now handled by GameState:
        // - GameState.unlockLore(id) - unlock a lore entry
        // - GameState.isUnlocked(id) - check if unlocked
        // - GameState.collectLight(sceneName, lightId) - mark light as collected
        // - GameState.isLightCollected(sceneName, lightId) - check light status


        let mapW = 0, mapH = 0;

        // Dynamische Auflösung
        let SCREEN_W = 320;
        let SCREEN_H = 240;

        function updateDimensions() {
            // Robust Responsive Logic
            // Aim for maintaining pixel density while filling the screen.
            // Base resolution reference: 320x240 (4:3)

            const targetRatio = 320 / 240; // 1.333
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const winRatio = winW / winH;

            if (winRatio > targetRatio) {
                // Window is wider than 4:3 (Landscape / Wide)
                // Fix Height at 240, expand Width
                SCREEN_H = 240;
                SCREEN_W = Math.ceil(SCREEN_H * winRatio);
            } else {
                // Window is taller/narrower than 4:3 (Portrait / Square)
                // Fix Width at 320, expand Height
                SCREEN_W = 320;
                SCREEN_H = Math.ceil(SCREEN_W / winRatio);
            }

            // Canvas Größe aktualisieren
            if (canvas) {
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;
            }
            console.log(`Resolution updated: ${SCREEN_W}x${SCREEN_H} (Win: ${winW}x${winH}, Ratio: ${winRatio.toFixed(2)})`);
        }

        // Initial und bei Resize
        // Initial resize
        updateDimensions(); // Keep the original initial call
        window.addEventListener('resize', () => { // Keep the original resize listener
            updateDimensions();
            // Auch Subtitles neu rendern falls nötig
            if (isReadingMode && subtitleTracks.length > 0) {
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // --- VISUAL CALIBRATION TOOL ---
        let params = {
            brightness: 1.15,
            contrast: 1.10,
            saturate: 0.85
        };
        let activeParam = 'brightness';

        const dispBrit = document.getElementById('dispBrit');
        const dispCont = document.getElementById('dispCont');
        const dispSat = document.getElementById('dispSat');
        const dispSel = document.getElementById('dispSel');
        const debugCanvas = document.getElementById('gameCanvas');

        window.addEventListener('keydown', (e) => {
            // Select Parameter (only if debug elements exist)
            if (e.key === '1') { activeParam = 'brightness'; if (dispSel) dispSel.innerText = 'Brightness'; }
            if (e.key === '2') { activeParam = 'contrast'; if (dispSel) dispSel.innerText = 'Contrast'; }
            if (e.key === '3') { activeParam = 'saturate'; if (dispSel) dispSel.innerText = 'Saturation'; }

            // Adjust
            if (e.key === '+' || e.key === 'Add' || e.key === '=') {
                params[activeParam] = Math.round((params[activeParam] + 0.05) * 100) / 100;
                updateVisuals();
            } else if (e.key === '-' || e.key === 'Subtract' || e.key === '_') {
                params[activeParam] = Math.round((params[activeParam] - 0.05) * 100) / 100;
                updateVisuals();
            }
        });

        function updateVisuals() {
            // Apply override to canvas
            // Standard PAL structure
            if (debugCanvas) debugCanvas.style.filter = `url(#pal-filter) contrast(${params.contrast}) brightness(${params.brightness}) saturate(${params.saturate})`;

            if (dispBrit) dispBrit.innerText = params.brightness.toFixed(2);
            if (dispCont) dispCont.innerText = params.contrast.toFixed(2);
            if (dispSat) dispSat.innerText = params.saturate.toFixed(2);

            console.log(`Params: B=${params.brightness}, C=${params.contrast}, S=${params.saturate}`);
        }
        // Initialize with default values once to ensure UI matches
        // updateVisuals();
        // End of VISUAL CALIBRATION TOOL

        let camX = 0, camY = 0;
        let targetCamX = 0, targetCamY = 0;

        // Sprite Sheet Konfiguration
        const SPRITE = {
            frameWidth: 0,   // Wird berechnet
            frameHeight: 0,  // Wird berechnet
            cols: 4,         // 4 Frames pro Reihe
            baseScale: 0.15, // Original Skalierung
            scale: 0.15      // Dynamische Skalierung
        };

        // Spieler
        const player = {
            x: 50, y: 50,
            w: 14, h: 8,      // Kollisionsbox (Füße)
            speed: 35,        // Pixels per second (was 0.54 per frame)
            dir: 0,           // 0=down, 1=up, 2=left, 3=right
            frame: 0,         // 0-3 für Animation
            animTimer: 0,
            isMoving: false,
            isBehindForeground: false
        };

        const keys = {};

        // ============================================
        // SPRITES LADEN (alle 4 Richtungen)
        // ============================================
        let spriteFront = null;   // Frontalansicht (down)
        let spriteBack = null;    // Rückenansicht (up)
        let spriteSide = null;    // Seitenansicht (right, links wird gespiegelt)
        let spritesLoaded = 0;
        const TOTAL_SPRITES = 3;

        function loadAllSprites() {
            // Frontal (nach unten schauend, NEU: spriteneu.png)
            spriteFront = new Image();
            spriteFront.onload = function () {
                // WICHTIG: Math.floor() für ganzzahlige Frame-Breite!
                SPRITE.frameWidth = Math.floor(this.width / SPRITE.cols); // Fallback-Wert, wird für DrawCoords überschrieben
                SPRITE.frameHeight = this.height;
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log(`Sprite Front (New) geladen: ${this.width}x${this.height}`);
            };
            spriteFront.src = 'assets/spriteneu.png';
            spriteFront.onerror = () => console.warn('assets/spriteneu.png nicht gefunden');

            // Rücken (nach oben schauend, NEU: spriterueckenneu.png)
            spriteBack = new Image();
            spriteBack.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Back (New) geladen');
            };
            spriteBack.src = 'assets/spriterueckenneu.png';
            spriteBack.onerror = () => console.warn('assets/spriterueckenneu.png nicht gefunden');

            // Seitlich (für rechts, links wird gespiegelt)
            spriteSide = new Image();
            spriteSide.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Side (New) geladen');
            };
            spriteSide.src = 'assets/seitlichneu.png';
            spriteSide.onerror = () => console.warn('assets/seitlichneu.png nicht gefunden');
        }

        // Front (spriteneu.png)
        const FRONT_SPRITE_DATA = [
            { left: 38, width: 141, footX: 106, footY: 267 },
            { left: 201, width: 138, footX: 273, footY: 265 },
            { left: 361, width: 140, footX: 436, footY: 270 },
            { left: 534, width: 137, footX: 604, footY: 268 }
        ];
        // Ping-Pong Animation für Front (0-1-2-3-2-1)
        const FRONT_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        // Back (spriterueckenneu.png)
        const BACK_SPRITE_DATA = [
            { left: 16, width: 147, footX: 90, footY: 282 },
            { left: 177, width: 144, footX: 253, footY: 283 },
            { left: 336, width: 152, footX: 417, footY: 285 }
        ];
        // Ping-Pong Animation für Back (0-1-2-1)
        const BACK_ANIM_CYCLE = [0, 1, 2, 1];

        // NEU: Marker-Daten für seitlichneu.png (X, Y)
        const SIDE_SPRITE_DATA = [
            { left: 20, footX: 92, footY: 275 },
            { left: 200, footX: 268, footY: 281 },
            { left: 372, footX: 440, footY: 280 },
            { left: 528, footX: 595, footY: 284 }
        ];

        // Ping-Pong Animation für Seitlich (0-1-2-3-2-1)
        const SIDE_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        function checkAllSpritesLoaded() {
            if (spritesLoaded >= TOTAL_SPRITES) {
                spriteReady = true;
                console.log('Alle Sprites geladen!');
            }
        }

        // DEBUG HELPER
        window.logDebug = function (msg) {
            console.log("[DEBUG]", msg);
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML += msg + "<br>";
                const lines = d.innerHTML.split("<br>");
                if (lines.length > 6) d.innerHTML = lines.slice(lines.length - 6).join("<br>");
            }
        };

        window.addEventListener('load', () => {
            const pal = document.getElementById('pal-filter');
            const glitch = document.getElementById('glitch-filter');
            logDebug("Filters: PAL=" + (pal ? "OK" : "NO") + " GLITCH=" + (glitch ? "OK" : "NO"));

            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const style = window.getComputedStyle(canvas);
                const filter = style.getPropertyValue('filter');
                logDebug("Canvas Filter: " + ((filter && filter !== 'none') ? "ACTIVE" : "NONE"));
            }
        });

        loadAllSprites();

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // GLOBAL ERROR HANDLER (DEBUG)
        // ============================================
        window.onerror = function (msg, url, line, col, error) {
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.style.display = 'block';
                pi.style.color = '#ff5555';
                pi.style.background = 'rgba(0,0,0,0.9)';
                pi.innerText += "\nERROR: " + msg + "\nLine: " + line;
            }
            console.error(msg, error);
            return false;
        };

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        window.addEventListener('DOMContentLoaded', async () => {
            console.log("Electron Mode: Auto-Loading...");

            // 0. IMMEDIATE AUDIO PRELOAD (User Request: Buffer early)
            // WRAPPED IN TRY-CATCH TO PREVENT CRASHING THE LOADING SCREEN
            try {
                const mainAudioSrc = 'assets/kapitel1.mp3';
                window.mainAudioUrl = mainAudioSrc;
                if (typeof getSCUrl === 'function' && typeof audioPlayer !== 'undefined') {
                    const scUrl = getSCUrl(mainAudioSrc);
                    audioPlayer.src = scUrl;
                    if (audioPlayer.mode === 'html5' && audioPlayer.audioNode) {
                        audioPlayer.audioNode.preload = "auto";
                        // audioPlayer.audioNode.load(); // Reduced aggression to prevent hang
                        console.log("Audio Preloading Configured (Lazy)");
                    }
                } else {
                    console.warn("AudioPlayer or getSCUrl not ready yet.");
                }
            } catch (e) {
                console.warn("Audio Preload Failed (Non-Fatal):", e);
            }

            // RESTORE READING MODE STATE
            const savedMode = localStorage.getItem('gameboy_reading_mode');
            if (savedMode === 'true') {
                isReadingMode = true;
                const ui = document.getElementById('audioPlayerUI');
                if (ui) ui.classList.add('reading-mode');
            }
            // Load watchdog: never start the game loop without a loaded map.
            const loadingScreen = document.getElementById('loading-screen');
            const processingInfo = document.getElementById('processingInfo');
            const dropZone = document.getElementById('dropZone');

            setTimeout(() => {
                if (gameReady) return;

                console.warn("Map still not ready after 10s. Waiting for map load instead of force-start.");
                if (dropZone && !dropZone.classList.contains('hidden')) dropZone.classList.add('hidden');

                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ffd54a';
                    processingInfo.style.background = 'rgba(0,0,0,0.75)';
                    processingInfo.innerText = 'Map is still loading... please wait.';
                }

                if (loadingScreen) loadingScreen.style.display = 'flex';
            }, 10000);

            // 1. Load Map (Default)
            const mapImg = new Image();
            mapImg.onload = () => {
                console.log("Map Loaded, processing...");
                try {
                    processMap(mapImg);
                } catch (e) {
                    console.error("Critical: processMap crashed!", e);
                }
            };
            mapImg.onerror = (e) => {
                console.error("Map Load Error", e);
                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ff5555';
                    processingInfo.style.background = 'rgba(0,0,0,0.85)';
                    processingInfo.innerText = 'Map failed to load. Please reload the page.';
                }
                if (loadingScreen) loadingScreen.style.display = 'flex';
            };
            mapImg.src = 'assets/platz3.png';

            // 2. Load Audio & Text (Chapter 1) -> Audio already preloaded above!
            // const mainAudioSrc = 'assets/kapitel1.mp3'; // Removed redundant def

            const attemptAutoPlay = async () => {
                if (!mainChapterAutoplayIntent.shouldAutoplay) {
                    indexDebugNote('autoplay', `suppressed policy=${mainChapterAutoplayIntent.policy} reason=${mainChapterAutoplayIntent.reason}`);
                    syncPlayPauseIcon();
                    return false;
                }
                const started = await verifyPlaybackStarted(3, 320);
                indexDebugNote('autoplay', `boot started=${started} source=${mainChapterAutoplayIntent.source} reason=${mainChapterAutoplayIntent.reason}`);
                syncPlayPauseIcon();
                return started;
            };

            try {
                // debugLog('Fetching kapitel1.txt...');
                const response = await fetch('assets/kapitel1.txt');
                // debugLog('Fetch response: ' + response.status);
                const text = await response.text();
                // debugLog('Text length: ' + text.length);
                window.mainTextContent = text;
                parseSubtitles(text);
                // debugLog('subtitleTracks: ' + subtitleTracks.length);
                renderSubtitleLines(0);
                // debugLog('Chapter 1 Loaded OK');

                await attemptAutoPlay();

                // --- BOOKMARK SEEK ON LOAD ---
                const bmTarget = sessionStorage.getItem('bookmark_seek_target');
                if (bmTarget) {
                    sessionStorage.removeItem('bookmark_seek_target');
                    try {
                        const { time } = JSON.parse(bmTarget);
                        if (typeof time === 'number' && time > 0) {
                            console.log(`[Bookmark] Seeking to bookmarked time: ${time}s`);
                            setTimeout(async () => {
                                await seekAndSyncSubtitle(time, 'bookmark:on-load');
                                if (audioPlayer.paused) {
                                    try { await audioPlayer.play(); } catch (_) { }
                                }
                                syncPlayPauseIcon();
                            }, 800);
                        }
                    } catch (e) {
                        console.warn('[Bookmark] Failed to parse seek target:', e);
                    }
                }
            } catch (e) {
                debugLog('Chapter 1 Load ERROR: ' + e.message);
                window.mainTextContent = "";
                subtitleTracks = [];
            }

            // 2b. Preload Lore 1 Text
            try {
                const lRes = await fetch('assets/lore1.txt');
                loreData.text[1] = await lRes.text();
                console.log("Lore 1 Loaded");
            } catch (e) {
                console.error("Lore 1 Text Load Error:", e);
                loreData.text[1] = "";
            }

            // Always show UI
            if (typeof uiContainer !== 'undefined' && uiContainer) uiContainer.style.display = 'flex';

            // 3. Load Save Game
            // Handled by generic GameState.init() called at top of script
            // if (window.electronAPI) { ... }
        });

        // Helper for manual image loading (optional debugging)
        function loadImageFile(file) {
            processingInfo.style.display = 'block';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => setTimeout(() => processMap(img), 50);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // KEYBOARD
        // ============================================
        // Toggle State
        let usePAL = true;
        let useHalftone = true;

        function updateFilterStyle() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;

            let filters = [];
            if (usePAL) filters.push('url(#pal-filter)');
            // Halftone is usually a CSS class or overlay?
            // If it's the SVG glitch:
            if (useHalftone) filters.push('url(#glitch-filter)');
            // Note: Halftone dots is often a CSS overlay DIV, not SVG filter.
            // But user said "2" -> halftone dots.
            // I'll check if there is a .halftone class.
            // If not, I'll toggle the GLITCH filter (since "Glitch=NO" was the issue).

            canvas.style.filter = filters.join(' ');

            // Also update Debug
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML = `Filters: PAL=${usePAL ? 'ON' : 'OFF'} GLITCH=${useHalftone ? 'ON' : 'OFF'}<br>CANVAS: ${canvas.style.filter}`;
            }
        }

        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
                // CRITICAL FIX: Ensure Audio Player NEVER has focus, preventing "fast forward"
                // if (audioPlayer) audioPlayer.blur();
                document.body.focus();
            }
            // TOGGLES
            if (e.key === '1') { usePAL = !usePAL; updateFilterStyle(); }
            if (e.key === '2') { useHalftone = !useHalftone; updateFilterStyle(); }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            // Tastendruck bricht Click-to-Move ab
            moveTarget = null;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Click-to-Move für Mobile
        function handleClickMove(screenX, screenY) {
            if (!gameReady) return;

            // Berechne Welt-Koordinaten aus Screen-Koordinaten
            const rect = canvas.getBoundingClientRect();
            // CSS-Pixel zu Canvas-Pixel Umrechnung
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;

            // Welt-Position = Canvas-Position + Kamera-Offset
            const worldX = canvasX + camX;
            const worldY = canvasY + camY;

            // Setze Ziel (Spieler-Mitte soll dort hin)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            moveTarget = {
                x: worldX - spriteW / 2,
                y: worldY - spriteH / 2
            };
        }

        canvas.addEventListener('click', e => {
            // Guard: Ignore if clicking UI buttons (propagated events)
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            handleClickMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            // Guard: Ignore if touching UI
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            e.preventDefault();
            if (e.touches.length > 0) {
                handleClickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // ============================================
        // MAP PROCESSING
        // ============================================
        // ============================================
        // MAP PROCESSING (NUCLEAR FALLBACK VERSION)
        // ============================================
        // ============================================
        // MAP PROCESSING (ADVANCED RESTORED)
        // ============================================

        // --- AUTO-WALK PATH SORTER (Pure Nearest Neighbor) ---
        // Immer den ALLERNÄCHSTEN Pixel. Keine Bereiche, keine Schwellen.
        function sortAutoWalkPath(pixels, startPoint) {
            if (pixels.length === 0) return [];

            const path = [];
            let pool = [...pixels];

            // 1. Startpunkt: Der Pixel, der am nächsten zum Spawn liegt.
            let minDistSq = Infinity;
            let startIndex = -1;

            for (let i = 0; i < pool.length; i++) {
                const dx = pool[i].x - startPoint.x;
                const dy = pool[i].y - startPoint.y;
                const dSq = dx * dx + dy * dy;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    startIndex = i;
                }
            }

            if (startIndex === -1) return [];

            let current = pool.splice(startIndex, 1)[0];
            path.push(current);

            // 2. Stur: Immer den ALLERNÄCHSTEN noch nicht besuchten Pixel wählen.
            while (pool.length > 0) {
                let bestIndex = -1;
                let bestDistSq = Infinity;

                for (let i = 0; i < pool.length; i++) {
                    const dx = pool[i].x - current.x;
                    const dy = pool[i].y - current.y;
                    const dSq = dx * dx + dy * dy;

                    if (dSq < bestDistSq) {
                        bestDistSq = dSq;
                        bestIndex = i;
                    }
                }

                // Immer nehmen, egal wie weit weg.
                if (bestIndex !== -1) {
                    current = pool.splice(bestIndex, 1)[0];
                    path.push(current);
                } else {
                    break;
                }
            }

            console.log(`Auto-Walk Path (Pure Nearest): ${path.length} nodes.`);
            return path;
        }

        function processMap(img) {
            console.log("Processing Map (Advanced):", img.width, "x", img.height);
            mapW = img.width;
            mapH = img.height;

            SCREEN_W = Math.min(mapW, window.innerWidth);
            SCREEN_H = Math.min(mapH, window.innerHeight);
            canvas.width = SCREEN_W;
            canvas.height = SCREEN_H;

            // VISUAL DEBUG
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.innerText = "PROCESSING PIXELS...";
                pi.style.display = 'block';
            }

            // ATTEMPT PIXEL PROCESSING
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapW;
                tempCanvas.height = mapH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imgData = tempCtx.getImageData(0, 0, mapW, mapH);
                const data = imgData.data;

                // 1. Initialisieren der Arrays
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                foregroundData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                flowData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));

                magentaPixels = [];
                cyanPixels = new Set();
                greenPixels = [];
                greenPixels = [];
                let orangePixels = []; // For Auto-Walk
                yellowLights = []; // Init global var
                let spawnPixel = null;

                // 2. Scan-Pass
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const i = (y * mapW + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Magenta = Kollision
                        if (r > 200 && g < 80 && b > 200) {
                            collisionData[y][x] = true;
                            magentaPixels.push({ x, y, i });
                        }
                        // Cyan = Vordergrund
                        else if (r < 80 && g > 200 && b > 200) {
                            cyanPixels.add(`${x},${y}`);
                        }
                        // Grün = Flow (Lichter)
                        else if (r < 80 && g > 200 && b < 80) {
                            flowData[y][x] = true;
                            greenPixels.push({ x, y, i });
                        }
                        // GELB = Lore Trigger (#FFFF00)
                        else if (r > 250 && g > 250 && b < 10) {
                            const id = yellowLights.length + 1;
                            yellowLights.push(new YellowLight(x, y, id));
                        }
                        // BLAU = Spawn Punkt (#0000FF)
                        else if (r < 50 && g < 50 && b > 200) {
                            if (!spawnPixel) spawnPixel = { x, y, i };
                        }
                        // ORANGE = Auto-Walk Pfad (#FFA500 -> R>240, G~165, B<50)
                        else if (r > 240 && g > 130 && g < 200 && b < 50) {
                            orangePixels.push({ x, y, i });
                        }
                    }
                }

                // 3. Flood Fill Cyan
                if (cyanPixels.size > 0) findEnclosedAreas(cyanPixels, mapW, mapH);

                // 4. Pixel Hiding (Flow, Lore, Spawn)
                // Use pullNearbyPixel to hide the debug colors

                // 5. Magenta Cleanup & Wall Dilatation (Robust Collision)
                const extraWalls = [];
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (collisionData[y][x]) {
                            if (x > 0) extraWalls.push({ x: x - 1, y: y });
                            if (x < mapW - 1) extraWalls.push({ x: x + 1, y: y });
                            if (y > 0) extraWalls.push({ x: x, y: y - 1 });
                            if (y < mapH - 1) extraWalls.push({ x: x, y: y + 1 });
                        }
                    }
                }
                for (const w of extraWalls) {
                    collisionData[w.y][w.x] = true;
                }

                // Restore Magenta Pixels visually
                for (const mp of magentaPixels) {
                    const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                    data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;
                }
                for (const gp of greenPixels) {
                    const repl = pullNearbyPixel(data, gp.x, gp.y, mapW, mapH, cyanPixels);
                    data[gp.i] = repl.r; data[gp.i + 1] = repl.g; data[gp.i + 2] = repl.b;
                }
                for (const yl of yellowLights) {
                    const i = (yl.y * mapW + yl.x) * 4;
                    const repl = pullNearbyPixel(data, yl.x, yl.y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }
                if (spawnPixel) {
                    const repl = pullNearbyPixel(data, spawnPixel.x, spawnPixel.y, mapW, mapH, cyanPixels);
                    data[spawnPixel.i] = repl.r; data[spawnPixel.i + 1] = repl.g; data[spawnPixel.i + 2] = repl.b;
                }

                // 4b. Process Auto-Walk Path
                if (orangePixels.length > 0) {
                    // Sort path starting from spawn (or map center)
                    const startRef = spawnPixel || { x: mapW / 2, y: mapH / 2 };

                    // Direct Sort (Strict 1px)
                    autoWalkPath = sortAutoWalkPath(orangePixels, startRef);
                    autoWalkIndex = 0;

                    // Hide Orange Pixels
                    for (const op of orangePixels) {
                        const repl = pullNearbyPixel(data, op.x, op.y, mapW, mapH, cyanPixels);
                        data[op.i] = repl.r; data[op.i + 1] = repl.g; data[op.i + 2] = repl.b;
                    }
                }

                // 5. Magenta Cleanup
                // Multi-pass to fill large magenta areas from outside in
                let remainingMagenta = [...magentaPixels];
                const maxPasses = 10;
                for (let pass = 0; pass < maxPasses && remainingMagenta.length > 0; pass++) {
                    const stillRemaining = [];
                    for (const mp of remainingMagenta) {
                        const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                        // If result is the fallback gray (60,55,50), it means no neighbor found yet
                        // But wait, pullNearbyPixel returns fallback if nothing found. 
                        // We need a way to know if it found something good. 
                        // For now, let's just accept the replacement. The loop is fine.
                        data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;

                        // Heuristic: If we are deep inside magenta, we might get gray. 
                        // Ideally we want to wait for neighbors. But this is fast enough.
                    }
                    remainingMagenta = []; // Assume processed (simplification for speed)
                }

                // 6. Cyan Cleanup
                for (const cp of cyanPixels) {
                    const [x, y] = cp.split(',').map(Number);
                    const i = (y * mapW + x) * 4;
                    const repl = pullNearbyPixel(data, x, y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }

                // 7. Create Foreground/Background Layers
                const bgData = new Uint8ClampedArray(data);
                const fgData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < fgData.length; i += 4) fgData[i + 3] = 0; // Clear Alpha

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (foregroundData[y][x]) {
                            const i = (y * mapW + x) * 4;
                            fgData[i] = data[i];
                            fgData[i + 1] = data[i + 1];
                            fgData[i + 2] = data[i + 2];
                            fgData[i + 3] = 255;
                        }
                    }
                }

                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = mapW; bgCanvas.height = mapH;
                bgCanvas.getContext('2d').putImageData(new ImageData(bgData, mapW, mapH), 0, 0);

                const fgCanvas = document.createElement('canvas');
                fgCanvas.width = mapW; fgCanvas.height = mapH;
                fgCanvas.getContext('2d').putImageData(new ImageData(fgData, mapW, mapH), 0, 0);

                bgImage = new Image();
                foregroundImage = new Image();

                bgImage.onload = () => {
                    gameReady = true;
                    if (document.getElementById('processingInfo')) document.getElementById('processingInfo').style.display = 'none';
                    if (document.getElementById('dropZone')) document.getElementById('dropZone').classList.add('hidden');
                    // Hide Loading Screen
                    const ls = document.getElementById('loading-screen');
                    if (ls) ls.style.display = 'none';

                    if (spawnPixel) {
                        // FIX: Blue pixel marks FOOT position, not sprite top
                        // Robust: use the same spriteH logic as checkCollisionAt

                        // 1. Update scale for spawn depth (initial guess)
                        if (mapH > 0) {
                            const yNorm = Math.max(0, Math.min(1, spawnPixel.y / mapH));
                            const depthFactor = 0.5 + (0.8 * yNorm);
                            SPRITE.scale = SPRITE.baseScale * depthFactor;
                        }

                        const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                        const FOOT_OFFSET_Y = 15; // Must match checkCollisionAt

                        player.x = spawnPixel.x - 8; // Center horizontally
                        player.y = spawnPixel.y - spriteH - FOOT_OFFSET_Y; // Feet at spawnPixel.y

                        console.log(`Spawn: Blue(${spawnPixel.x},${spawnPixel.y}) -> Feet at Y=${spawnPixel.y}, SpriteH=${spriteH.toFixed(1)}, Player.y=${player.y.toFixed(1)}`);
                    } else {
                        player.x = mapW / 2;
                        player.y = mapH / 2;
                    }

                    // Center Camera
                    camX = targetCamX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                    camY = targetCamY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));

                    // Init Extras
                    initParticles();
                    initClouds();

                    // Start Audio
                    if (typeof ambientAudio !== 'undefined') ambientAudio.play().catch(() => { });

                    startGameLoop();
                    console.log("Map Processed & Ready.");
                };
                bgImage.onerror = (e) => {
                    console.error("Processed background image failed to load", e);
                };
                foregroundImage.onerror = (e) => {
                    console.error("Processed foreground image failed to load", e);
                };
                bgImage.src = bgCanvas.toDataURL();
                foregroundImage.src = fgCanvas.toDataURL();


            } catch (e) {
                console.error("Advanced Processing Crash", e);
                // Fallback to RAW if crash
                bgImage = img;
                foregroundImage = null;
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false)); // Safe init
                gameReady = true;
                startGameLoop();
            }
        }

        // Fallback: Audio starten bei erster Interaktion, falls Autoplay blockiert wurde
        document.addEventListener('click', () => {
            if (gameReady && ambientAudio.paused) {
                ambientAudio.play().catch(e => console.warn("Ambient play failed:", e));
            }
        }, { once: true }); // Nur einmal ausführen

        // ============================================
        // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
        // ============================================
        let wasAmbientPlaying = false;
        let wasPlayerPlaying = false;
        window.gamePaused = false; // Flag for Game Loop
        window.visualFreezeActive = !!window.visualFreezeActive;

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // APP BACKGROUNDED -> PAUSE ALL
                window.gamePaused = true; // Stop loop logic
                saveCurrentContentState({ preferCachedTime: true, reason: 'visibility:hidden' });
                indexDebugNote('visibility', 'hidden');

                if (typeof ambientAudio !== 'undefined') {
                    wasAmbientPlaying = (typeof ambientAudio.isProbablyPlaying === 'function')
                        ? ambientAudio.isProbablyPlaying()
                        : !ambientAudio.paused;
                    ambientAudio.pause();
                    indexDebugNote('ambient', `pause hidden (wasPlaying=${wasAmbientPlaying})`);
                } else {
                    wasAmbientPlaying = false;
                }

                if (typeof audioPlayer !== 'undefined') {
                    wasPlayerPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                        ? audioPlayer.isProbablyPlaying()
                        : !audioPlayer.paused;
                    audioPlayer.pause();
                    indexDebugNote('player', `pause hidden (wasPlaying=${wasPlayerPlaying})`);
                } else {
                    wasPlayerPlaying = false;
                }

                if (typeof footstepSound !== 'undefined') footstepSound.pause();

            } else {
                // APP FOREGROUND -> RESUME IF WAS PLAYING
                // Reset time to prevent delta spikes
                lastTime = 0;
                window.gamePaused = false;
                if (!window.visualFreezeActive) {
                    startGameLoop();
                }
                indexDebugNote('visibility', 'visible');

                setTimeout(() => {
                    if (wasAmbientPlaying && typeof ambientAudio !== 'undefined') {
                        ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                        wasAmbientPlaying = false;
                        indexDebugNote('ambient', 'resume on visible');
                    }
                    if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                        audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                        wasPlayerPlaying = false;
                        indexDebugNote('player', 'resume on visible');
                    }
                }, 100);
            }
        });

        window.addEventListener('pagehide', () => {
            saveCurrentContentState({ preferCachedTime: true, reason: 'pagehide' });
            if (typeof ambientAudio !== 'undefined') ambientAudio.pause();
            if (typeof audioPlayer !== 'undefined') audioPlayer.pause();
            indexDebugNote('lifecycle', 'pagehide');
        });

        function findSafeStart() {
            // Suche ausgehend von der Mitte nach einer Position ohne Kollision
            const startX = Math.floor(mapW / 2);
            const startY = Math.floor(mapH / 2);

            for (let radius = 0; radius < 100; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < mapW - 16 && y >= 0 && y < mapH - 16) {
                            if (!checkCollisionAt(x, y)) {
                                player.x = x;
                                player.y = y;
                                return;
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // FLOOD FILL MIT DILATATION
        // ============================================
        function findEnclosedAreas(cyanPixels, w, h) {
            const visited = new Array(h).fill(null).map(() => new Array(w).fill(0));

            // Dilatation der Cyan-Grenzen
            const dilationRadius = 2;
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                    for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) <= dilationRadius) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                visited[ny][nx] = 2;
                            }
                        }
                    }
                }
            }

            // Flood Fill vom Rand
            const queue = [];
            for (let x = 0; x < w; x++) {
                if (visited[0][x] === 0) queue.push([x, 0]);
                if (visited[h - 1][x] === 0) queue.push([x, h - 1]);
            }
            for (let y = 0; y < h; y++) {
                if (visited[y][0] === 0) queue.push([0, y]);
                if (visited[y][w - 1] === 0) queue.push([w - 1, y]);
            }

            let idx = 0;
            while (idx < queue.length) {
                const [x, y] = queue[idx++];
                if (x < 0 || x >= w || y < 0 || y >= h || visited[y][x] !== 0) continue;
                visited[y][x] = 1;
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Innere Bereiche markieren
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (visited[y][x] === 0 || visited[y][x] === 2) {
                        foregroundData[y][x] = true;
                    }
                }
            }

            // Original Cyan-Pixel auch markieren
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                foregroundData[y][x] = true;
            }
        }

        // ============================================
        // PIXEL-PULLING (Spiralförmige Suche für alle Linienrichtungen)
        // ============================================
        function pullNearbyPixel(data, x, y, w, h, cyanPixels) {
            // Spiralförmige Suche: Sucht in expandierenden Kreisen
            // Funktioniert für horizontale, vertikale UND diagonale Linien
            const maxRadius = 15;  // Maximaler Suchradius

            for (let radius = 1; radius <= maxRadius; radius++) {
                // Alle Punkte auf dem aktuellen "Quadrat-Ring" durchsuchen
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        // Nur Randpunkte des Quadrats (nicht innere)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                        const ni = (ny * w + nx) * 4;
                        const r = data[ni], g = data[ni + 1], b = data[ni + 2];

                        // Skip Magenta (Kollision) und Cyan (Vordergrund)
                        if (r > 200 && g < 80 && b > 200) continue;
                        if (r < 80 && g > 200 && b > 200) continue;
                        if (cyanPixels.has(`${nx},${ny}`)) continue;

                        // Gültiges Pixel gefunden!
                        return { r, g, b };
                    }
                }
            }

            // Fallback: Neutrales Grau-Braun (passt zu den meisten Umgebungen)
            return { r: 60, g: 55, b: 50 };
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function startGameLoop() {
            if (window.gameLoopRunning) return;
            if (window.visualFreezeActive) return;
            window.gameLoopRunning = true;
            lastTime = 0;
            console.log("startGameLoop");
            requestAnimationFrame(gameLoop);
        }

        // Global vars for timing
        let lastTime = 0;

        function gameLoop(timestamp) {
            if (window.visualFreezeActive) {
                window.gameLoopRunning = false;
                return;
            }

            if (window.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Clamp DT to prevent speed spikes (e.g. after lag/pause)
            if (dt > 0.1) dt = 0.1;

            // Cap delta time (prevent spirals of death)
            if (dt > 0.1) dt = 0.1;

            // Update Game Logic
            update(dt);
            updateLoreSystem(); // Lore-Proximity prüfen

            // Draw
            draw();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // UPDATE - MIT ROBUSTER KOLLISION
        // ============================================
        function update(dt) {
            if (!dt) dt = 0.016;
            if (!gameReady) return;

            // --- DYNAMIC SCALING (Depth Effect) ---
            if (mapH > 0) {
                // Normalisierte Y-Position (0.0 oben bis 1.0 unten)
                const yNorm = Math.max(0, Math.min(1, player.y / mapH));

                // Skalierung: 50% (oben) bis 130% (unten)
                // Formel: 0.5 + (0.8 * yNorm) -> 
                // yNorm=0 -> 0.5 | yNorm=1 -> 1.3
                const depthFactor = 0.5 + (0.8 * yNorm);

                SPRITE.scale = SPRITE.baseScale * depthFactor;
            }

            let dx = 0, dy = 0;
            player.isMoving = false;

            // Input von Tastatur
            if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) { dy = -1; player.dir = 1; }
            if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) { dy = 1; player.dir = 0; }
            if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) { dx = -1; player.dir = 2; }
            if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) { dx = 1; player.dir = 3; }

            // Click-to-Move: Wenn kein Tastatur-Input und Ziel gesetzt
            // Fix: Movement allowed during Lore (unless Reading Mode active)
            if (dx === 0 && dy === 0 && moveTarget && !isReadingMode) {
                const tdx = moveTarget.x - player.x;
                const tdy = moveTarget.y - player.y;
                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Ziel erreicht? (innerhalb von 3px)
                if (tdist < 3) {
                    moveTarget = null;
                } else {
                    // Richtung zum Ziel
                    dx = tdx / tdist;
                    dy = tdy / tdist;

                    // Blickrichtung setzen
                    if (Math.abs(tdx) > Math.abs(tdy)) {
                        player.dir = tdx > 0 ? 3 : 2; // Rechts oder Links
                    } else {
                        player.dir = tdy > 0 ? 0 : 1; // Unten oder Oben
                    }
                }
            }

            // --- AUTO-WALK (READING MODE & COASTDOWN) ---
            if ((isReadingMode || (player.slowdownTimer > 0)) && autoWalkPath.length > 0) {
                // Initialize Slowdown Timer
                if (isReadingMode) {
                    player.slowdownTimer = 1.0; // 1 Second Coastdown buffer (float seconds now)
                } else {
                    player.slowdownTimer -= dt;
                }

                // Calculate Foot Position
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const footX = player.x + spriteW / 2;
                const footY = player.y + spriteH + 15;

                // Target logic
                let target = autoWalkPath[autoWalkIndex];
                const tdx = target.x - footX;
                const tdy = target.y - footY;
                const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Speed Calculation (Linked to player.speed)
                let walkSpeed = player.speed;
                if (!isReadingMode) {
                    // Coastdown Fade
                    walkSpeed *= Math.max(0, player.slowdownTimer);
                }
                const step = walkSpeed * dt;

                if (dist < 4) {
                    autoWalkIndex++;
                    if (autoWalkIndex >= autoWalkPath.length) {
                        autoWalkIndex = autoWalkPath.length - 1;
                        if (!isReadingMode) player.slowdownTimer = 0;
                    }
                }

                if (autoWalkIndex < autoWalkPath.length && player.slowdownTimer > 0) {
                    const nextTdx = target.x - footX;
                    const nextTdy = target.y - footY;
                    const nextDist = Math.sqrt(nextTdx * nextTdx + nextTdy * nextTdy);

                    if (nextDist > 1) {
                        const dx = (nextTdx / nextDist) * step;
                        const dy = (nextTdy / nextDist) * step;

                        player.x += dx;
                        player.y += dy;
                        player.isMoving = true;

                        // Direction
                        if (Math.abs(nextTdx) > Math.abs(nextTdy)) {
                            player.dir = nextTdx > 0 ? 3 : 2;
                        } else {
                            player.dir = nextTdy > 0 ? 0 : 1;
                        }

                        // Animation
                        player.animTimer += dt;

                        // 50% Slower Animation for Front (0) and Back (1) views

                        // 50% Slower Animation for Front/Back (0.30s vs 0.15s)
                        let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                        if (player.animTimer > animThreshold) {
                            player.animTimer = 0;
                            player.frame = (player.frame + 1) % 12;
                        }
                    }
                }
            }

            // --- MANUAL MOVEMENT ---
            if (dx !== 0 || dy !== 0) {
                player.isMoving = true;

                // Normalisieren (Diagonal Fix)
                if ((keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) && Math.abs(dx) === 1 && Math.abs(dy) === 1) {
                    const inv = 0.7071;
                    dx *= inv; dy *= inv;
                }

                // Apply Movement
                let moveSpeed = player.speed;
                if (isReadingMode) {
                    moveSpeed = player.speed * 0.175; // 50% of 35% = 17.5% (User Request: even slower)
                }

                // LOG SPEED for Debug (Throttle)
                if (player.isMoving && Math.random() < 0.01) {
                    console.log(`[DEBUG_SYS] Player Move Speed: Base=${player.speed}, Actual=${moveSpeed} (Mode=${isReadingMode ? 'READING' : 'GAME'})`);
                }

                const amount = moveSpeed * dt;

                // Collision Logic (restore if missing or use simplified slide)
                const vx = dx * amount;
                const vy = dy * amount;
                const targetX = player.x + vx;
                const targetY = player.y + vy;

                // Simple Slide or Full Collision
                // Assuming checkCollisionAt is available
                if (!checkCollisionAt(targetX, targetY)) {
                    player.x = targetX;
                    player.y = targetY;
                } else {
                    if (!checkCollisionAt(targetX, player.y)) player.x = targetX;
                    else if (!checkCollisionAt(player.x, targetY)) player.y = targetY;
                }

                // Animation
                player.animTimer += dt;
                // 50% Slower Animation for Front/Back
                let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                if (player.animTimer > animThreshold) {
                    player.animTimer = 0;
                    player.frame = (player.frame + 1) % 12;
                }
            }

            // Handle Animation & Sound for Movement
            if (player.isMoving) {
                // Initial Footstep
                if (audioUnlocked && !footstepPlaying) {
                    footstepSound.play().catch(() => { });
                    footstepPlaying = true;
                }

                // Dust Particles
                if (Math.random() > 0.9) { // Reduced freq for dt loop
                    const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                    const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                    const offsetY = Math.floor(spriteH * 0.22);
                    const shiftY = Math.floor(spriteH / 3) - 4;
                    const anchorY = player.y + spriteH + offsetY + shiftY;

                    dustParticles.push({
                        x: player.x + spriteW / 2 + (Math.random() - 0.5) * 6,
                        y: anchorY - 15 + (Math.random() - 0.5) * 2,
                        vx: (Math.random() - 0.5) * 10,  // px/sec (no dt at spawn)
                        vy: -Math.random() * 10,
                        life: 1.0,
                        size: 2 + Math.random() * 2
                    });
                }
            } else {
                // Stop Sound
                player.frame = 1; // Stand
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
            }

            // Update Dust
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const d = dustParticles[i];
                d.x += d.vx * dt;  // Frame-rate independent
                d.y += d.vy * dt;
                d.life -= 2.5 * dt;
                if (d.life <= 0) dustParticles.splice(i, 1);
            }

            // Map Bounds (with sprite size and foot offset)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const FOOT_OFFSET_Y = 15;
                player.x = Math.max(0, Math.min(player.x, mapW - spriteW));
                player.y = Math.max(0, Math.min(player.y, mapH - spriteH - FOOT_OFFSET_Y));
            }

            // Foreground Check
            player.isBehindForeground = checkForeground(player.x, player.y);

            // Smooth Camera (Time-based)
            targetCamX = player.x - SCREEN_W / 2 + 10;
            targetCamY = player.y - SCREEN_H * 0.30 + 10;
            targetCamX = Math.max(0, Math.min(targetCamX, Math.max(0, mapW - SCREEN_W)));
            targetCamY = Math.max(0, Math.min(targetCamY, Math.max(0, mapH - SCREEN_H)));

            camX += (targetCamX - camX) * 5.0 * dt;
            camY += (targetCamY - camY) * 5.0 * dt;

            // Update Particles
            nearbyLights = [];
            for (const p of particles) p.update(dt); // Ensure particle update accepts dt (or add it)
            for (const c of clouds) c.update(dt);

            // Screen-Shake Decay (frame-rate independent)
            if (screenShake > 0.01) {
                screenShake *= Math.pow(0.8, dt * 60);
            } else {
                screenShake = 0;
            }
        }

        // ============================================
        // KOLLISIONSPRÜFUNG - ROBUST (Ecken-Check)
        // ============================================
        function checkCollisionAt(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            // Definition der Fuß-Kollisionsbox relative zum Sprite-Ursprung (px, py)
            // Sprite ist ca 16x20. Füße sind unten.
            // Wir definieren eine schmale Box mittig unten.

            const boxWidth = 8; // Schmaler als Sprite (damit man nicht an Ecken hängen bleibt)
            const boxHeight = 6;

            const centerX = px + spriteW / 2;
            const bottomY = py + spriteH + 15; // +15 wie bisher (visueller Offset)

            // Prüfpunkte:
            // 1. Unten Links
            // 2. Unten Rechts
            // (Optional auch Oben, wenn man eine tiefe Box hat, aber für RPG reicht meist eine 'Grundlinie')

            const left = Math.floor(centerX - boxWidth / 2);
            const right = Math.floor(centerX + boxWidth / 2);
            const yFn = Math.floor(bottomY);

            // Prüfe beide Ecken
            if (isSolid(left, yFn)) return true;
            if (isSolid(right, yFn)) return true;

            return false;
        }

        function isSolid(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true; // Map-Rand ist Wand
            if (collisionData[y][x]) return true;
            return false;
        }

        function checkForeground(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const cx = Math.floor(px + spriteW / 2);
            const cy = Math.floor(py + spriteH / 2);

            if (foregroundData && foregroundData[cy] && cy >= 0 && cy < mapH && cx >= 0 && cx < mapW) {
                return foregroundData[cy][cx];
            }
            return false;
        }

        // ============================================
        // DRAWING
        // ============================================
        function draw() {
            // LCD Ghosting: Vorherigen Frame mit Transparenz beibehalten
            // Disable Ghosting
            // ctx.save(); ... ctx.restore();

            // Clear Canvas fully every frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameReady) return;

            ctx.save();
            // Screen-Shake anwenden
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            // SMOOTH CAMERA: Use sub-pixel values (remove Math.floor)
            ctx.translate(-camX + shakeX, -camY + shakeY);

            // screenShake decay moved to update(dt) for frame-rate independence

            // Hintergrund
            if (bgImage) ctx.drawImage(bgImage, 0, 0);

            // Partikel (Additives Leuchten)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) p.draw(ctx, camX, camY);
            ctx.restore();

            // Gelbe Lore-Lichter zeichnen
            for (const light of yellowLights) {
                light.draw(ctx);

                // Beleuchtung hinzufügen wenn aktiv!
                if (activeLightSourceId === light.id && isLoreMode) {
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = light.x - px;
                    const ddy = light.y - py;
                    const dist = Math.sqrt(ddx * ddx + ddy * ddy);
                    nearbyLights.push({
                        x: light.x,
                        y: light.y,
                        dist: dist,
                        life: 1.0,
                        isYellow: true
                    });
                }
            }

            // Spieler-Schatten (diffuse Ellipse unter den Füßen)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

                // Offsets identisch zu drawPlayer berechnen
                const offsetY = Math.floor(spriteH * 0.22);
                const shiftY = Math.floor(spriteH / 3) - 4;
                const totalYOffset = offsetY + shiftY;

                // Schatten-Position: exakt unter den Füßen des Sprites
                const shadowCenterX = player.x + spriteW / 2;
                const shadowCenterY = player.y + totalYOffset + spriteH - 15; // Korrigiert

                // Schatten-Größe: klein und diffus
                const shadowWidth = spriteW * 0.4;
                const shadowHeight = 3;

                // Schatten-Deckkraft
                let shadowAlpha = 0.35;

                if (nearbyLights.length > 0) {
                    const light = nearbyLights[0];
                    const distFactor = 1 - (light.dist / 35);
                    shadowAlpha = 0.25 + distFactor * 0.15;
                }

                // Diffuser Schatten mit radialem Gradient
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    shadowCenterX, shadowCenterY, 0,
                    shadowCenterX, shadowCenterY, shadowWidth
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
                gradient.addColorStop(0.5, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(shadowCenterX, shadowCenterY, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Spieler NORMAL zeichnen (keine Transparenz!)
            drawPlayer(ctx, player.x, player.y, player.dir, player.frame);

            // DEBUG: Fadenkreuz an Fuß-Position (nur im Reading Mode)
            if (isReadingMode && player.debugFootX !== undefined) {
                const fx = player.debugFootX;
                const fy = player.debugFootY;
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1;
                // Horizontale Linie
                ctx.beginPath();
                ctx.moveTo(fx - 8, fy);
                ctx.lineTo(fx + 8, fy);
                ctx.stroke();
                // Vertikale Linie
                ctx.beginPath();
                ctx.moveTo(fx, fy - 8);
                ctx.lineTo(fx, fy + 8);
                ctx.stroke();
                // Kreis
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Beleuchtung: Direktional mit Gradient
            if (nearbyLights.length > 0) {
                nearbyLights.sort((a, b) => a.dist - b.dist);

                const maxRadius = 65; // Erhöht (war 35) für weichere Übergänge
                let totalIntensity = 0;
                let avgDx = 0, avgDy = 0;
                let useYellow = false;

                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const spriteW = coords.w;
                const spriteH = coords.h;
                const playerCX = coords.x + spriteW / 2;
                const playerCY = coords.y + spriteH / 2;

                const numLights = Math.min(2, nearbyLights.length);
                for (let i = 0; i < numLights; i++) {
                    const light = nearbyLights[i];
                    if (light.isYellow) useYellow = true;

                    // Distanz-Modulation: 0% am Rand, 100% direkt am Spieler
                    const distFactor = (1 - (light.dist / maxRadius));
                    // Gelbes Licht etwas intensiver
                    const intensity = distFactor * light.life * (light.isYellow ? 1.5 : 1.0);
                    totalIntensity += intensity * 0.4; // Subtiler (war 0.6)

                    // Richtung vom Licht zum Spieler (normalisiert)
                    const dx = playerCX - light.x;
                    const dy = playerCY - light.y;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    avgDx += (dx / len) * intensity;
                    avgDy += (dy / len) * intensity;
                }

                // Max 50% Aufhellung (subtiler Effekt), Gelb darf etwas heller sein (70%)
                totalIntensity = Math.min(useYellow ? 0.7 : 0.5, totalIntensity);

                if (totalIntensity > 0.02) {
                    // Normalisiere Durchschnittsrichtung
                    const dirLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy) || 1;
                    const ndx = avgDx / dirLen;
                    const ndy = avgDy / dirLen;

                    // OffScreen-Canvas für Gradient-Beleuchtung
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = spriteW;
                    lightCanvas.height = spriteH;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Zeichne Sprite exakt so wie es auf dem Hauptcanvas erscheint, aber relativ zu (0,0)
                    lightCtx.save();
                    lightCtx.translate(-coords.x, -coords.y);
                    drawPlayer(lightCtx, player.x, player.y, player.dir, player.frame);
                    lightCtx.restore();

                    // Gleichmäßigere Beleuchtung (statt harter Gradient)
                    // Wir füllen das Sprite fast gleichmäßig auf (mit sehr weichem Rand-Ausfall)
                    const r = useYellow ? 255 : 255;
                    const g = useYellow ? 220 : 255;
                    const b = useYellow ? 50 : 255;

                    lightCtx.globalCompositeOperation = 'source-in';
                    // Fast gleichmäßige Füllung basierend auf Intensität
                    lightCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.8})`;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Ein ganz dezenter Gradient für Dreidimensionalität
                    const rad = Math.max(spriteW, spriteH) * 2;
                    const gradient = lightCtx.createRadialGradient(
                        spriteW / 2 + ndx * (spriteW / 2),
                        spriteH / 2 + ndy * (spriteH / 2),
                        0,
                        spriteW / 2,
                        spriteH / 2,
                        rad
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    lightCtx.fillStyle = gradient;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Zeichne beleuchtetes Sprite an die berechnete Sprite-Position
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(lightCanvas, coords.x, coords.y);
                    ctx.restore();
                }
            }

            // Dust-Particles zeichnen
            ctx.save();
            for (const d of dustParticles) {
                ctx.globalAlpha = d.life * 0.4;
                ctx.fillStyle = '#a89070';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Vordergrund
            if (foregroundImage) ctx.drawImage(foregroundImage, 0, 0);

            // Graue Silhouette IMMER berechnen (Pixel-genaues Masking)
            if (foregroundImage && spriteReady) {
                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const px = coords.x;
                const py = coords.y;
                const dw = coords.w;
                const dh = coords.h;

                // OffScreen-Canvas für Masking
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = dw + 4;
                maskCanvas.height = dh + 4;
                const maskCtx = maskCanvas.getContext('2d');

                // 1. Zeichne den Foreground-Ausschnitt über dem Spieler
                maskCtx.drawImage(foregroundImage,
                    px - 2, py - 2, dw + 4, dh + 4,
                    0, 0, dw + 4, dh + 4);

                // 2. Source-In: Nur wo Foreground-Pixel existieren
                maskCtx.globalCompositeOperation = 'source-in';

                // 3. Zeichne graues Sprite
                const graySprite = createGraySpriteCanvas();
                if (graySprite) {
                    maskCtx.drawImage(graySprite, 2, 2);
                }

                // 4. Zeichne das Ergebnis
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(maskCanvas, px - 2, py - 2);
                ctx.restore();
            }

            // Wolken-Layer (Parallax, über allem)
            for (const c of clouds) c.draw(ctx, camX, camY);

            ctx.restore();
        }

        // NEU: Hilfsfunktion für konsistente Koordinatenberechnung
        // iOS Detection
        // const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent); // REMOVED DUPLICATE

        function getPlayerDrawCoords(x, y, dir, frame) {
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;
            const flipX = (dir === 3);

            let result = {};

            // FRONT (Marker-basiert, 6-Step)
            if (dir === 0) {
                const cycleIdx = frame % 6;
                const frameIdx = FRONT_ANIM_CYCLE[cycleIdx];
                const data = FRONT_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteFront.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteFront.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // BACK (NEU: Marker-basiert, 4-Step Cycle)
            else if (dir === 1) {
                const cycleIdx = frame % 4;
                const frameIdx = BACK_ANIM_CYCLE[cycleIdx];
                const data = BACK_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteBack.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteBack.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // SIDE (Marker-basiert, 6-Step Ping-Pong)
            else if (dir === 2 || dir === 3) {
                const cycleIdx = frame % 6;
                const frameIdx = SIDE_ANIM_CYCLE[cycleIdx];
                const data = SIDE_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = 175;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteSide.height * SPRITE.scale);

                let dx;
                if (flipX) {
                    // Gespiegelt: Ankerpunkt (x + refW/2) ist die Achse.
                    // Die linke Kante ist (Anker + verschobener_Anker) - Breite
                    dx = (x + refW / 2 + footRelX * SPRITE.scale) - dw;
                } else {
                    dx = x + refW / 2 - footRelX * SPRITE.scale;
                }
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: true, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteSide.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: flipX
                };
            } else {
                let sprite = (dir === 1) ? (spriteBack || spriteFront) : spriteFront;
                const sw = Math.floor(sprite.width / SPRITE.cols);
                const sh = sprite.height;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(sh * SPRITE.scale);
                const offsetY = Math.floor(dh * 0.22);

                const frameIdx = frame % 4;
                const sx = frameIdx * sw;

                const finalX = x;
                const finalY = y + offsetY + visualShiftY;
                result = {
                    x: finalX, y: finalY, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: sx, sw: sw, sh: sh,
                    flipX: false
                };
            }

            // iOS FIX: Force integer coordinates to prevent sub-pixel "wobble"
            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                result.x = Math.floor(result.x);
                result.y = Math.floor(result.y);
            }
            return result;
        }

        // ============================================
        // SPIELER SPRITE ZEICHNEN
        // ============================================
        function drawPlayer(ctx, x, y, dir, frame) {
            if (!spriteReady) return;

            const coords = getPlayerDrawCoords(x, y, dir, frame);
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;

            ctx.save();
            let sprite;
            if (dir === 0) sprite = spriteFront;
            else if (dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            // DEBUG-DOT an der Fuß-Koordinate
            if (window.debugFoot) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + refW / 2, y + refH + visualShiftY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(x + refW / 2 - 2, y + refH + visualShiftY - 2, 4, 4);
                ctx.restore();
            }

            if (coords.isSide && coords.flipX) {
                // Spiegeln: Translate zur EXAKT berechneten linken Kante + Breite
                ctx.translate(coords.x + coords.w, coords.y);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            } else {
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, coords.x, coords.y, coords.w, coords.h);
            }

            ctx.restore();
        }

        window.debugFoot = false;

        // Erstellt ein einfarbig graues Sprite-Canvas
        function createGraySpriteCanvas() {
            if (!spriteReady) return null;

            const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
            const flipX = (player.dir === 3);

            let sprite;
            if (player.dir === 0) sprite = spriteFront;
            else if (player.dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            const c = document.createElement('canvas');
            c.width = coords.w;
            c.height = coords.h;
            const gc = c.getContext('2d');

            if (coords.isSide && flipX) {
                gc.translate(coords.w, 0);
                gc.scale(-1, 1);
            }
            gc.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);

            gc.globalCompositeOperation = 'source-in';
            gc.fillStyle = 'rgb(180, 180, 180)';
            gc.fillRect(0, 0, coords.w, coords.h);

            return c;
        }

        function drawPlayerOutline(ctx, x, y) {
            if (!spriteReady || !spriteFront) return;

            const dir = player.dir;
            let sprite;
            let flipX = false;

            switch (dir) {
                case 0: sprite = spriteFront; break;
                case 1: sprite = spriteBack || spriteFront; break;
                case 2: sprite = spriteSide || spriteFront; break;
                case 3: sprite = spriteSide || spriteFront; flipX = true; break;
                default: sprite = spriteFront;
            }

            const spriteW = Math.floor(sprite.width / SPRITE.cols);
            const spriteH = sprite.height;
            const drawW = Math.floor(spriteW * SPRITE.scale);
            const drawH = Math.floor(spriteH * SPRITE.scale);
            const frame = player.frame % SPRITE.cols;

            // Erstelle OffScreen-Canvas für einfarbige Silhouette
            const offCanvas = document.createElement('canvas');
            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');

            // Zeichne Sprite ins OffScreen-Canvas
            if (flipX) {
                offCtx.translate(drawW, 0);
                offCtx.scale(-1, 1);
            }
            offCtx.drawImage(sprite, frame * spriteW, 0, spriteW, spriteH, 0, 0, drawW, drawH);

            // Wandle alle sichtbaren Pixel in einheitliches Grau
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = 'rgb(200, 200, 200)'; // Helles Grau
            offCtx.fillRect(0, 0, drawW, drawH);

            // Zeichne die graue Silhouette halbtransparent
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(offCanvas, Math.floor(x), Math.floor(y));
            ctx.restore();
        }

        // AUDIO & SUBTITLE SYSTEM
        // ============================================

        // SoundCloud Audio Player via Widget API
        const audioPlayer = new SCAudioAdapter();
        console.log('[Audio] Created SCAudioAdapter for main audio');
        let subtitleTracks = []; // Array aus { time: sekunden, text: string }
        let currentSubtitleIndex = -1;
        let isReadingMode = false;
        let subtitleFollowLocked = false;
        let suppressFollowLockUntil = 0;

        const uiContainer = document.getElementById('audioPlayerUI');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const audioControlsEl = document.getElementById('audioControls');
        const playBtn = document.getElementById('audioToggleBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipForwardBtn = document.getElementById('skipForwardBtn');
        const modeToggleBtn = document.getElementById('readingModeBtn');
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const iconFsEnter = document.getElementById('iconFsEnter');
        const iconFsExit = document.getElementById('iconFsExit');
        const subtitleRecenterBtn = document.getElementById('subtitleRecenterBtn');
        const RECENTER_MOBILE_RADIUS_PX = 75;
        if (subtitleRecenterBtn && subtitleRecenterBtn.parentElement !== document.body) {
            // Keep fixed-position math viewport-based: transformed UI containers skew fixed children.
            document.body.appendChild(subtitleRecenterBtn);
        }
        let subtitleRecenterMobileRadius = document.getElementById('subtitleRecenterMobileRadius');
        if (!subtitleRecenterMobileRadius) {
            subtitleRecenterMobileRadius = document.createElement('div');
            subtitleRecenterMobileRadius.id = 'subtitleRecenterMobileRadius';
            subtitleRecenterMobileRadius.setAttribute('aria-hidden', 'true');
            document.body.appendChild(subtitleRecenterMobileRadius);
        }
        const globalVisualDimmer = window.GlobalVisualDimmer
            ? window.GlobalVisualDimmer.init({
                overlayId: 'sceneDimmerOverlay',
                toggleButtonId: 'sceneDimmerToggleBtn',
                iconFullId: 'sceneDimmerIconFull',
                iconHalfId: 'sceneDimmerIconHalf',
                iconCrescentId: 'sceneDimmerIconCrescent',
                iconSunId: 'sceneDimmerIconSun'
            })
            : null;
        let manualBackgroundDimLevel = globalVisualDimmer ? globalVisualDimmer.getLevel() : 0;
        let pendingForceReadingFromFreeze = false;
        let modeSwitchInitialized = false;
        if (globalVisualDimmer) {
            globalVisualDimmer.onChange(({ level, frozen }) => {
                manualBackgroundDimLevel = level;
                window.visualFreezeActive = frozen;

                if (frozen) {
                    pendingForceReadingFromFreeze = true;
                    if (modeSwitchInitialized) {
                        setReadingMode(true, 'dimmer-freeze');
                        pendingForceReadingFromFreeze = false;
                    }
                } else {
                    pendingForceReadingFromFreeze = false;
                }
                if (!frozen && gameReady && !document.hidden) {
                    lastTime = 0;
                    startGameLoop();
                }
            });
            window.visualFreezeActive = globalVisualDimmer.isFrozen();
            pendingForceReadingFromFreeze = window.visualFreezeActive;

        }

        function syncPlayPauseIcon() {
            const isPaused = !audioPlayer || audioPlayer.paused;
            iconPlay.style.display = isPaused ? 'block' : 'none';
            iconPause.style.display = isPaused ? 'none' : 'block';
        }

        audioPlayer.addEventListener('play', syncPlayPauseIcon);
        audioPlayer.addEventListener('pause', syncPlayPauseIcon);
        audioPlayer.addEventListener('ended', syncPlayPauseIcon);
        audioPlayer.addEventListener('canplay', syncPlayPauseIcon);
        syncPlayPauseIcon();

        // FORCE REMOVE FOCUS FROM BUTTONS
        // This prevents the "Orange Box" from appearing when using arrow keys after clicking a button
        document.querySelectorAll('button').forEach(btn => {
            // Option 1: Blur on click
            btn.addEventListener('click', () => {
                btn.blur();
                window.focus();
            });
            // Option 2: Build wall against focus
            btn.addEventListener('focus', () => {
                btn.blur();
            });
            // Option 3: Prevent default on mousedown (stops focus, keeps click)
            btn.addEventListener('mousedown', (e) => {
                if (document.activeElement !== btn) {
                    e.preventDefault();
                }
            });
        });

        // Ambient und Schritte Audio via SC Adapter
        const ambientAudio = new SCAudioAdapter();
        ambientAudio.src = getSCUrl('assets/medieval_town.mp3');
        ambientAudio.volume = 0.02;

        // Audio unlock on first interaction (required for mobile autoplay policies)
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            if (ambientAudio.paused) {
                ambientAudio.play().catch(() => { });
            }
        }
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        console.log('[Audio] Created SCAudioAdapters for main/ambient/footsteps');

        // Berechne die Anzahl sichtbarer Zeilen basierend auf Bildschirmhöhe
        function getMaxVisibleLines() {
            if (!isReadingMode) return 3;
            const lineHeight = 28; // Ungefähre Zeilenhöhe in px
            const availableHeight = window.innerHeight * 0.6; // 60% der Bildschirmhöhe
            return Math.min(15, Math.max(5, Math.floor(availableHeight / lineHeight)));
        }

        // Custom Smooth Scroll with Variable Duration (1s-3s based on distance)
        // No jumping - always smooth glide
        let currentScrollAnimation = null;
        function smoothScrollToElement(container, targetEl) {
            if (!container || !targetEl) return;

            // Cancel any existing animation
            if (currentScrollAnimation) {
                cancelAnimationFrame(currentScrollAnimation);
                currentScrollAnimation = null;
            }

            const startY = container.scrollTop;

            // Calculate Target Y to center the element
            const relativeTop = targetEl.offsetTop;
            const targetY = relativeTop - (container.clientHeight / 2) + (targetEl.clientHeight / 2);

            const distance = Math.abs(targetY - startY);

            // Skip if already very close (within 5px)
            if (distance < 5) return;

            // Dynamic Duration: 1s (near) to 3s (far)
            // "Near" = within 200px, "Far" = 1000px+
            let duration = 1000; // Base 1s
            if (distance > 200) {
                // Scale from 1s to 3s between 200px and 1000px
                const extraDist = Math.min(800, distance - 200);
                duration = 1000 + (extraDist / 800) * 2000;
            }
            duration = Math.min(3000, duration); // Cap at 3s

            console.log(`[SmoothScroll] Dist=${distance.toFixed(0)}px -> Duration=${duration.toFixed(0)}ms`);

            const startTime = performance.now();

            // Easing function for smooth deceleration
            const easeOutQuad = (t) => t * (2 - t);

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                if (elapsed >= duration) {
                    container.scrollTop = targetY; // Snap to final
                    currentScrollAnimation = null;
                    return;
                }

                const progress = elapsed / duration;
                const eased = easeOutQuad(progress);

                container.scrollTop = startY + (targetY - startY) * eased;

                currentScrollAnimation = requestAnimationFrame(animate);
            };

            currentScrollAnimation = requestAnimationFrame(animate);
        }

        function updateRecenterButtonVisibility(reason = 'unspecified') {
            if (!subtitleRecenterBtn) return;

            const show = isReadingMode && subtitleFollowLocked;
            if (!show) {
                subtitleRecenterBtn.style.setProperty('display', 'none', 'important');
                subtitleRecenterBtn.setAttribute('aria-hidden', 'true');
                if (subtitleRecenterMobileRadius) {
                    subtitleRecenterMobileRadius.style.display = 'none';
                }
                return;
            }

            subtitleRecenterBtn.style.setProperty('display', 'inline-flex', 'important');
            subtitleRecenterBtn.setAttribute('aria-hidden', 'false');
            requestAnimationFrame(() => positionRecenterButton(`visibility-show:${reason}`));
        }

        function setSubtitleFollowLocked(nextLocked, reason = 'unspecified') {
            const normalized = !!nextLocked;
            subtitleFollowLocked = normalized;
            updateRecenterButtonVisibility(reason);
        }

        function isMobileRecenterZoneActive() {
            if (!subtitleRecenterBtn || !subtitleRecenterMobileRadius) return false;
            if (!window.matchMedia('(max-width: 768px)').matches) return false;
            const btnStyle = window.getComputedStyle(subtitleRecenterBtn);
            return btnStyle.display !== 'none' && isReadingMode && subtitleFollowLocked;
        }

        function updateMobileRecenterRadius(left, top, width, height) {
            if (!subtitleRecenterMobileRadius) return;
            if (!isMobileRecenterZoneActive()) {
                subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            const diameter = RECENTER_MOBILE_RADIUS_PX * 2;
            const centerX = left + (width * 0.5);
            const centerY = top + (height * 0.5);
            subtitleRecenterMobileRadius.style.width = `${diameter}px`;
            subtitleRecenterMobileRadius.style.height = `${diameter}px`;
            subtitleRecenterMobileRadius.style.left = `${centerX - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.top = `${centerY - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.display = 'block';
        }

        function eventPointInMobileRecenterZone(e) {
            if (!isMobileRecenterZoneActive()) return false;
            if (!e) return false;

            const point = Number.isFinite(e.clientX) && Number.isFinite(e.clientY)
                ? { x: e.clientX, y: e.clientY }
                : (e.changedTouches && e.changedTouches.length > 0
                    ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }
                    : (e.touches && e.touches.length > 0
                        ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
                        : null));
            if (!point) return false;

            const rect = subtitleRecenterBtn.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) return false;
            const centerX = rect.left + (rect.width * 0.5);
            const centerY = rect.top + (rect.height * 0.5);
            const dx = point.x - centerX;
            const dy = point.y - centerY;
            return (dx * dx + dy * dy) <= (RECENTER_MOBILE_RADIUS_PX * RECENTER_MOBILE_RADIUS_PX);
        }

        function positionRecenterButton(reason = 'unspecified') {
            if (!subtitleRecenterBtn || subtitleRecenterBtn.style.display === 'none') return;

            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            const anchorBtn = isMobileLayout ? fullscreenBtn : skipBackBtn;
            if (!anchorBtn) return;

            const anchorRect = anchorBtn.getBoundingClientRect();
            const btnRect = subtitleRecenterBtn.getBoundingClientRect();
            const gap = 10;

            const rawLeft = anchorRect.left + (anchorRect.width - btnRect.width) * 0.5;
            let rawTop = anchorRect.top - btnRect.height - gap;

            if (isMobileLayout) {
                const subtitleRect = subtitleContainer.getBoundingClientRect();
                const targetCenterY = subtitleRect.top + subtitleRect.height * 0.5;
                rawTop = targetCenterY - btnRect.height * 0.5;
            }

            let left = rawLeft;
            let top = rawTop;
            left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
            top = Math.max(6, Math.min(window.innerHeight - btnRect.height - 6, top));

            const clampedX = Math.abs(left - rawLeft) > 0.5;
            const clampedY = Math.abs(top - rawTop) > 0.5;

            subtitleRecenterBtn.style.left = `${left}px`;
            subtitleRecenterBtn.style.top = `${top}px`;
            updateMobileRecenterRadius(left, top, btnRect.width, btnRect.height);
        }

        function recenterToCurrentTimestamp() {
            if (!subtitleTracks || subtitleTracks.length === 0) {
                setSubtitleFollowLocked(false, 'recenter-no-tracks');
                return;
            }

            const fallbackIndex = findSubtitleIndexForTime(audioPlayer.currentTime || 0);
            const safeIndex = Math.max(
                0,
                Math.min(
                    subtitleTracks.length - 1,
                    Number.isFinite(currentSubtitleIndex) && currentSubtitleIndex >= 0 ? currentSubtitleIndex : fallbackIndex
                )
            );

            setSubtitleFollowLocked(false, 'recenter');
            suppressFollowLockUntil = Date.now() + 450;
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false';
            currentSubtitleIndex = safeIndex;
            renderSubtitleLines(safeIndex);

            const activeEl = subtitleContainer.children[safeIndex];
            if (activeEl) {
                smoothScrollToElement(subtitleContainer, activeEl);
            }
        }

        let lastRecenterActivationAt = 0;
        let suppressSubtitleClickUntil = 0;
        function handleRecenterActivate(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            const now = Date.now();
            if (now - lastRecenterActivationAt < 260) return;
            lastRecenterActivationAt = now;
            // Touch devices may emit a delayed "ghost click" after the recenter tap.
            // Keep subtitle timestamp clicks muted briefly to avoid accidental seeks.
            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            suppressSubtitleClickUntil = isMobileLayout ? now + 600 : now;
            recenterToCurrentTimestamp();
        }

        if (subtitleRecenterBtn) {
            subtitleRecenterBtn.addEventListener('pointerdown', handleRecenterActivate);
            subtitleRecenterBtn.addEventListener('touchstart', handleRecenterActivate, { passive: false });
            subtitleRecenterBtn.addEventListener('click', handleRecenterActivate);
        }

        window.addEventListener('resize', () => {
            positionRecenterButton('resize');
        });
        window.addEventListener('orientationchange', () => {
            positionRecenterButton('orientationchange');
        });

        const TOP_FADE_BYPASS_COUNT = 2;
        function syncReadingTopFadeMask(activeIndex) {
            if (!subtitleContainer) return;
            const shouldDisableTopFade =
                isReadingMode &&
                Number.isFinite(activeIndex) &&
                activeIndex >= 0 &&
                activeIndex < TOP_FADE_BYPASS_COUNT;
            subtitleContainer.classList.toggle('no-top-fade', shouldDisableTopFade);
        }

        // Generiert die Untertitel-Zeilen dynamisch
        function renderSubtitleLines(centerIndex) {
            // A) Reading Mode: Rendere ALLE Zeilen (für Scrollbar)
            if (isReadingMode) {
                // Version Check: Ensure we are rendering the current set of subtitles
                if (subtitleTracks.length === 0) {
                    syncReadingTopFadeMask(-1);
                    subtitleContainer.innerHTML = '';
                    const emptyLine = document.createElement('div');
                    emptyLine.className = 'subtitle-line subtitle-current';
                    emptyLine.innerText = 'Warte auf Audio/Text...';
                    subtitleContainer.appendChild(emptyLine);
                    return;
                }

                const currentVersion = window.subtitleVersion || 0;
                const renderedVersion = parseInt(subtitleContainer.dataset.version || '-1');

                // Nur neu bauen, wenn Anzahl nicht stimmt ODER Version anders ist
                if (subtitleContainer.children.length !== subtitleTracks.length || renderedVersion !== currentVersion) {
                    subtitleContainer.innerHTML = '';
                    subtitleContainer.dataset.version = currentVersion;

                    subtitleTracks.forEach((track, i) => {
                        const div = document.createElement('div');
                        div.className = 'subtitle-line';
                        div.innerText = track.text;
                        div.dataset.index = i;

                        // Click to Seek
                        div.title = "Klicken zum Springen";
                        div.style.cursor = "pointer";
                        div.addEventListener('click', async (e) => {
                            if (eventPointInMobileRecenterZone(e)) {
                                handleRecenterActivate(e);
                                return;
                            }
                            if (Date.now() < suppressSubtitleClickUntil) {
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            if (subtitleContainer.dataset.wasDragging === 'true') {
                                console.log("Click ignored due to drag");
                                return;
                            }
                            // If a bookmark button is visible and was the click target, skip seek
                            if (e.target.classList.contains('bookmark-btn')) return;
                            setSubtitleFollowLocked(false, 'timestamp-click');
                            console.log(`Seek to ${track.time}s`);
                            await seekAndSyncSubtitle(track.time, `reading-click:${i}`);
                            try {
                                await audioPlayer.play();
                            } catch (_) {
                                // ignore autoplay gesture restrictions
                            }
                            // Smooth scroll to clicked element
                            smoothScrollToElement(subtitleContainer, div);
                        });

                        // --- LONG-PRESS BOOKMARK ---
                        div.style.position = 'relative';
                        let _bmTimer = null;
                        const startLongPress = (e) => {
                            if (_bmTimer) clearTimeout(_bmTimer);
                            _bmTimer = setTimeout(() => {
                                _bmTimer = null;
                                // Show bookmark button
                                let btn = div.querySelector('.bookmark-btn');
                                if (!btn) {
                                    btn = document.createElement('button');
                                    btn.className = 'bookmark-btn';
                                    btn.innerText = '🔖 Lesezeichen';
                                    btn.addEventListener('click', async (ev) => {
                                        ev.stopPropagation();
                                        ev.preventDefault();
                                        const bm = {
                                            id: Date.now(),
                                            chapter: CURRENT_CHAPTER,
                                            chapterTitle: CURRENT_CHAPTER_TITLE,
                                            page: CURRENT_PAGE,
                                            time: track.time,
                                            textPreview: (track.text || '').substring(0, 60),
                                            createdAt: Date.now()
                                        };
                                        const added = await window.GameState.addBookmark(bm);
                                        if (added) {
                                            btn.classList.add('saved');
                                            btn.innerText = '✓ Gespeichert';
                                            setTimeout(() => {
                                                btn.classList.remove('visible', 'saved');
                                                btn.innerText = '🔖 Lesezeichen';
                                            }, 1200);
                                        } else {
                                            btn.classList.remove('visible');
                                        }
                                    });
                                    div.appendChild(btn);
                                }
                                btn.classList.add('visible');
                                // Auto-hide after 4 seconds
                                setTimeout(() => {
                                    if (!btn.classList.contains('saved')) {
                                        btn.classList.remove('visible');
                                    }
                                }, 4000);
                            }, 600);
                        };
                        const cancelLongPress = () => {
                            if (_bmTimer) { clearTimeout(_bmTimer); _bmTimer = null; }
                        };
                        div.addEventListener('mousedown', startLongPress);
                        div.addEventListener('touchstart', startLongPress, { passive: true });
                        div.addEventListener('mouseup', cancelLongPress);
                        div.addEventListener('mouseleave', cancelLongPress);
                        div.addEventListener('touchend', cancelLongPress);
                        div.addEventListener('touchcancel', cancelLongPress);

                        subtitleContainer.appendChild(div);
                    });
                }

                // Highlighting aktualisieren
                const oldActive = subtitleContainer.querySelector('.subtitle-current');
                if (oldActive) oldActive.classList.remove('subtitle-current');

                // Ensure centerIndex is valid
                const normalizedIndex = Number.isFinite(centerIndex) ? centerIndex : 0;
                const safeIndex = Math.max(0, Math.min(subtitleTracks.length - 1, normalizedIndex));
                syncReadingTopFadeMask(safeIndex);

                if (subtitleContainer.children.length > safeIndex) {
                    const activeEl = subtitleContainer.children[safeIndex];
                    activeEl.classList.add('subtitle-current');

                    // Auto-Scroll only if user is NOT actively dragging AND audio is playing
                    // Uses custom smooth scroll with variable duration (1-3s)
                    const isPlaying = !audioPlayer.paused;
                    if (subtitleContainer.dataset.isDragging !== 'true' && !subtitleFollowLocked && isPlaying) {
                        smoothScrollToElement(subtitleContainer, activeEl);
                    }
                }
                return;
            }

            // B) Game Mode: Nur kleines Fenster rendern (3 Zeilen)
            syncReadingTopFadeMask(-1);
            subtitleContainer.innerHTML = '';

            if (subtitleTracks.length === 0) {
                const div = document.createElement('div');
                div.className = 'subtitle-line subtitle-current';
                div.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(div);
                return;
            }

            // Fixe 3 Zeilen im Spielmodus
            const startIdx = Math.max(0, centerIndex - 1);
            const endIdx = Math.min(subtitleTracks.length - 1, centerIndex + 1);

            for (let i = startIdx; i <= endIdx; i++) {
                const div = document.createElement('div');
                div.className = 'subtitle-line';

                const distance = Math.abs(i - centerIndex);

                if (i === centerIndex) {
                    div.classList.add('subtitle-current');
                } else {
                    // Verblassen
                    if (distance >= 5) div.classList.add('fade-far');
                    else if (distance >= 3) div.classList.add('fade-mid');
                }

                div.innerText = subtitleTracks[i].text;
                subtitleContainer.appendChild(div);
            }
        }



        // 2. Parser für Timestamps - CORRECTLY distinguishes between formats:
        // [hh:mm:ss] - Colon before third part means SECONDS (kapitel1.txt uses [00:mm:ss])
        // [mm:ss.xx] - Dot before third part means CENTISECONDS (lore format)
        function parseSubtitles(rawText) {
            subtitleTracks = [];
            currentSubtitleIndex = -1;
            const lines = rawText.split('\n');

            // Capture the separator character to distinguish formats:
            // Group 1: first number
            // Group 2: second number  
            // Group 3: separator (: or .) - captured separately!
            // Group 4: third number if exists
            // Group 5: text
            const timeReg = /^\[(\d{1,2}):(\d{2})([:.])(\d{1,2}(?:\.\d+)?)\]\s*(.*)|\[(\d{1,2}):(\d{2})\]\s*(.*)/;

            let matchCount = 0;
            lines.forEach((line, idx) => {
                const match = line.match(timeReg);
                if (match) {
                    matchCount++;
                    let totalSeconds;
                    let text;

                    if (match[1] !== undefined) {
                        // Three-part format: [xx:xx:xx] or [xx:xx.xx]
                        const first = parseFloat(match[1]);
                        const second = parseFloat(match[2]);
                        const separator = match[3]; // ':' or '.'
                        const third = parseFloat(match[4]);
                        text = match[5] ? match[5].trim() : '';

                        if (separator === ':') {
                            // [hh:mm:ss] format - third part is SECONDS
                            totalSeconds = first * 3600 + second * 60 + third;
                        } else {
                            // [mm:ss.xx] format - third part is CENTISECONDS
                            totalSeconds = first * 60 + second + (third / 100);
                        }
                    } else {
                        // Two-part format: [mm:ss]
                        const first = parseFloat(match[6]);
                        const second = parseFloat(match[7]);
                        text = match[8] ? match[8].trim() : '';
                        totalSeconds = first * 60 + second;
                    }

                    if (text && text.length > 0) {
                        subtitleTracks.push({
                            time: totalSeconds,
                            text: text
                        });
                    }
                }
            });

            console.log(`[DEBUG] parseSubtitles: ${matchCount} matches from ${lines.length} lines, ${subtitleTracks.length} tracks with text`);
            if (subtitleTracks.length > 0) {
                console.log(`[DEBUG] First subtitle at ${subtitleTracks[0].time}s: "${subtitleTracks[0].text.substring(0, 40)}..."`);
                if (subtitleTracks.length > 1) {
                    console.log(`[DEBUG] Second subtitle at ${subtitleTracks[1].time}s: "${subtitleTracks[1].text.substring(0, 30)}..."`);
                }
            }

            subtitleTracks.sort((a, b) => a.time - b.time);
            setSubtitleFollowLocked(false, 'parse-subtitles');

            // Increment version to force re-render in Reading Mode
            window.subtitleVersion = (window.subtitleVersion || 0) + 1;
        }

        // 3. Update-Funktion für Anzeige
        function updateSubtitleDisplay(index) {
            if (index === currentSubtitleIndex) return;
            currentSubtitleIndex = index;
            renderSubtitleLines(Math.max(0, index));
        }

        // 4. Synchronisation (läuft bei jedem Audio-Update)
        audioPlayer.addEventListener('timeupdate', () => {
            const t = audioPlayer.currentTime;

            let newIndex = -1;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (t >= subtitleTracks[i].time) {
                    newIndex = i;
                    break;
                }
            }

            updateSubtitleDisplay(newIndex);
        });

        // 4b. Chapter Transition Logic (Main Audio Ended)
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode) {
                if (window.restoreMainAudio) {
                    window.restoreMainAudio({ saveCurrent: false });
                }
                return;
            } else {
                // MAIN CHAPTER FINISHED
                console.log("Chapter 1 Finished. ReadingMode:", isReadingMode);

                // BUGFIX: Prevent transition if Text is not finished!
                // Only if we are in Reading Mode (where text matters).
                // Or generally? User said "Cut off bug".

                let textFinished = true;
                if (subtitleTracks.length > 0) {
                    // If we are significantly behind? use small buffer (e.g. within last 3 lines)
                    if (currentSubtitleIndex < subtitleTracks.length - 1) {
                        textFinished = false;
                    }
                }

                // Debug Decision
                console.log(`[DEBUG_SYS] Audio Ended. SubtitleIndex=${currentSubtitleIndex}/${subtitleTracks.length}. TextFinished=${textFinished}`);
                indexDebugNote('audio-ended', `idx=${currentSubtitleIndex}/${subtitleTracks.length} textFinished=${textFinished} reading=${isReadingMode}`);
                const shouldClearMainState = !isReadingMode || textFinished;
                if (shouldClearMainState) {
                    clearContentState(MAIN_CONTENT_KEY);
                }

                if (isReadingMode) {
                    if (textFinished) {
                        transitionToNextChapter();
                    } else {
                        console.log("[DEBUG_SYS] Audio ended but text incomplete. Pausing audio, keeping Reading Mode open.");
                        // Stop audio but do not transition. 
                        // User can read remaining text, then manual action needed? 
                        // Or maybe we don't need to do anything, just let it stop.
                        audioPlayer.pause();
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else {
                    // Game Mode: Show Button
                    const btn = document.getElementById('nextChapterBtn');
                    if (btn) btn.classList.add('visible');

                    // UI Polish: switch to Pause icon? No, audio ended means it stopped.
                    // Just ensure logic state.
                }
            }
        });

        // PINCH-TO-ZOOM REMOVED per user request (caused jitter issues)


        window.transitionToNextChapter = async function () {
            const overlay = document.getElementById('transitionOverlay');
            if (overlay) overlay.classList.add('active');

            await waitForContentSwitchIdle('transition:next-chapter');
            await saveCurrentContentState({ reason: 'transition:next-chapter' });
            indexDebugNote('transition', 'to chapter 1b');
            markChapterAutoplayIntent('liminal_library', 'auto', 'chapter-transition');
            writeStateHandoff('liminal_library');

            // Fade out any remaining audio
            fadeAudio(audioPlayer, 0, 1500);

            setTimeout(() => {
                window.location.href = 'liminal library.html';
            }, 2000); // 2s Fade Time
        };

        const nextChapterBtn = document.getElementById('nextChapterBtn');
        if (nextChapterBtn) {
            nextChapterBtn.addEventListener('click', () => {
                nextChapterBtn.classList.remove('visible');
                transitionToNextChapter();
            });
        }


        // 11. Custom Drag-to-Scroll Logic for Subtitle Container (with Momentum)
        let isDown = false;
        let startY;
        let scrollTop;
        let lastMoveY = 0;
        let lastMoveTime = 0;
        let swipeVelocity = 0;
        let momentumAnimId = null;

        function cancelMomentum() {
            if (momentumAnimId) {
                cancelAnimationFrame(momentumAnimId);
                momentumAnimId = null;
            }
        }

        const handleDown = (e) => {
            cancelMomentum();
            isDown = true;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false'; // Reset for next click check
            const pageY = e.pageY || e.touches[0].pageY;
            startY = pageY - subtitleContainer.offsetTop;
            scrollTop = subtitleContainer.scrollTop;
            lastMoveY = pageY;
            lastMoveTime = performance.now();
            swipeVelocity = 0;
            // Optional: Cursor style
            subtitleContainer.style.cursor = 'grabbing';
        };

        const handleMove = (e) => {
            if (!isDown) return;
            e.preventDefault(); // Prevent text selection
            const pageY = e.pageY || e.touches[0].pageY;
            const y = pageY - subtitleContainer.offsetTop;
            const walk = (y - startY) * 1.0; // Scroll speed

            // Track velocity for momentum
            const now = performance.now();
            const elapsed = now - lastMoveTime;
            if (elapsed > 0) {
                // velocity in px/ms, smoothed
                const instantVelocity = (pageY - lastMoveY) / elapsed;
                swipeVelocity = swipeVelocity * 0.6 + instantVelocity * 0.4;
            }
            lastMoveY = pageY;
            lastMoveTime = now;

            // Threshold check
            if (Math.abs(walk) > 5) {
                subtitleContainer.dataset.isDragging = 'true';
                subtitleContainer.dataset.wasDragging = 'true';
                if (isReadingMode && Date.now() >= suppressFollowLockUntil) {
                    setSubtitleFollowLocked(true, 'drag-threshold');
                }
                subtitleContainer.scrollTop = scrollTop - walk;
            }
        };

        const handleUp = () => {
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.style.cursor = 'auto';

            // Start momentum animation if velocity is significant
            const velocityPxPerMs = swipeVelocity;
            let velocityPxPerSec = -velocityPxPerMs * 1000 * 1.2; // Negate + moderate amplify
            const MAX_VELOCITY = 5000;
            const MIN_VELOCITY = 15;
            velocityPxPerSec = Math.max(-MAX_VELOCITY, Math.min(MAX_VELOCITY, velocityPxPerSec));

            if (Math.abs(velocityPxPerSec) > MIN_VELOCITY) {
                let lastFrame = performance.now();
                const animateMomentum = (now) => {
                    const dt = (now - lastFrame) / 1000;
                    lastFrame = now;

                    // Apply velocity
                    subtitleContainer.scrollTop += velocityPxPerSec * dt;

                    // Decay — 0.96 is much gentler than 0.92, so hard swipes coast far
                    velocityPxPerSec *= Math.pow(0.96, dt * 60);

                    // Stop when effectively still
                    if (Math.abs(velocityPxPerSec) < 0.5) {
                        momentumAnimId = null;
                        return;
                    }

                    momentumAnimId = requestAnimationFrame(animateMomentum);
                };
                momentumAnimId = requestAnimationFrame(animateMomentum);
            }
        };

        subtitleContainer.addEventListener('mousedown', handleDown);
        subtitleContainer.addEventListener('touchstart', handleDown, { passive: true });

        subtitleContainer.addEventListener('mouseleave', handleUp);
        subtitleContainer.addEventListener('mouseup', handleUp);
        subtitleContainer.addEventListener('touchend', handleUp);

        subtitleContainer.addEventListener('mousemove', handleMove);
        subtitleContainer.addEventListener('touchmove', handleMove, { passive: false });

        // 10. Scrollbar Auto-Hide Logic
        let scrollTimeout;
        subtitleContainer.addEventListener('scroll', () => {
            subtitleContainer.classList.add('is-scrolling');
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                subtitleContainer.classList.remove('is-scrolling');
            }, 1000); // 1 Sekunde nach Scroll-Ende ausblenden
        });

        // 5. Play/Pause Steuerung
        playBtn.addEventListener('click', () => {
            console.log("Play Button Clicked. Current Src:", audioPlayer.src, "Paused:", audioPlayer.paused);
            if (audioPlayer.paused) {
                audioPlayer.play()
                    .then(() => syncPlayPauseIcon())
                    .catch(e => {
                        console.error("Play verification failed:", e);
                        syncPlayPauseIcon();
                    });
            } else {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        });

        // 6. Skip Buttons (±15 Sekunden)
        skipBackBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 15);
        });

        skipForwardBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.min(audioPlayer.duration || 0, audioPlayer.currentTime + 15);
        });

        // 7. Modus-Wechsel mit robuster Animation
        let modeSwitchUiTimer = null;
        let modeSwitchLockUntil = 0;

        function syncModeToggleButton() {
            if (!modeToggleBtn) return;
            const nextModeLabel = isReadingMode ? 'Spielmodus aktivieren' : 'Lesemodus aktivieren';
            modeToggleBtn.title = nextModeLabel;
            modeToggleBtn.setAttribute('aria-label', nextModeLabel);
        }

        function setReadingMode(nextMode, reason = 'manual') {
            let normalized = !!nextMode;
            if (!normalized && globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                normalized = true;
            }
            const now = performance.now();

            if (now < modeSwitchLockUntil && normalized === isReadingMode) return;
            modeSwitchLockUntil = now + 120;

            isReadingMode = normalized;
            localStorage.setItem('gameboy_reading_mode', normalized ? 'true' : 'false');

            if (normalized) {
                syncAutoWalkToIndex();
                uiContainer.classList.add('reading-mode');
            } else {
                setSubtitleFollowLocked(false, 'mode-off');
                if (isLoreMode && !isMenuTriggeredLore) {
                    endLoreMode();
                }
                uiContainer.classList.remove('reading-mode');
            }

            syncModeToggleButton();
            moveTarget = null;
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));

            uiContainer.classList.add('mode-switching');
            if (modeSwitchUiTimer) clearTimeout(modeSwitchUiTimer);
            modeSwitchUiTimer = setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);

            indexDebugNote(
                'mode-switch',
                `${reason} reading=${isReadingMode} tracks=${subtitleTracks.length} switching=${contentSwitchInProgress}`
            );
            updateRecenterButtonVisibility();
        }

        syncModeToggleButton();
        modeSwitchInitialized = true;
        if (pendingForceReadingFromFreeze) {
            setReadingMode(true, 'dimmer-freeze-init');
            pendingForceReadingFromFreeze = false;
        }

        modeToggleBtn.addEventListener('click', () => {
            // In frozen mode: reset dimmer to off + switch to game mode
            if (globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                globalVisualDimmer.setLevel(0, { forceEmit: true });
                setReadingMode(false, 'ui-mode-toggle-unfreeze');
            } else {
                setReadingMode(!isReadingMode, 'ui-mode-toggle');
            }
        });

        // HELPER: Sync AutoWalk Index to current Player Position
        function syncAutoWalkToIndex() {
            if (!autoWalkPath || autoWalkPath.length === 0) return;

            // Calculate Foot Position
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const footX = player.x + spriteW / 2;
            const footY = player.y + spriteH + 15;

            // Find closest index
            let closestIdx = 0;
            let minDistSq = Infinity;

            for (let i = 0; i < autoWalkPath.length; i++) {
                const node = autoWalkPath[i];
                const dx = node.x - footX;
                const dy = node.y - footY;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestIdx = i;
                }
            }

            // Set Index
            autoWalkIndex = closestIdx;
            console.log(`AutoWalk Synced to Index: ${closestIdx} / ${autoWalkPath.length}`);
        }

        // 8. Wenn Audio zu Ende ist, Reset
        // 8. Wenn Audio zu Ende ist
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode || contentSwitchInProgress) return;
            iconPlay.style.display = 'block';
            renderSubtitleLines(subtitleTracks.length - 1);
        });

        // 9. Bei Fenster-Resize: Canvas anpassen & Zeilen neu berechnen
        window.addEventListener('resize', () => {
            // A) Canvas Resize Logic (Vollbild Unterstützung)
            if (mapW > 0 && mapH > 0 && gameReady) {
                SCREEN_W = Math.min(mapW, window.innerWidth);
                SCREEN_H = Math.min(mapH, window.innerHeight);
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;

                // Kamera neu zentrieren
                camX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                camY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));
            }

            // B) Untertitel Logic: Force Rebuild bei Resize
            if (isReadingMode && subtitleTracks.length > 0) {
                // Leere Container um Rebuild zu erzwingen (Fix für Scrollbar Resize Bug)
                subtitleContainer.innerHTML = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // 10. Fullscreen Logic
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                iconFsEnter.style.display = 'none';
                iconFsExit.style.display = 'block';
            } else {
                iconFsEnter.style.display = 'block';
                iconFsExit.style.display = 'none';
            }
            positionRecenterButton();
        });

        // 11. Custom Fullscreen Button (siehe oben)
        let lastBrightness = 0;


        let lastBrightnessCheck = 0;
        function checkBackgroundBrightness(timestamp) {
            if (manualBackgroundDimLevel > 0) {
                subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            // Im Lesemodus immer dunkler Hintergrund
            if (isReadingMode) {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            if (!gameReady || uiContainer.style.display === 'none') {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            // Throttle: Nur alle 1000ms prüfen (Performance!)
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastBrightnessCheck < 1000) {
                requestAnimationFrame(checkBackgroundBrightness);
                return;
            }
            lastBrightnessCheck = timestamp;

            try {
                const uiRect = uiContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const sampleX = Math.max(0, (uiRect.left - canvasRect.left) * (canvas.width / canvasRect.width));
                const sampleY = Math.max(0, (uiRect.top - canvasRect.top) * (canvas.height / canvasRect.height));
                const sampleW = Math.min(canvas.width - sampleX, uiRect.width * (canvas.width / canvasRect.width));
                const sampleH = Math.min(canvas.height - sampleY, uiRect.height * (canvas.height / canvasRect.height));

                if (sampleW > 0 && sampleH > 0 && sampleX >= 0 && sampleY >= 0) {
                    const imageData = ctx.getImageData(
                        Math.floor(sampleX),
                        Math.floor(sampleY),
                        Math.floor(Math.min(sampleW, 100)),
                        Math.floor(Math.min(sampleH, 60))
                    );

                    let totalBrightness = 0;
                    const pixels = imageData.data;
                    const pixelCount = pixels.length / 4;

                    for (let i = 0; i < pixels.length; i += 16) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                    }

                    const avgBrightness = totalBrightness / (pixelCount / 4);
                    lastBrightness = lastBrightness * 0.85 + avgBrightness * 0.15;

                    // Stärkerer Kontrast: noch früher einsetzen, höhere Basis
                    const threshold = 60;
                    const maxBrightness = 180;
                    const baseOpacity = 0.5;
                    const maxAdditionalOpacity = 0.8;

                    if (lastBrightness > threshold) {
                        const dynamicOpacity = ((lastBrightness - threshold) / (maxBrightness - threshold)) * maxAdditionalOpacity;
                        const opacity = Math.min(0.95, baseOpacity + dynamicOpacity);
                        const bgValue = `rgba(0, 0, 0, ${opacity.toFixed(2)})`;
                        subtitleContainer.style.background = bgValue;
                        audioControlsEl.style.background = bgValue;
                    } else {
                        subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                        audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                    }
                }
            } catch (e) {
                // Canvas-Zugriff kann bei bestimmten Bedingungen fehlschlagen
            }

            requestAnimationFrame(checkBackgroundBrightness);
        }

        // Starte die Hintergrund-Prüfung
        requestAnimationFrame(checkBackgroundBrightness);

        // Global Start Time for Grace Period
        const GAME_START_TIME = Date.now();

        // ============================================
        // LORE PROXIMITY SYSTEM
        // ============================================
        function updateLoreSystem() {
            // Grace Period: 3 Sekunden keine Trigger nach Start
            if (!gameReady || yellowLights.length === 0 || (Date.now() - GAME_START_TIME < 3000)) return;

            const refW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const refH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const offsetY = Math.floor(refH * 0.22);
            const hatOffset = Math.floor(refH * 0.15);

            // Bounding Box des Charakters (synchron mit der visuellen Anzeige)
            // Nur der "Körper" (Hut bis Füße) löst den Trigger aus
            const pLeft = player.x;
            const pRight = player.x + refW;
            const pTop = player.y + offsetY + hatOffset;
            const pBottom = player.y + offsetY + refH;

            // Finde das nächste Licht und die Distanz zur Bounding Box
            let nearestId = null;
            let minDist = Infinity;

            yellowLights.forEach(light => {
                // Finde den nächsten Punkt auf der Bounding Box zum Licht
                const closestX = Math.max(pLeft, Math.min(light.x, pRight));
                const closestY = Math.max(pTop, Math.min(light.y, pBottom));

                const dx = light.x - closestX;
                const dy = light.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearestId = light.id;
                }
            });

            const TRIGGER_DIST = 6; // Reduced by ~70% (was 20)
            const EXIT_DIST = 25; // Adjusted Hysteresis

            // SHIMMER SOUND TRIGGER (Unabhängig vom Text)
            if (nearestId && minDist < TRIGGER_DIST) {
                // BUGFIX: Do not play shimmer if already collected!
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));

                if (!alreadyCollected) {
                    if (lastShimmerLightId !== nearestId) {
                        shimmerSound.currentTime = 0;
                        shimmerSound.play().catch(() => { });
                        lastShimmerLightId = nearestId;
                    }
                }
            } else if (!nearestId || minDist > EXIT_DIST) {
                // Reset, wenn man den Einflussbereich verlassen hat
                lastShimmerLightId = null;
            }

            // START LORE - Dynamic Sequential Unlock
            if (nearestId && minDist < TRIGGER_DIST && !isLoreMode) {
                // Safety Check: Ignore if Player or Light is at (0,0) (Spawn Glitch)
                const light = yellowLights.find(l => l.id === nearestId);
                if ((player.x === 0 && player.y === 0) || (light && light.x === 0 && light.y === 0)) {
                    return;
                }

                // Check if this specific light was already collected
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));
                if (alreadyCollected) {
                    return;
                }

                activeLightSourceId = nearestId;

                // Use GameState for unified persistence (syncs with YellowLight.draw check)
                if (window.GameState) {
                    window.GameState.collectLight(sc, nearestId).then(unlockedLoreId => {
                        if (unlockedLoreId) {
                            console.log("[GameState] Collected Light -> Unlocked Lore:", unlockedLoreId);
                            // Refresh archive menu so new lore appears immediately
                            if (typeof renderArchive === 'function') renderArchive();
                            // Start lore mode with the UNLOCKED lore ID (not the light ID!)
                            startLoreMode(unlockedLoreId);
                        } else {
                            console.log("[GameState] Light collected but all lore already unlocked.");
                        }
                    });
                } else {
                    // Fallback to local LoreSystem if GameState not available
                    if (!LoreSystem.state.collectedLights[sc]) LoreSystem.state.collectedLights[sc] = [];
                    LoreSystem.state.collectedLights[sc].push(nearestId);
                    LoreSystem.save();
                    const nextLore = LoreSystem.state.collectedLore.length + 1;
                    if (LoreSystem.unlock(nextLore)) {
                        console.log("[LoreSystem] Unlocked Lore:", nextLore);
                        startLoreMode(nextLore);
                    }
                }

            }
            // STOP LORE (Spieler läuft weg) - NUR wenn NICHT vom Menü gestartet!
            else if (isLoreMode && minDist > EXIT_DIST && !isMenuTriggeredLore) {
                endLoreMode();
            }
        } // End updateLoreSystem

        // NEW: Restore Main Audio Function (Replaces basic endLoreMode logic)
        function getActiveContentKey() {
            if (isLoreMode && activeLoreId) return `lore${activeLoreId}`;
            return MAIN_CONTENT_KEY;
        }

        function clearContentState(key) {
            if (!key) return;
            if (window.PlayerStateManager) {
                window.PlayerStateManager.clear(key);
            }

            if (key === MAIN_CONTENT_KEY) {
                mainAudioState.time = 0;
                mainAudioState.wasPlaying = false;
            } else if (key.startsWith('lore')) {
                const loreId = parseInt(key.replace('lore', ''), 10);
                if (Number.isFinite(loreId)) {
                    loreData.resumeTimes[loreId] = 0;
                }
            }
        }

        function isCurrentContentCompleted() {
            if (!subtitleTracks || subtitleTracks.length === 0) return false;
            const t = audioPlayer.currentTime || 0;
            const duration = audioPlayer.duration || 0;
            const reachedAudioEnd = duration > 0 && t >= Math.max(0, duration - 0.25);
            const reachedSubtitleEnd = currentSubtitleIndex >= subtitleTracks.length - 1;
            return reachedAudioEnd && reachedSubtitleEnd;
        }

        async function saveCurrentContentState(options = {}) {
            const {
                keyOverride = null,
                clear = false,
                preferCachedTime = false,
                reason = 'unspecified'
            } = options;

            const key = keyOverride || getActiveContentKey();
            if (!key || !audioPlayer) return;

            if (clear) {
                clearContentState(key);
                indexDebug.lastSave = { key, cleared: true, reason, at: Date.now() };
                indexDebugNote('state-clear', `${key} (${reason})`);
                return;
            }

            try {
                let currentTime = audioPlayer.currentTime || 0;
                if (!preferCachedTime && typeof audioPlayer.getAccurateCurrentTime === 'function') {
                    currentTime = await audioPlayer.getAccurateCurrentTime(800);
                }

                const wasPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !audioPlayer.paused;

                if (window.PlayerStateManager) {
                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        const sentence = window.PlayerStateManager.findSentenceStart(currentTime, subtitleTracks);
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: sentence.index,
                            sentenceTime: sentence.time,
                            wasPlaying
                        });

                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: sentence.index,
                            sentenceTime: Number((sentence.time || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} -> ${sentence.time.toFixed(2)}s idx=${sentence.index} play=${wasPlaying} (${reason})`);
                    } else {
                        window.PlayerStateManager.saveState(key, subtitleTracks, audioPlayer);
                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: null,
                            sentenceTime: Number((currentTime || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} (legacy) ${currentTime.toFixed(2)}s (${reason})`);
                    }
                }

                if (key === MAIN_CONTENT_KEY) {
                    mainAudioState.wasPlaying = wasPlaying;
                    mainAudioState.time = currentTime || 0;
                    mainAudioState.tracks = [...subtitleTracks];
                } else if (key.startsWith('lore')) {
                    const loreId = parseInt(key.replace('lore', ''), 10);
                    if (Number.isFinite(loreId)) {
                        loreData.resumeTimes[loreId] = currentTime || 0;
                    }
                }
            } catch (e) {
                console.warn('[State] saveCurrentContentState failed:', e);
                indexDebugNote('state-error', `${reason}: ${e && e.message ? e.message : e}`);
            }
        }

        async function ensureMainTextLoaded() {
            if (window.mainTextContent && window.mainTextContent.length > 0) {
                return window.mainTextContent;
            }
            const response = await fetch('assets/kapitel1.txt');
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            window.mainTextContent = await response.text();
            return window.mainTextContent;
        }

        async function ensureLoreTextLoaded(id) {
            if (loreData.text[id] && loreData.text[id].length > 0) {
                return loreData.text[id];
            }

            const content = window.GameState?.getLore(id);
            const textPath = content ? content.text : `assets/lore${id}.txt`;
            const response = await fetch(textPath);
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            loreData.text[id] = await response.text();
            return loreData.text[id];
        }

        function findSubtitleIndexForTime(timeSec) {
            if (!subtitleTracks || subtitleTracks.length === 0) return 0;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (timeSec >= subtitleTracks[i].time) return i;
            }
            return 0;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForContentSwitchIdle(reason, timeoutMs = 2200) {
            const endAt = Date.now() + Math.max(300, timeoutMs || 0);
            let waited = 0;
            while (contentSwitchInProgress && Date.now() < endAt) {
                await wait(60);
                waited += 60;
            }
            if (contentSwitchInProgress) {
                indexDebugNote('switch-wait-timeout', `${reason || 'unknown'} waited=${waited}ms`);
            } else if (waited > 0) {
                indexDebugNote('switch-wait', `${reason || 'unknown'} waited=${waited}ms`);
            }
        }

        async function seekAndSyncSubtitle(targetTime, reason) {
            const safeTarget = Math.max(0, Number(targetTime) || 0);
            let seekResult = {
                ok: false,
                target: safeTarget,
                position: audioPlayer.currentTime || 0,
                attempts: 0
            };

            try {
                if (typeof audioPlayer.seekAndConfirm === 'function') {
                    seekResult = await audioPlayer.seekAndConfirm(safeTarget, {
                        maxAttempts: 5,
                        settleMs: 220,
                        tolerance: 0.9
                    });
                } else {
                    audioPlayer.currentTime = safeTarget;
                    await wait(260);
                    const pos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                        ? await audioPlayer.getAccurateCurrentTime(900)
                        : (audioPlayer.currentTime || 0);
                    seekResult = {
                        ok: Math.abs(pos - safeTarget) <= 1.0 || pos >= safeTarget - 1.0,
                        target: safeTarget,
                        position: pos,
                        attempts: 1
                    };
                }
            } catch (e) {
                indexDebugNote('seek-error', `${reason}: ${e && e.message ? e.message : e}`);
            }

            const effectiveTime = Number.isFinite(seekResult.position) ? seekResult.position : safeTarget;
            currentSubtitleIndex = findSubtitleIndexForTime(effectiveTime);
            renderSubtitleLines(currentSubtitleIndex);
            indexDebugNote('seek', `${reason} target=${safeTarget.toFixed(2)} pos=${effectiveTime.toFixed(2)} ok=${seekResult.ok} tries=${seekResult.attempts}`);
            return seekResult;
        }

        async function pauseWithFade(duration = 800) {
            if (!audioPlayer || audioPlayer.paused) return;
            await new Promise(resolve => {
                fadeAudio(audioPlayer, 0, duration, () => {
                    audioPlayer.pause();
                    resolve();
                });
            });
        }

        async function verifyPlaybackStarted(retries = 2, delayMs = 320) {
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    await audioPlayer.play();
                } catch (e) {
                    console.warn(`[Audio] play() failed on attempt ${attempt + 1}:`, e);
                }

                await wait(delayMs);
                const currentPos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                    ? await audioPlayer.getAccurateCurrentTime(700)
                    : (audioPlayer.currentTime || 0);
                indexDebugNote('play-check', `attempt=${attempt + 1} paused=${audioPlayer.paused} t=${currentPos.toFixed(2)}`);
                if (!audioPlayer.paused) {
                    return true;
                }
            }
            return false;
        }

        async function restoreMainAudio(options = {}) {
            const {
                saveCurrent = true
            } = options;

            if (!isLoreMode && !contentSwitchInProgress) {
                return;
            }

            if (contentSwitchInProgress) {
                return;
            }
            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;

            try {
                const loreIdBeforeSwitch = activeLoreId;
                if (saveCurrent && loreIdBeforeSwitch) {
                    await saveCurrentContentState({ keyOverride: `lore${loreIdBeforeSwitch}`, reason: 'restore-main:save-lore' });
                } else if (!saveCurrent && loreIdBeforeSwitch) {
                    clearContentState(`lore${loreIdBeforeSwitch}`);
                }

                isLoreMode = false;
                isMenuTriggeredLore = false;
                activeLoreId = null;
                activeLightSourceId = null;

                if (loreResumeTimeout) {
                    clearTimeout(loreResumeTimeout);
                    loreResumeTimeout = null;
                }

                uiContainer.classList.add('mode-switching');

                await pauseWithFade(700);
                if (switchToken !== contentSwitchToken) return;

                audioPlayer.src = getSCUrl(window.mainAudioUrl || 'assets/kapitel1.mp3');

                const mainText = await ensureMainTextLoaded();
                if (switchToken !== contentSwitchToken) return;
                parseSubtitles(mainText);

                const savedMain = window.PlayerStateManager ? window.PlayerStateManager.getState(MAIN_CONTENT_KEY) : null;
                const resumeTime = savedMain && savedMain.sentenceTime !== undefined
                    ? savedMain.sentenceTime
                    : Math.max(0, mainAudioState.time || 0);
                indexDebugNote('restore-main', `resume=${resumeTime.toFixed(2)}s saved=${!!savedMain}`);
                await seekAndSyncSubtitle(resumeTime, 'restore-main:pre-play');

                const shouldResumePlayback = savedMain ? !!savedMain.wasPlaying : !!mainAudioState.wasPlaying;
                if (shouldResumePlayback) {
                    audioPlayer.volume = 0;
                    const started = await verifyPlaybackStarted(2, 320);
                    if (started) {
                        // Re-render subtitles at the already-seeked position without re-seeking
                        currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                        renderSubtitleLines(currentSubtitleIndex);
                        fadeAudio(audioPlayer, 1.0, 700);
                        iconPlay.style.display = 'none';
                        iconPause.style.display = 'block';
                    } else {
                        audioPlayer.volume = 1.0;
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else {
                    audioPlayer.volume = 1.0;
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error('[Switch] Failed to restore main audio:', e);
                indexDebugNote('restore-main-error', e && e.message ? e.message : String(e));
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                }
            }
        }

        async function startLoreMode(id, fromMenu = false) {
            if (isLoreMode && activeLoreId === id) return;
            if (contentSwitchInProgress) return;

            const content = window.GameState?.getLore(id) || {
                audio: loreData.audio[id] || `assets/lore${id}.mp3`,
                text: `assets/lore${id}.txt`
            };

            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;

            try {
                await saveCurrentContentState({ reason: `start-lore:${id}` });

                isLoreMode = true;
                activeLoreId = id;
                isMenuTriggeredLore = !!fromMenu;
                moveTarget = null;

                if (isReadingMode) {
                    uiContainer.classList.add('reading-mode');
                } else {
                    uiContainer.classList.remove('reading-mode');
                }
                uiContainer.classList.add('mode-switching');

                await pauseWithFade(800);
                if (switchToken !== contentSwitchToken) return;

                const loreText = await ensureLoreTextLoaded(id);
                if (switchToken !== contentSwitchToken) return;

                const loreAudioSrc = getSCUrl(content.audio || loreData.audio[id] || `assets/lore${id}.mp3`);
                audioPlayer.src = loreAudioSrc;

                parseSubtitles(loreText);
                const savedLore = window.PlayerStateManager ? window.PlayerStateManager.getState(`lore${id}`) : null;
                const resumeTime = savedLore && savedLore.sentenceTime !== undefined
                    ? savedLore.sentenceTime
                    : Math.max(0, loreData.resumeTimes[id] || 0);
                indexDebugNote('start-lore', `id=${id} resume=${resumeTime.toFixed(2)}s saved=${!!savedLore} fromMenu=${!!fromMenu}`);
                await seekAndSyncSubtitle(resumeTime, `start-lore:${id}:pre-play`);

                audioPlayer.volume = 0;
                const started = await verifyPlaybackStarted(3, 320);
                if (switchToken !== contentSwitchToken) return;

                if (started) {
                    // Re-render subtitles at the already-seeked position without re-seeking
                    currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                    renderSubtitleLines(currentSubtitleIndex);
                    fadeAudio(audioPlayer, 1.0, 900);
                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';
                } else {
                    audioPlayer.volume = 1.0;
                    console.warn(`[Switch] Lore ${id} loaded but playback did not start.`);
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error(`[Switch] Failed to start lore ${id}:`, e);
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                }
            }
        }

        function endLoreMode() {
            restoreMainAudio({ saveCurrent: true });
        }

        function fadeAudio(audio, targetVolume, duration, callback) {
            const startVolume = audio.volume;
            const diff = targetVolume - startVolume;
            const startTime = Date.now();

            function tick() {
                const now = Date.now();
                const progress = Math.min(1, (now - startTime) / duration);
                audio.volume = startVolume + diff * progress;

                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (callback) {
                    callback();
                }
            }
            tick();
        }


    </script>
</body>

</html>