<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heidelberg RPG</title>
    <!-- SoundCloud Widget API & System -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="assets/js/SoundCloudURLs.js"></script>
    <script src="assets/js/shared-game-systems.js"></script>
    <script src="assets/js/PlayerStateManager.js"></script>
    <script src="assets/js/ChapterAutoplayIntent.js"></script>
    <script src="assets/js/AudioVisibilityManager.js"></script>
    <script src="assets/js/SCAudioAdapter.js"></script> <!-- Adapter AFTER Managers so it can register itself -->
    <script src="assets/js/GlobalVisualDimmer.js"></script>
    <!-- Main Stylesheet (extracted during refactoring) -->
    <link rel="stylesheet" href="assets/css/main.css">
    <!-- Critical inline CSS for loading screen (above-the-fold) -->
    <style>
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #444;
            font-family: 'Segoe UI', system-ui, sans-serif;
            transition: opacity 1s ease;
        }

        #loading-screen .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .subtitle-current {
            font-weight: 500 !important;
        }

        #subtitleRecenterBtn {
            position: fixed;
            top: -9999px;
            left: -9999px;
            display: none;
            pointer-events: auto;
            opacity: 0.92;
            z-index: 2600;
        }

        #subtitleRecenterBtn svg {
            width: 22px;
            height: 22px;
        }

        #subtitleRecenterMobileRadius {
            position: fixed;
            width: 500px;
            height: 500px;
            left: -9999px;
            top: -9999px;
            display: none;
            pointer-events: none;
            border: none;
            border-radius: 50%;
            background: transparent;
            box-shadow: none;
            z-index: 2598;
        }
    </style>
</head>

<body>



    <!-- LOADING SCREEN (Ã¼ber ALLEM) -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING...</p>
    </div>

    <!-- SVG Filter Definitionen -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1"
        xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- PAL Filter: Horizontal Blur + leichte Farbverschiebung -->
            <filter id="pal-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.6 0" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="
                    0.9 0.1 0.0 0 0
                    0.0 0.9 0.1 0 0
                    0.0 0.0 0.9 0 0
                    0   0   0   1 0" result="colored" />
            </filter>

            <!-- Glitch Filter: Turbulenz Displacement -->
            <!-- Glitch Filter: Turbulenz Displacement -->
            <filter id="glitch-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.002 0.005" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="baseFrequency" dur="60s" values="0.002 0.005;0.005 0.01;0.002 0.005"
                        repeatCount="indefinite" />
                    <animate attributeName="seed" dur="3s" values="0;100;0" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R"
                    yChannelSelector="G" />
            </filter>
        </defs>
    </svg>

    <!-- DropZone removed for Electron App -->

    <div id="processingInfo">
        <div class="spinner"></div>
        <div>Verarbeite Karte...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>

    <!-- MAIN GAME AREA -->
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="crtOverlay"></div>
    </div>

    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer" class="reader-layout-timestamps">
            <!-- Dynamisch generierte Zeilen -->
        </div>

        <!-- Next Chapter Button (Hidden by default) -->
        <button id="nextChapterBtn">Weiter</button>

        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn" tabindex="-1">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" tabindex="-1" aria-label="Inhalt">
                    <img src="data:image/png;base64,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" alt="Buch"
                        style="width: 24px; height: 24px;" />
                </button>

                <button id="readingModeBtn" class="audio-btn" title="Lesemodus aktivieren" tabindex="-1"
                    aria-label="Lesemodus aktivieren">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="sceneDimmerToggleBtn" class="audio-btn" title="Hintergrund abdunkeln" tabindex="-1"
                    aria-label="Hintergrunddimmer aus">
                    <svg id="sceneDimmerIconFull" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="8"></circle>
                        <circle cx="12" cy="12" r="6" fill="white" stroke="none"></circle>
                    </svg>
                    <svg id="sceneDimmerIconHalf" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="8"></circle>
                        <path d="M12 4a8 8 0 0 0 0 16z" fill="white" stroke="none"></path>
                    </svg>
                    <svg id="sceneDimmerIconCrescent" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <path d="M16.5 4.5A8 8 0 1 0 16.5 19A6.8 6.8 0 1 1 16.5 4.5Z" fill="white" stroke="white">
                        </path>
                    </svg>
                    <svg id="sceneDimmerIconSun" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="4" fill="white" stroke="none"></circle>
                        <path d="M12 2v3"></path>
                        <path d="M12 19v3"></path>
                        <path d="M2 12h3"></path>
                        <path d="M19 12h3"></path>
                        <path d="M4.9 4.9l2.1 2.1"></path>
                        <path d="M17 17l2.1 2.1"></path>
                        <path d="M19.1 4.9L17 7"></path>
                        <path d="M7 17l-2.1 2.1"></path>
                    </svg>
                </button>
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild" tabindex="-1">
                    <!-- ENTER FULLSCREEN (Corners pointing OUT) -->
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square">
                        <path d="M7 10V7h3" />
                        <path d="M17 10V7h-3" />
                        <path d="M17 14v3h-3" />
                        <path d="M7 14v3h3" />
                    </svg>
                    <!-- EXIT FULLSCREEN (Corners pointing IN) -->
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square" style="display:none;">
                        <path d="M4 14h6v6" />
                        <path d="M20 14h-6v6" />
                        <path d="M20 10h-6V4" />
                        <path d="M4 10h6V4" />
                    </svg>
                </button>
                <button id="subtitleRecenterBtn" class="audio-btn" title="Text auf aktuelle Stelle zentrieren"
                    aria-label="Text auf aktuelle Stelle zentrieren" tabindex="-1" type="button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 7h10" />
                        <path d="M3 12h10" />
                        <path d="M3 17h10" />
                        <path d="M14 12h7" />
                        <path d="M18 9l3 3-3 3" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <div id="sceneDimmerOverlay" aria-hidden="true"></div>

    <!-- ARCHIVE MODAL (INHALT) -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title-wrap">
                    <button class="archive-primary-btn active" id="archivePrimaryInhaltBtn"
                        type="button">Inhalt</button>
                    <button class="archive-primary-btn archive-primary-gear" id="archivePrimarySettingsBtn"
                        type="button" aria-label="Einstellungen" title="Einstellungen">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7"
                            stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <path
                                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 0 0-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 0 0-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 0 0-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 0 0-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 0 0 1.066-2.573c-.94-1.543.826-3.31 2.37-2.37c.996.608 2.296.07 2.572-1.065z">
                            </path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                    </button>
                </div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>

            <div class="archive-tabs">
                <button class="archive-tab active" data-tab="kapitel">Kapitel</button>
                <button class="archive-tab" data-tab="lore">Lore</button>
                <button class="archive-tab" data-tab="lesezeichen">Lesezeichen</button>
            </div>

            <div class="archive-tab-content active" data-tab="kapitel">
                <!-- KAPITEL -->
                <div class="col-left" id="chapterList" style="flex:1;">
                    <!-- Hardcoded Chapter 1 -->
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Der Marktplatz</div>
                    </div>

                    <!-- Chapter 1b -->
                    <div class="menu-item" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Liminal Library</div>
                    </div>

                    <!-- Chapter 1c -->
                    <div class="menu-item" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse</div>
                    </div>
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lore">
                <!-- LORE -->
                <div class="col-left" id="loreList" style="flex:1;">
                    <!-- Dynamisch gefÃ¼llt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lesezeichen">
                <!-- LESEZEICHEN -->
                <div id="bookmarkList" style="width:100%;">
                    <!-- Dynamisch gefÃ¼llt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="einstellungen">
                <div class="reader-settings-panel">
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Satztechnik</div>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="blaettern">
                            <span>Bl&auml;ttern</span>
                        </label>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="timestamps" checked>
                            <span>Timestamps</span>
                        </label>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="flat">
                            <span>Flattersatz</span>
                        </label>
                    </div>
                    <div class="reader-settings-group">
                        <label class="reader-settings-title" for="readerFontSizeRange">SchriftgrÃ¶ÃŸe</label>
                        <div class="reader-size-row">
                            <input id="readerFontSizeRange" type="range" min="14" max="30" step="1" value="18">
                            <input id="readerFontSizeNumber" type="number" min="14" max="30" step="1" value="18">
                            <span class="reader-size-unit">px</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Lautst&auml;rke</div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerTextVolumeRange">Text</label>
                            <input id="readerTextVolumeRange" type="range" min="0" max="100" step="1" value="100">
                            <input id="readerTextVolumeNumber" type="number" min="0" max="100" step="1" value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerBackgroundVolumeRange">Hintergrund</label>
                            <input id="readerBackgroundVolumeRange" type="range" min="0" max="100" step="1" value="100">
                            <input id="readerBackgroundVolumeNumber" type="number" min="0" max="100" step="1"
                                value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Farben</div>
                        <div class="reader-color-field">
                            <button id="readerBgColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerBgColorPickerPopover">
                                <span class="reader-color-row-label">Hintergrund</span>
                                <span class="reader-color-preview" id="readerBgColorPreview"></span>
                            </button>
                            <div id="readerBgColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerBgColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerBgColorMarker" class="reader-wheel-marker" aria-hidden="true"></div>
                                </div>
                            </div>
                        </div>
                        <div class="reader-color-field">
                            <button id="readerTextColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerTextColorPickerPopover">
                                <span class="reader-color-row-label">Schrift</span>
                                <span class="reader-color-preview" id="readerTextColorPreview"></span>
                            </button>
                            <div id="readerTextColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerTextColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerTextColorMarker" class="reader-wheel-marker" aria-hidden="true">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="readerColorResetBtn" class="reader-color-reset-btn" type="button">Farben
                            zur&uuml;cksetzen</button>
                    </div>
                </div>
            </div>

            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; display: flex; gap: 20px; justify-content: center;">
                <button id="btnSaveData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">SAVE
                    (Export)</button>
                <button id="btnLoadData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">LOAD
                    (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <!-- Shared Game Systems (Particle, Cloud, YellowLight) for code sharing - LOADED IN HEAD -->

    <script>
        // ============================================
        // SETUP & FILTER LOGIK
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const controlsHint = document.getElementById('controlsHint');



        const processingInfo = document.getElementById('processingInfo');
        const gameWrapper = document.getElementById('gameWrapper');

        // PAL + CRT Effekte permanent aktiviert
        console.log("Applying Visual Fixes..."); // DEBUG
        gameWrapper.classList.add('effect-pal');
        gameWrapper.classList.add('effect-crt');
        const isIOSDevice = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const AUDIO_PROFILE = isIOSDevice
            ? { ambient: 0.012, footsteps: 0.014 }
            : { ambient: 0.02, footsteps: 0.024 };
        if (isIOSDevice) {
            // SVG PAL filter is expensive on iOS WebKit and causes visible stutter.
            gameWrapper.classList.remove('effect-pal');
        }

        // Turbulenz fÃ¼r Glitch laufend aktualisieren fÃ¼r "Randomness"
        // const turb = document.querySelector('#glitch-filter feTurbulence');
        // const disp = document.querySelector('#glitch-filter feDisplacementMap');

        // Glitch Loop: Manchmal stÃ¤rker, manchmal schwÃ¤cher
        // setInterval(() => {
        //     if (Math.random() > 0.95) {
        //         // Kurzer starker Glitch
        //         disp.setAttribute('scale', (Math.random() * 30 + 10).toString());
        //         turb.setAttribute('seed', Math.floor(Math.random() * 100).toString());
        //         setTimeout(() => {
        //             disp.setAttribute('scale', '4'); // ZurÃ¼ck zu subtil
        //         }, 100);
        //     }
        // }, 500);

        let gameReady = false;

        // ============================================
        // MULTI-LEVEL CONFIG (URL-Parameter: ?chapter=kapitel1c)
        // ============================================
        const _urlParams = new URLSearchParams(window.location.search);
        const _chapterParam = _urlParams.get('chapter');
        const LEVEL_CONFIGS = {
            kapitel1: {
                sceneName: 'marktplatz',
                contentKey: 'kapitel1',
                mapFile: 'assets/platz3.png',
                audioUrl: 'assets/kapitel1.mp3',
                subtitleFile: 'assets/kapitel1.txt',
                activeChapterBtn: 'chapter1Btn',
                nextChapterTarget: 'liminal library.html',
                page: 'index.html',
                chapterLabel: '1a',
                chapterTitle: 'Der Marktplatz',
            },
            kapitel1c: {
                sceneName: 'steingasse',
                contentKey: 'kapitel1c',
                mapFile: 'assets/kapitel1c.png',
                audioUrl: 'assets/kapitel1c.mp3',
                subtitleFile: 'assets/kapitel1c.txt',
                activeChapterBtn: 'chapter1cBtn',
                nextChapterTarget: null,
                page: 'index.html?chapter=kapitel1c',
                chapterLabel: '1c',
                chapterTitle: 'Steingasse',
            }
        };
        const LEVEL = LEVEL_CONFIGS[_chapterParam] ?? LEVEL_CONFIGS['kapitel1'];

        const SCENE_NAME = LEVEL.sceneName;
        let bgImage = null;
        let foregroundImage = null;
        let spriteReady = false;
        let collisionData = [];   // true = Wand
        let foregroundData = [];  // true = Vordergrund (verdeckt Spieler)
        let flowData = [];        // true = Magischer Fluss (GrÃ¼n)
        let magentaPixels = [];
        let cyanPixels = new Set();
        let greenPixels = [];     // Zum Verstecken
        let yellowLights = [];    // Lore Lights (Global)
        let autoWalkPath = [];
        let autoWalkIndex = 0;
        // isReadingMode is defined later in AUDIO & SUBTITLE SYSTEM

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================
        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        let GameState = null; // Will be loaded dynamically

        let mainAudioState = { time: 0, wasPlaying: false, tracks: [] };
        let activeLoreId = null;
        let activeLightSourceId = null;
        let isLoreMode = false;
        let isMenuTriggeredLore = false;
        let loreResumeTimeout = null;
        const MAIN_CONTENT_KEY = LEVEL.contentKey;
        let contentSwitchInProgress = false;
        let contentSwitchToken = 0;
        const mainChapterAutoplayIntent = window.ChapterAutoplayIntent
            ? window.ChapterAutoplayIntent.consume(MAIN_CONTENT_KEY, { defaultPolicy: 'auto' })
            : { policy: 'auto', shouldAutoplay: true, source: 'fallback', reason: 'intent-missing' };

        function markChapterAutoplayIntent(targetPageKey, policy = 'auto', reason = '') {
            if (!window.ChapterAutoplayIntent || !targetPageKey) return;
            if (policy === 'manual') {
                window.ChapterAutoplayIntent.markManual(targetPageKey, MAIN_CONTENT_KEY, reason || 'chapter-menu');
                return;
            }
            window.ChapterAutoplayIntent.markAuto(targetPageKey, MAIN_CONTENT_KEY, reason || 'auto-transition');
        }

        const loreData = {
            audio: {},
            text: {},
            resumeTimes: {}
        };

        // ============================================
        // DEBUG (disabled in production UI)
        // ============================================
        const indexDebug = {
            lastSave: null
        };

        function indexDebugNote() { }
        function indexTrace() { }

        function writeStateHandoff(targetPageKey) {
            try {
                if (!window.PlayerStateManager || typeof window.PlayerStateManager.exportStates !== 'function') return;
                const states = window.PlayerStateManager.exportStates();
                const payload = {
                    from: MAIN_CONTENT_KEY,
                    to: targetPageKey,
                    at: Date.now(),
                    states
                };
                sessionStorage.setItem('gb_state_handoff', JSON.stringify(payload));
                sessionStorage.setItem('gb_handoff_expect', String(targetPageKey || ''));
                indexDebugNote('handoff-out', `to=${targetPageKey} states=${Object.keys(states).length}`);
            } catch (e) {
                indexDebugNote('handoff-out-error', e && e.message ? e.message : String(e));
            }
        }

        function mergeIncomingStateHandoff(expectedTargetKey) {
            try {
                const raw = sessionStorage.getItem('gb_state_handoff');
                const expected = sessionStorage.getItem('gb_handoff_expect');
                if (!raw || !window.PlayerStateManager) {
                    if (expected && expected === expectedTargetKey) {
                        indexDebugNote('handoff-in-missing', `expected=${expectedTargetKey}`);
                        sessionStorage.removeItem('gb_handoff_expect');
                    }
                    return;
                }

                const payload = JSON.parse(raw);
                if (!payload || payload.to !== expectedTargetKey || !payload.states || typeof payload.states !== 'object') {
                    return;
                }

                let merged = 0;
                for (const [key, incoming] of Object.entries(payload.states)) {
                    if (!incoming || typeof incoming !== 'object') continue;
                    const current = window.PlayerStateManager.getState(key);
                    const incomingStamp = Number(incoming.lastUpdate || 0);
                    const currentStamp = Number((current && current.lastUpdate) || 0);
                    if (current && currentStamp > incomingStamp) continue;

                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: Number.isFinite(incoming.sentenceIndex) ? incoming.sentenceIndex : 0,
                            sentenceTime: Number.isFinite(incoming.sentenceTime) ? incoming.sentenceTime : 0,
                            wasPlaying: !!incoming.wasPlaying
                        });
                        merged++;
                    }
                }

                sessionStorage.removeItem('gb_state_handoff');
                sessionStorage.removeItem('gb_handoff_expect');
                indexDebugNote('handoff-in', `from=${payload.from || '-'} merged=${merged}`);
            } catch (e) {
                indexDebugNote('handoff-in-error', e && e.message ? e.message : String(e));
            }
        }

        mergeIncomingStateHandoff(MAIN_CONTENT_KEY);

        // Initialize GameState
        (async function initGameState() {
            try {
                const module = await import('./assets/js/GameState.js');
                GameState = module.GameState;
                window.GameState = GameState; // Global Ref
                await GameState.init();
                console.log("[Index] GameState Loaded & Initialized");

                // Populate loreData for compatibility (audio + text)
                const db = GameState.getAllLore();
                for (const [id, content] of Object.entries(db)) {
                    loreData.audio[id] = content.audio;
                    // Pre-fetch text for reliability
                    try {
                        const res = await fetch(content.text);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`[Init] Pre-loaded text for lore ${id}`);
                        }
                    } catch (e) {
                        console.warn(`[Init] Could not pre-load text for lore ${id}:`, e);
                    }
                }
            } catch (e) {
                console.error("Failed to load GameState:", e);
            }
        })();

        // Haupt-Audio je nach aktivem Level
        window.mainAudioUrl = LEVEL.audioUrl;

        // Unlock Logic Wrapper
        async function unlockLoreItem(id) {
            if (!GameState) return;
            const newUnlock = await GameState.unlockLore(id);
            if (newUnlock) {
                const item = GameState.getLore(id);
                showNotification(`Eintrag freigeschaltet: ${item ? item.title : 'Unbekannt'}`);
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('controlsHint');
            if (el) {
                el.innerText = msg;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
        }

        function triggerUiHaptic(pattern = 8) {
            if (typeof navigator === 'undefined' || typeof navigator.vibrate !== 'function') return;
            navigator.vibrate(pattern);
        }

        // --- ARCHIVE TAB SWITCHING ---
        function initArchiveTabs() {
            const tabs = Array.from(document.querySelectorAll('.archive-tab'));
            const panels = Array.from(document.querySelectorAll('.archive-tab-content'));
            const tabsBar = document.querySelector('.archive-tabs');
            const primaryInhaltBtn = document.getElementById('archivePrimaryInhaltBtn');
            const primarySettingsBtn = document.getElementById('archivePrimarySettingsBtn');
            const settingsPanel = document.querySelector('.archive-tab-content[data-tab="einstellungen"]');
            let lastContentTab = 'kapitel';

            const setPrimaryMode = (mode) => {
                const normalized = mode === 'einstellungen' ? 'einstellungen' : 'inhalt';

                if (primaryInhaltBtn) primaryInhaltBtn.classList.toggle('active', normalized === 'inhalt');
                if (primarySettingsBtn) primarySettingsBtn.classList.toggle('active', normalized === 'einstellungen');
                if (tabsBar) tabsBar.style.display = normalized === 'inhalt' ? '' : 'none';
            };

            const showContentTab = (target, activeTab = null) => {
                tabs.forEach((t) => t.classList.remove('active'));
                panels.forEach((p) => p.classList.remove('active'));

                const matchedTab = activeTab || tabs.find((t) => t.getAttribute('data-tab') === target) || null;
                if (matchedTab) {
                    matchedTab.classList.add('active');
                    lastContentTab = matchedTab.getAttribute('data-tab') || lastContentTab;
                }

                const panel = document.querySelector(`.archive-tab-content[data-tab="${lastContentTab}"]`);
                if (panel) panel.classList.add('active');
                if (lastContentTab === 'lesezeichen') renderBookmarks();
            };

            const showSettingsPanel = () => {
                tabs.forEach((t) => t.classList.remove('active'));
                panels.forEach((p) => p.classList.remove('active'));
                if (settingsPanel) settingsPanel.classList.add('active');
                if (typeof syncReaderSettingsUi === 'function') syncReaderSettingsUi();
            };

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    tab.classList.remove('pressed');
                    // Force reflow so the press animation retriggers on repeated clicks.
                    void tab.offsetWidth;
                    tab.classList.add('pressed');
                    setTimeout(() => tab.classList.remove('pressed'), 170);
                    const target = tab.getAttribute('data-tab');
                    setPrimaryMode('inhalt');
                    showContentTab(target, tab);
                });
            });

            if (primaryInhaltBtn) {
                primaryInhaltBtn.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    setPrimaryMode('inhalt');
                    showContentTab(lastContentTab);
                });
            }

            if (primarySettingsBtn) {
                primarySettingsBtn.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    setPrimaryMode('einstellungen');
                    showSettingsPanel();
                });
            }

            const initiallyActiveTab = tabs.find((tab) => tab.classList.contains('active'));
            if (initiallyActiveTab) {
                lastContentTab = initiallyActiveTab.getAttribute('data-tab') || 'kapitel';
            }
            setPrimaryMode('inhalt');
            showContentTab(lastContentTab, initiallyActiveTab || undefined);
        }
        initArchiveTabs();

        // --- BOOKMARK RENDERING ---
        const CURRENT_PAGE = LEVEL.page;
        const CURRENT_CHAPTER = LEVEL.chapterLabel;
        const CURRENT_CHAPTER_TITLE = LEVEL.chapterTitle;
        const BOOKMARK_PAGE_KEY_MAP = {
            'index.html': 'kapitel1',
            'liminal library.html': 'liminal_library',
            'index.html?chapter=kapitel1c': 'kapitel1c'
        };

        function resolveBookmarkPageKey(page) {
            return BOOKMARK_PAGE_KEY_MAP[page] || 'kapitel1';
        }

        function extractLoreIdFromBookmark(bm, fallbackKey = '') {
            const directLoreId = Number(bm && bm.loreId);
            if (Number.isFinite(directLoreId) && directLoreId > 0) return Math.trunc(directLoreId);

            const keyCandidate = (typeof fallbackKey === 'string' && fallbackKey)
                ? fallbackKey
                : (typeof (bm && bm.contentKey) === 'string' ? bm.contentKey : '');
            const keyMatch = keyCandidate.match(/^lore(\d+)$/i);
            if (keyMatch) return Number(keyMatch[1]);

            const chapterMatch = (typeof (bm && bm.chapter) === 'string' ? bm.chapter : '').match(/^lore(\d+)$/i);
            if (chapterMatch) return Number(chapterMatch[1]);

            const refs = [
                (typeof (bm && bm.audioRef) === 'string') ? bm.audioRef : '',
                (typeof (bm && bm.textRef) === 'string') ? bm.textRef : ''
            ];
            for (const ref of refs) {
                const m = ref.match(/lore(\d+)\.(?:mp3|txt)/i);
                if (m) return Number(m[1]);
            }
            return null;
        }

        function resolveBookmarkContentKey(bm) {
            if (bm && typeof bm.contentKey === 'string' && bm.contentKey.trim()) {
                return bm.contentKey.trim();
            }

            const loreId = extractLoreIdFromBookmark(bm);
            if (Number.isFinite(loreId) && loreId > 0) return `lore${loreId}`;

            if (bm && typeof bm.page === 'string' && BOOKMARK_PAGE_KEY_MAP[bm.page]) {
                return BOOKMARK_PAGE_KEY_MAP[bm.page];
            }
            return '';
        }

        async function ensureBookmarkContentForCurrentPage(bm, reason = 'bookmark') {
            await waitForContentSwitchIdle(`${reason}:pre`);

            const targetKey = resolveBookmarkContentKey(bm);
            if (!targetKey) return true; // Legacy bookmark without content metadata

            const currentKey = getActiveContentKey();
            if (targetKey === currentKey) return true;

            if (/^lore\d+$/i.test(targetKey)) {
                const loreId = extractLoreIdFromBookmark(bm, targetKey);
                if (!Number.isFinite(loreId) || loreId <= 0) {
                    console.warn('[Bookmark] Invalid lore target:', bm);
                    return false;
                }
                await startLoreMode(loreId, true);
                await waitForContentSwitchIdle(`${reason}:switch-lore`);
                return getActiveContentKey() === `lore${loreId}`;
            }

            if (targetKey === MAIN_CONTENT_KEY) {
                if (isLoreMode) {
                    await restoreMainAudio({ saveCurrent: true, forceResume: true });
                    await waitForContentSwitchIdle(`${reason}:switch-main`);
                }
                return getActiveContentKey() === MAIN_CONTENT_KEY;
            }

            return false;
        }

        function renderBookmarks() {
            const list = document.getElementById('bookmarkList');
            if (!list) return;
            list.innerHTML = '';

            if (!window.GameState) return;
            const bookmarks = window.GameState.getBookmarks();

            if (bookmarks.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bookmark-empty-msg';
                empty.innerText = 'Keine Lesezeichen gesetzt';
                list.appendChild(empty);
                return;
            }

            bookmarks.forEach(bm => {
                const item = document.createElement('div');
                item.className = 'menu-item bookmark-item';

                const mainText = document.createElement('div');
                mainText.className = 'item-main-text';
                const timeStr = window.GameState.formatBookmarkTime(bm.time);
                mainText.innerText = `${bm.chapterTitle} Â· ${timeStr}`;

                const subText = document.createElement('div');
                subText.className = 'item-sub-text';
                subText.innerText = bm.textPreview || '';

                const delBtn = document.createElement('button');
                delBtn.className = 'bookmark-delete-btn';
                delBtn.innerHTML = '&times;';
                delBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await window.GameState.removeBookmark(bm.id);
                    renderBookmarks();
                });

                item.appendChild(mainText);
                item.appendChild(subText);
                item.appendChild(delBtn);

                item.addEventListener('click', async () => {
                    document.getElementById('archiveModal').classList.remove('visible');
                    const targetPage = (typeof bm.page === 'string' && bm.page) ? bm.page : CURRENT_PAGE;
                    const targetContentKey = resolveBookmarkContentKey(bm);
                    const isLoreBookmark = /^lore\d+$/i.test(targetContentKey);

                    if (targetPage === CURRENT_PAGE || isLoreBookmark) {
                        const reason = isLoreBookmark
                            ? `bookmark:${bm.id}:lore-local`
                            : `bookmark:${bm.id}:same-page`;
                        const ready = await ensureBookmarkContentForCurrentPage(bm, reason);
                        if (!ready) {
                            console.warn('[Bookmark] Could not activate target content on current page.', bm);
                            return;
                        }
                        await seekAndSyncSubtitle(bm.time, `bookmark:${bm.id}`);
                        if (audioPlayer.paused) {
                            try { await audioPlayer.play(); } catch (_) { }
                        }
                    } else {
                        await waitForContentSwitchIdle('bookmark:cross-page');
                        await saveCurrentContentState({ reason: 'bookmark:navigate' });
                        sessionStorage.setItem('bookmark_seek_target', JSON.stringify(bm));
                        const key = resolveBookmarkPageKey(targetPage);
                        markChapterAutoplayIntent(key, 'manual', 'bookmark');
                        writeStateHandoff(key);
                        window.location.href = targetPage;
                    }
                });

                list.appendChild(item);
            });
        }

        // --- MENU LOGIC ---
        function renderArchive() {
            const list = document.getElementById('loreList');
            list.innerHTML = '';

            if (!window.GameState) return;

            const db = window.GameState.getAllLore();
            const collectedIds = window.GameState.state.collectedLore;

            if (collectedIds.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bookmark-empty-msg';
                empty.innerText = 'Keine Lore gefunden';
                list.appendChild(empty);
            } else {
                collectedIds.sort((a, b) => a - b).forEach(id => {
                    const content = db[id];
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'menu-item';

                    if (isLoreMode && activeLoreId === id) {
                        item.classList.add('active');
                    }

                    const mainText = document.createElement('div');
                    mainText.className = 'item-main-text';
                    mainText.innerText = content.title;

                    const subText = document.createElement('div');
                    subText.className = 'item-sub-text';
                    subText.innerText = content.duration;

                    item.appendChild(mainText);
                    item.appendChild(subText);

                    item.addEventListener('click', async () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        await waitForContentSwitchIdle(`menu:lore:${id}`);
                        await startLoreMode(id, true);
                    });
                    list.appendChild(item);
                });
            }
            // (Chapter Logic continues inside renderArchive)

            // Aktiven Kapitel-Button markieren
            document.querySelectorAll('#chapterList .menu-item').forEach(btn => btn.classList.remove('active'));
            const _activeCh = document.getElementById(LEVEL.activeChapterBtn);
            if (_activeCh) _activeCh.classList.add('active');

            // Chapter Logic (Left Column)
            const ch1 = document.getElementById('chapter1Btn');
            if (ch1) {
                const newCh1 = ch1.cloneNode(true);
                ch1.parentNode.replaceChild(newCh1, ch1);

                newCh1.addEventListener('click', async () => {
                    console.log("Loading Chapter 1...");
                    if (LEVEL.contentKey !== 'kapitel1') {
                        // Wir sind auf einem anderen Level â€“ navigiere zu Marktplatz
                        await waitForContentSwitchIdle('chapter-menu:to-1');
                        await saveCurrentContentState({ reason: 'chapter-menu:to-1' });
                        markChapterAutoplayIntent('kapitel1', 'manual', 'chapter-menu');
                        writeStateHandoff('kapitel1');
                        window.location.href = 'index.html';
                        return;
                    }
                    document.getElementById('archiveModal').classList.remove('visible');

                    // 1. RE-LOAD MAP (Only if needed)
                    // If we are already here, do not reload map!
                    // processMap(mapImg); // REMOVED to prevent reload

                    // 2. Audio Logic
                    if (isLoreMode) {
                        // If listening to Lore, switch back to Chapter
                        restoreMainAudio({ forceResume: true });
                    } else {
                        // If already in Chapter mode, maybe just unpause?
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        }
                    }
                });
            }

            // Chapter 1b Logic
            const ch1b = document.getElementById('chapter1bBtn');
            if (ch1b) {
                // Remove old listeners by cloning (if any exist spread from updates)
                const newCh1b = ch1b.cloneNode(true);
                ch1b.parentNode.replaceChild(newCh1b, ch1b);

                newCh1b.addEventListener('click', async () => {
                    console.log("Loading Chapter 1b...");
                    await waitForContentSwitchIdle('chapter-menu:to-1b');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1b' });
                    markChapterAutoplayIntent('liminal_library', 'manual', 'chapter-menu');
                    writeStateHandoff('liminal_library');
                    window.location.href = 'liminal library.html';
                });
            }

            // Chapter 1c Logic
            const ch1c = document.getElementById('chapter1cBtn');
            if (ch1c) {
                const newCh1c = ch1c.cloneNode(true);
                ch1c.parentNode.replaceChild(newCh1c, ch1c);

                newCh1c.addEventListener('click', async () => {
                    console.log("Loading Chapter 1c...");
                    if (LEVEL.contentKey === 'kapitel1c') {
                        // Bereits auf Steingasse â€“ Audio fortsetzen
                        document.getElementById('archiveModal').classList.remove('visible');
                        if (isLoreMode) {
                            restoreMainAudio({ forceResume: true });
                        } else {
                            if (audioPlayer.paused) {
                                audioPlayer.play();
                                iconPlay.style.display = 'none';
                                iconPause.style.display = 'block';
                            }
                        }
                        return;
                    }
                    await waitForContentSwitchIdle('chapter-menu:to-1c');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1c' });
                    markChapterAutoplayIntent('kapitel1c', 'manual', 'chapter-menu');
                    writeStateHandoff('kapitel1c');
                    window.location.href = 'index.html?chapter=kapitel1c';
                });
            }
        }

        // LEGACY - DEACTIVATED
        // LEGACY REMOVED

        // EVENT LISTENERS FOR ARCHIVE
        document.getElementById('bookBtn').addEventListener('click', () => {
            renderArchive();
            document.getElementById('archiveModal').classList.add('visible');
        });

        document.getElementById('closeArchiveBtn').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('visible');
        });

        // SAVE / LOAD LOGIC
        const btnSave = document.getElementById('btnSaveData');
        const btnLoad = document.getElementById('btnLoadData');
        const fileInput = document.getElementById('fileInputSave');

        if (btnSave) {
            btnSave.addEventListener('click', () => {
                if (!window.GameState) return;
                const json = window.GameState.exportState();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'liminal_save_' + Date.now() + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        if (btnLoad) {
            btnLoad.addEventListener('click', () => {
                if (fileInput) fileInput.click();
            });
        }

        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (window.GameState) {
                        const success = await window.GameState.importState(ev.target.result);
                        if (success) {
                            alert("Save Data Imported Successfully! Reloading...");
                            window.location.reload();
                        } else {
                            alert("Invalid Save File.");
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        // YellowLight class - now loaded from assets/js/shared-game-systems.js

        // Click-to-Move fÃ¼r Mobile
        let moveTarget = null; // {x, y} oder null

        // ============================================
        // PARTIKEL SYSTEM
        // ============================================
        const particles = [];
        const NUM_PARTICLES = 300; // Reduziert um 50%
        let particleSprite = null;

        // Spotlight-System: Sammelt Lichtquellen mit Richtung und IntensitÃ¤t
        let nearbyLights = []; // {x, y, intensity}

        // Dust-Particles: Staubwolken beim Laufen
        const dustParticles = [];

        // Screen-Shake bei Kollision
        let screenShake = 0;

        // Wolken-System (Parallax, selten)
        const clouds = [];
        const MAX_CLOUDS = 3;
        let cloudSpawnTimer = 0;

        // Cloud class and initClouds() - now loaded from assets/js/shared-game-systems.js

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        const footstepSound = new SCAudioAdapter();
        footstepSound.src = getSCUrl('assets/footsteps.mp3');
        footstepSound.volume = AUDIO_PROFILE.footsteps;
        // Index uses its own lifecycle handler below; avoid double pause/resume races.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(footstepSound);
        }

        const SHIMMER_BASE_VOLUME = 0.4;
        const shimmerSound = new SCAudioAdapter();
        shimmerSound.src = getSCUrl('assets/shimmer.mp3');
        shimmerSound.volume = SHIMMER_BASE_VOLUME;
        // One-shot SFX should not auto-resume after visibility changes.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(shimmerSound);
        }
        let lastShimmerLightId = null;
        let footstepPlaying = false;

        let audioUnlocked = false;

        // createGlowSprite(), Particle class, and initParticles()
        // now loaded from assets/js/shared-game-systems.js

        // ============================================
        // LORE PERSISTENCE - Uses GameState module
        // ============================================
        // NOTE: LoreSystem object was REMOVED (redundant with GameState.js)
        // All lore persistence is now handled by GameState:
        // - GameState.unlockLore(id) - unlock a lore entry
        // - GameState.isUnlocked(id) - check if unlocked
        // - GameState.collectLight(sceneName, lightId) - mark light as collected
        // - GameState.isLightCollected(sceneName, lightId) - check light status


        let mapW = 0, mapH = 0;

        // Dynamische AuflÃ¶sung
        let SCREEN_W = 320;
        let SCREEN_H = 240;

        function updateDimensions() {
            // Robust Responsive Logic
            // Aim for maintaining pixel density while filling the screen.
            // Base resolution reference: 320x240 (4:3)

            const targetRatio = 320 / 240; // 1.333
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const winRatio = winW / winH;

            if (winRatio > targetRatio) {
                // Window is wider than 4:3 (Landscape / Wide)
                // Fix Height at 240, expand Width
                SCREEN_H = 240;
                SCREEN_W = Math.ceil(SCREEN_H * winRatio);
            } else {
                // Window is taller/narrower than 4:3 (Portrait / Square)
                // Fix Width at 320, expand Height
                SCREEN_W = 320;
                SCREEN_H = Math.ceil(SCREEN_W / winRatio);
            }

            // Canvas GrÃ¶ÃŸe aktualisieren
            if (canvas) {
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;
            }
            console.log(`Resolution updated: ${SCREEN_W}x${SCREEN_H} (Win: ${winW}x${winH}, Ratio: ${winRatio.toFixed(2)})`);
        }

        // Initial und bei Resize
        // Initial resize
        updateDimensions(); // Keep the original initial call
        window.addEventListener('resize', () => { // Keep the original resize listener
            updateDimensions();
            // Auch Subtitles neu rendern falls nÃ¶tig
            if (isReadingMode && subtitleTracks.length > 0) {
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // --- VISUAL CALIBRATION TOOL ---
        let params = {
            brightness: 1.15,
            contrast: 1.10,
            saturate: 0.85
        };
        let activeParam = 'brightness';

        const dispBrit = document.getElementById('dispBrit');
        const dispCont = document.getElementById('dispCont');
        const dispSat = document.getElementById('dispSat');
        const dispSel = document.getElementById('dispSel');
        const debugCanvas = document.getElementById('gameCanvas');

        window.addEventListener('keydown', (e) => {
            // Select Parameter (only if debug elements exist)
            if (e.key === '1') { activeParam = 'brightness'; if (dispSel) dispSel.innerText = 'Brightness'; }
            if (e.key === '2') { activeParam = 'contrast'; if (dispSel) dispSel.innerText = 'Contrast'; }
            if (e.key === '3') { activeParam = 'saturate'; if (dispSel) dispSel.innerText = 'Saturation'; }

            // Adjust
            if (e.key === '+' || e.key === 'Add' || e.key === '=') {
                params[activeParam] = Math.round((params[activeParam] + 0.05) * 100) / 100;
                updateVisuals();
            } else if (e.key === '-' || e.key === 'Subtract' || e.key === '_') {
                params[activeParam] = Math.round((params[activeParam] - 0.05) * 100) / 100;
                updateVisuals();
            }
        });

        function updateVisuals() {
            // Apply override to canvas
            // Standard PAL structure
            if (debugCanvas) debugCanvas.style.filter = `url(#pal-filter) contrast(${params.contrast}) brightness(${params.brightness}) saturate(${params.saturate})`;

            if (dispBrit) dispBrit.innerText = params.brightness.toFixed(2);
            if (dispCont) dispCont.innerText = params.contrast.toFixed(2);
            if (dispSat) dispSat.innerText = params.saturate.toFixed(2);

            console.log(`Params: B=${params.brightness}, C=${params.contrast}, S=${params.saturate}`);
        }
        // Initialize with default values once to ensure UI matches
        // updateVisuals();
        // End of VISUAL CALIBRATION TOOL

        let camX = 0, camY = 0;
        let targetCamX = 0, targetCamY = 0;

        // Sprite Sheet Konfiguration
        const SPRITE = {
            frameWidth: 0,   // Wird berechnet
            frameHeight: 0,  // Wird berechnet
            cols: 4,         // 4 Frames pro Reihe
            baseScale: 0.15, // Original Skalierung
            scale: 0.15      // Dynamische Skalierung
        };

        // Spieler
        const player = {
            x: 50, y: 50,
            w: 14, h: 8,      // Kollisionsbox (FÃ¼ÃŸe)
            speed: 35,        // Pixels per second (was 0.54 per frame)
            dir: 0,           // 0=down, 1=up, 2=left, 3=right
            frame: 0,         // 0-3 fÃ¼r Animation
            animTimer: 0,
            isMoving: false,
            isBehindForeground: false
        };

        const keys = {};

        // ============================================
        // SPRITES LADEN (alle 4 Richtungen)
        // ============================================
        let spriteFront = null;   // Frontalansicht (down)
        let spriteBack = null;    // RÃ¼ckenansicht (up)
        let spriteSide = null;    // Seitenansicht (right, links wird gespiegelt)
        let spritesLoaded = 0;
        const TOTAL_SPRITES = 3;

        function loadAllSprites() {
            // Frontal (nach unten schauend, NEU: spriteneu.png)
            spriteFront = new Image();
            spriteFront.onload = function () {
                // WICHTIG: Math.floor() fÃ¼r ganzzahlige Frame-Breite!
                SPRITE.frameWidth = Math.floor(this.width / SPRITE.cols); // Fallback-Wert, wird fÃ¼r DrawCoords Ã¼berschrieben
                SPRITE.frameHeight = this.height;
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log(`Sprite Front (New) geladen: ${this.width}x${this.height}`);
            };
            spriteFront.src = 'assets/spriteneu.png';
            spriteFront.onerror = () => console.warn('assets/spriteneu.png nicht gefunden');

            // RÃ¼cken (nach oben schauend, NEU: spriterueckenneu.png)
            spriteBack = new Image();
            spriteBack.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Back (New) geladen');
            };
            spriteBack.src = 'assets/spriterueckenneu.png';
            spriteBack.onerror = () => console.warn('assets/spriterueckenneu.png nicht gefunden');

            // Seitlich (fÃ¼r rechts, links wird gespiegelt)
            spriteSide = new Image();
            spriteSide.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Side (New) geladen');
            };
            spriteSide.src = 'assets/seitlichneu.png';
            spriteSide.onerror = () => console.warn('assets/seitlichneu.png nicht gefunden');
        }

        // Front (spriteneu.png)
        const FRONT_SPRITE_DATA = [
            { left: 38, width: 141, footX: 106, footY: 267 },
            { left: 201, width: 138, footX: 273, footY: 265 },
            { left: 361, width: 140, footX: 436, footY: 270 },
            { left: 534, width: 137, footX: 604, footY: 268 }
        ];
        // Ping-Pong Animation fÃ¼r Front (0-1-2-3-2-1)
        const FRONT_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        // Back (spriterueckenneu.png)
        const BACK_SPRITE_DATA = [
            { left: 16, width: 147, footX: 90, footY: 282 },
            { left: 177, width: 144, footX: 253, footY: 283 },
            { left: 336, width: 152, footX: 417, footY: 285 }
        ];
        // Ping-Pong Animation fÃ¼r Back (0-1-2-1)
        const BACK_ANIM_CYCLE = [0, 1, 2, 1];

        // NEU: Marker-Daten fÃ¼r seitlichneu.png (X, Y)
        const SIDE_SPRITE_DATA = [
            { left: 20, footX: 92, footY: 275 },
            { left: 200, footX: 268, footY: 281 },
            { left: 372, footX: 440, footY: 280 },
            { left: 528, footX: 595, footY: 284 }
        ];

        // Ping-Pong Animation fÃ¼r Seitlich (0-1-2-3-2-1)
        const SIDE_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        function checkAllSpritesLoaded() {
            if (spritesLoaded >= TOTAL_SPRITES) {
                spriteReady = true;
                console.log('Alle Sprites geladen!');
            }
        }

        // DEBUG HELPER
        window.logDebug = function (msg) {
            console.log("[DEBUG]", msg);
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML += msg + "<br>";
                const lines = d.innerHTML.split("<br>");
                if (lines.length > 6) d.innerHTML = lines.slice(lines.length - 6).join("<br>");
            }
        };

        window.addEventListener('load', () => {
            const pal = document.getElementById('pal-filter');
            const glitch = document.getElementById('glitch-filter');
            logDebug("Filters: PAL=" + (pal ? "OK" : "NO") + " GLITCH=" + (glitch ? "OK" : "NO"));

            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const style = window.getComputedStyle(canvas);
                const filter = style.getPropertyValue('filter');
                logDebug("Canvas Filter: " + ((filter && filter !== 'none') ? "ACTIVE" : "NONE"));
            }
        });

        loadAllSprites();

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // GLOBAL ERROR HANDLER (DEBUG)
        // ============================================
        window.onerror = function (msg, url, line, col, error) {
            const rawMessage = String(msg || (error && error.message) || '');
            const lowered = rawMessage.toLowerCase();
            const isFullscreenNoise =
                lowered.includes('fullscreen') ||
                lowered.includes('requestfullscreen') ||
                lowered.includes('webkitfullscreen');

            if (isFullscreenNoise) {
                console.warn('[NonFatal][Fullscreen]', rawMessage, error || '');
                return true;
            }

            const pi = document.getElementById('processingInfo');
            if (pi && !gameReady) {
                pi.style.display = 'block';
                pi.style.color = '#ff5555';
                pi.style.background = 'rgba(0,0,0,0.9)';
                pi.innerText = 'Ein Fehler ist beim Laden aufgetreten.';
                if (line) {
                    pi.innerText += "\nLine: " + line;
                }
            }
            console.error(rawMessage, error);
            return false;
        };

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        window.addEventListener('DOMContentLoaded', async () => {
            console.log("Electron Mode: Auto-Loading...");

            // 0. IMMEDIATE AUDIO PRELOAD (User Request: Buffer early)
            // WRAPPED IN TRY-CATCH TO PREVENT CRASHING THE LOADING SCREEN
            try {
                const mainAudioSrc = window.mainAudioUrl || LEVEL.audioUrl;
                window.mainAudioUrl = mainAudioSrc;
                if (typeof getSCUrl === 'function' && typeof audioPlayer !== 'undefined') {
                    const scUrl = getSCUrl(mainAudioSrc);
                    audioPlayer.src = scUrl;
                    if (audioPlayer.mode === 'html5' && audioPlayer.audioNode) {
                        audioPlayer.audioNode.preload = "auto";
                        // audioPlayer.audioNode.load(); // Reduced aggression to prevent hang
                        console.log("Audio Preloading Configured (Lazy)");
                    }
                } else {
                    console.warn("AudioPlayer or getSCUrl not ready yet.");
                }
            } catch (e) {
                console.warn("Audio Preload Failed (Non-Fatal):", e);
            }

            // RESTORE READING MODE STATE
            const savedMode = localStorage.getItem('gameboy_reading_mode');
            if (savedMode === 'true') {
                isReadingMode = true;
                const ui = document.getElementById('audioPlayerUI');
                if (ui) ui.classList.add('reading-mode');
            }
            syncBlaetternUiState('restore-reading-mode');
            // Load watchdog: never start the game loop without a loaded map.
            const loadingScreen = document.getElementById('loading-screen');
            const processingInfo = document.getElementById('processingInfo');
            const dropZone = document.getElementById('dropZone');

            setTimeout(() => {
                if (gameReady) return;

                console.warn("Map still not ready after 10s. Waiting for map load instead of force-start.");
                if (dropZone && !dropZone.classList.contains('hidden')) dropZone.classList.add('hidden');

                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ffd54a';
                    processingInfo.style.background = 'rgba(0,0,0,0.75)';
                    processingInfo.innerText = 'Map is still loading... please wait.';
                }

                if (loadingScreen) loadingScreen.style.display = 'flex';
            }, 10000);

            // 1. Load Map (Default)
            const mapImg = new Image();
            mapImg.onload = () => {
                console.log("Map Loaded, processing...");
                try {
                    processMap(mapImg);
                } catch (e) {
                    console.error("Critical: processMap crashed!", e);
                }
            };
            mapImg.onerror = (e) => {
                console.error("Map Load Error", e);
                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ff5555';
                    processingInfo.style.background = 'rgba(0,0,0,0.85)';
                    processingInfo.innerText = 'Map failed to load. Please reload the page.';
                }
                if (loadingScreen) loadingScreen.style.display = 'flex';
            };
            mapImg.src = LEVEL.mapFile;

            // 2. Load Audio & Text (Chapter 1) -> Audio already preloaded above!
            // const mainAudioSrc = 'assets/kapitel1.mp3'; // Removed redundant def

            const attemptAutoPlay = async () => {
                if (!mainChapterAutoplayIntent.shouldAutoplay) {
                    indexDebugNote('autoplay', `suppressed policy=${mainChapterAutoplayIntent.policy} reason=${mainChapterAutoplayIntent.reason}`);
                    syncPlayPauseIcon();
                    return false;
                }
                const started = await verifyPlaybackStarted(3, 320);
                indexDebugNote('autoplay', `boot started=${started} source=${mainChapterAutoplayIntent.source} reason=${mainChapterAutoplayIntent.reason}`);
                syncPlayPauseIcon();
                return started;
            };

            try {
                // debugLog('Fetching subtitle file...');
                const response = await fetch(LEVEL.subtitleFile);
                // debugLog('Fetch response: ' + response.status);
                const text = await response.text();
                // debugLog('Text length: ' + text.length);
                window.mainTextContent = text;
                parseSubtitles(text);
                // debugLog('subtitleTracks: ' + subtitleTracks.length);
                renderSubtitleLines(0);
                // debugLog('Chapter 1 Loaded OK');

                await attemptAutoPlay();

                // --- BOOKMARK SEEK ON LOAD ---
                const bmTarget = sessionStorage.getItem('bookmark_seek_target');
                if (bmTarget) {
                    sessionStorage.removeItem('bookmark_seek_target');
                    try {
                        const target = JSON.parse(bmTarget);
                        const time = Number(target && target.time);
                        if (Number.isFinite(time) && time >= 0) {
                            console.log(`[Bookmark] Seeking to bookmarked time: ${time}s`);
                            setTimeout(async () => {
                                try {
                                    const targetPage = (target && typeof target.page === 'string' && target.page) ? target.page : CURRENT_PAGE;
                                    const targetContentKey = resolveBookmarkContentKey(target);
                                    const isLoreTarget = /^lore\d+$/i.test(targetContentKey);
                                    if (targetPage !== CURRENT_PAGE && !isLoreTarget) {
                                        console.warn('[Bookmark] Ignored stale on-load bookmark target for other page.', targetPage);
                                        return;
                                    }

                                    const ready = await ensureBookmarkContentForCurrentPage(target, 'bookmark:on-load');
                                    if (!ready) {
                                        console.warn('[Bookmark] Could not activate bookmark target content on load.', target);
                                        return;
                                    }

                                    await seekAndSyncSubtitle(time, 'bookmark:on-load');
                                    if (audioPlayer.paused) {
                                        try { await audioPlayer.play(); } catch (_) { }
                                    }
                                    syncPlayPauseIcon();
                                } catch (e) {
                                    console.warn('[Bookmark] Failed to apply on-load bookmark target:', e);
                                }
                            }, 800);
                        }
                    } catch (e) {
                        console.warn('[Bookmark] Failed to parse seek target:', e);
                    }
                }
            } catch (e) {
                debugLog('Chapter 1 Load ERROR: ' + e.message);
                window.mainTextContent = "";
                subtitleTracks = [];
            }

            // 2b. Preload Lore 1 Text
            try {
                const lRes = await fetch('assets/lore1.txt');
                loreData.text[1] = await lRes.text();
                console.log("Lore 1 Loaded");
            } catch (e) {
                console.error("Lore 1 Text Load Error:", e);
                loreData.text[1] = "";
            }

            // Always show UI
            if (typeof uiContainer !== 'undefined' && uiContainer) uiContainer.style.display = 'flex';

            // 3. Load Save Game
            // Handled by generic GameState.init() called at top of script
            // if (window.electronAPI) { ... }
        });

        // Helper for manual image loading (optional debugging)
        function loadImageFile(file) {
            processingInfo.style.display = 'block';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => setTimeout(() => processMap(img), 50);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // KEYBOARD
        // ============================================
        // Toggle State
        let usePAL = true;
        let useHalftone = true;

        function updateFilterStyle() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;

            let filters = [];
            if (usePAL) filters.push('url(#pal-filter)');
            // Halftone is usually a CSS class or overlay?
            // If it's the SVG glitch:
            if (useHalftone) filters.push('url(#glitch-filter)');
            // Note: Halftone dots is often a CSS overlay DIV, not SVG filter.
            // But user said "2" -> halftone dots.
            // I'll check if there is a .halftone class.
            // If not, I'll toggle the GLITCH filter (since "Glitch=NO" was the issue).

            canvas.style.filter = filters.join(' ');

            // Also update Debug
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML = `Filters: PAL=${usePAL ? 'ON' : 'OFF'} GLITCH=${useHalftone ? 'ON' : 'OFF'}<br>CANVAS: ${canvas.style.filter}`;
            }
        }

        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
                // CRITICAL FIX: Ensure Audio Player NEVER has focus, preventing "fast forward"
                // if (audioPlayer) audioPlayer.blur();
                document.body.focus();
            }
            // TOGGLES
            if (e.key === '1') { usePAL = !usePAL; updateFilterStyle(); }
            if (e.key === '2') { useHalftone = !useHalftone; updateFilterStyle(); }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            // Tastendruck bricht Click-to-Move ab
            moveTarget = null;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Click-to-Move fÃ¼r Mobile
        function handleClickMove(screenX, screenY) {
            if (!gameReady) return;

            // Berechne Welt-Koordinaten aus Screen-Koordinaten
            const rect = canvas.getBoundingClientRect();
            // CSS-Pixel zu Canvas-Pixel Umrechnung
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;

            // Welt-Position = Canvas-Position + Kamera-Offset
            const worldX = canvasX + camX;
            const worldY = canvasY + camY;

            // Setze Ziel (Spieler-Mitte soll dort hin)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            moveTarget = {
                x: worldX - spriteW / 2,
                y: worldY - spriteH / 2
            };
        }

        canvas.addEventListener('click', e => {
            // Guard: Ignore if clicking UI buttons (propagated events)
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            handleClickMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            // Guard: Ignore if touching UI
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            e.preventDefault();
            if (e.touches.length > 0) {
                handleClickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // ============================================
        // MAP PROCESSING
        // ============================================
        // ============================================
        // MAP PROCESSING (NUCLEAR FALLBACK VERSION)
        // ============================================
        // ============================================
        // MAP PROCESSING (ADVANCED RESTORED)
        // ============================================

        // --- AUTO-WALK PATH SORTER (Pure Nearest Neighbor) ---
        // Immer den ALLERNÃ„CHSTEN Pixel. Keine Bereiche, keine Schwellen.
        function sortAutoWalkPath(pixels, startPoint) {
            if (pixels.length === 0) return [];

            const path = [];
            let pool = [...pixels];

            // 1. Startpunkt: Der Pixel, der am nÃ¤chsten zum Spawn liegt.
            let minDistSq = Infinity;
            let startIndex = -1;

            for (let i = 0; i < pool.length; i++) {
                const dx = pool[i].x - startPoint.x;
                const dy = pool[i].y - startPoint.y;
                const dSq = dx * dx + dy * dy;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    startIndex = i;
                }
            }

            if (startIndex === -1) return [];

            let current = pool.splice(startIndex, 1)[0];
            path.push(current);

            // 2. Stur: Immer den ALLERNÃ„CHSTEN noch nicht besuchten Pixel wÃ¤hlen.
            while (pool.length > 0) {
                let bestIndex = -1;
                let bestDistSq = Infinity;

                for (let i = 0; i < pool.length; i++) {
                    const dx = pool[i].x - current.x;
                    const dy = pool[i].y - current.y;
                    const dSq = dx * dx + dy * dy;

                    if (dSq < bestDistSq) {
                        bestDistSq = dSq;
                        bestIndex = i;
                    }
                }

                // Immer nehmen, egal wie weit weg.
                if (bestIndex !== -1) {
                    current = pool.splice(bestIndex, 1)[0];
                    path.push(current);
                } else {
                    break;
                }
            }

            console.log(`Auto-Walk Path (Pure Nearest): ${path.length} nodes.`);
            return path;
        }

        function processMap(img) {
            console.log("Processing Map (Advanced):", img.width, "x", img.height);
            mapW = img.width;
            mapH = img.height;

            SCREEN_W = Math.min(mapW, window.innerWidth);
            SCREEN_H = Math.min(mapH, window.innerHeight);
            canvas.width = SCREEN_W;
            canvas.height = SCREEN_H;

            // VISUAL DEBUG
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.innerText = "PROCESSING PIXELS...";
                pi.style.display = 'block';
            }

            // ATTEMPT PIXEL PROCESSING
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapW;
                tempCanvas.height = mapH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imgData = tempCtx.getImageData(0, 0, mapW, mapH);
                const data = imgData.data;

                // 1. Initialisieren der Arrays
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                foregroundData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                flowData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));

                magentaPixels = [];
                cyanPixels = new Set();
                greenPixels = [];
                greenPixels = [];
                let orangePixels = []; // For Auto-Walk
                yellowLights = []; // Init global var
                let spawnPixel = null;

                // 2. Scan-Pass
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const i = (y * mapW + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Magenta = Kollision
                        if (r > 200 && g < 80 && b > 200) {
                            collisionData[y][x] = true;
                            magentaPixels.push({ x, y, i });
                        }
                        // Cyan = Vordergrund
                        else if (r < 80 && g > 200 && b > 200) {
                            cyanPixels.add(`${x},${y}`);
                        }
                        // GrÃ¼n = Flow (Lichter)
                        else if (r < 80 && g > 200 && b < 80) {
                            flowData[y][x] = true;
                            greenPixels.push({ x, y, i });
                        }
                        // GELB = Lore Trigger (#FFFF00)
                        else if (r > 250 && g > 250 && b < 10) {
                            const id = yellowLights.length + 1;
                            yellowLights.push(new YellowLight(x, y, id));
                        }
                        // BLAU = Spawn Punkt (#0000FF)
                        else if (r < 50 && g < 50 && b > 200) {
                            if (!spawnPixel) spawnPixel = { x, y, i };
                        }
                        // ORANGE = Auto-Walk Pfad (#FFA500 -> R>240, G~165, B<50)
                        else if (r > 240 && g > 130 && g < 200 && b < 50) {
                            orangePixels.push({ x, y, i });
                        }
                    }
                }

                // 3. Flood Fill Cyan
                if (cyanPixels.size > 0) findEnclosedAreas(cyanPixels, mapW, mapH);

                // 4. Pixel Hiding (Flow, Lore, Spawn)
                // Use pullNearbyPixel to hide the debug colors

                // 5. Magenta Cleanup & Wall Dilatation (Robust Collision)
                const extraWalls = [];
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (collisionData[y][x]) {
                            if (x > 0) extraWalls.push({ x: x - 1, y: y });
                            if (x < mapW - 1) extraWalls.push({ x: x + 1, y: y });
                            if (y > 0) extraWalls.push({ x: x, y: y - 1 });
                            if (y < mapH - 1) extraWalls.push({ x: x, y: y + 1 });
                        }
                    }
                }
                for (const w of extraWalls) {
                    collisionData[w.y][w.x] = true;
                }

                // Restore Magenta Pixels visually
                for (const mp of magentaPixels) {
                    const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                    data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;
                }
                for (const gp of greenPixels) {
                    const repl = pullNearbyPixel(data, gp.x, gp.y, mapW, mapH, cyanPixels);
                    data[gp.i] = repl.r; data[gp.i + 1] = repl.g; data[gp.i + 2] = repl.b;
                }
                for (const yl of yellowLights) {
                    const i = (yl.y * mapW + yl.x) * 4;
                    const repl = pullNearbyPixel(data, yl.x, yl.y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }
                if (spawnPixel) {
                    const repl = pullNearbyPixel(data, spawnPixel.x, spawnPixel.y, mapW, mapH, cyanPixels);
                    data[spawnPixel.i] = repl.r; data[spawnPixel.i + 1] = repl.g; data[spawnPixel.i + 2] = repl.b;
                }

                // 4b. Process Auto-Walk Path
                if (orangePixels.length > 0) {
                    // Sort path starting from spawn (or map center)
                    const startRef = spawnPixel || { x: mapW / 2, y: mapH / 2 };

                    // Direct Sort (Strict 1px)
                    autoWalkPath = sortAutoWalkPath(orangePixels, startRef);
                    autoWalkIndex = 0;

                    // Hide Orange Pixels
                    for (const op of orangePixels) {
                        const repl = pullNearbyPixel(data, op.x, op.y, mapW, mapH, cyanPixels);
                        data[op.i] = repl.r; data[op.i + 1] = repl.g; data[op.i + 2] = repl.b;
                    }
                }

                // 5. Magenta Cleanup
                // Multi-pass to fill large magenta areas from outside in
                let remainingMagenta = [...magentaPixels];
                const maxPasses = 10;
                for (let pass = 0; pass < maxPasses && remainingMagenta.length > 0; pass++) {
                    const stillRemaining = [];
                    for (const mp of remainingMagenta) {
                        const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                        // If result is the fallback gray (60,55,50), it means no neighbor found yet
                        // But wait, pullNearbyPixel returns fallback if nothing found. 
                        // We need a way to know if it found something good. 
                        // For now, let's just accept the replacement. The loop is fine.
                        data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;

                        // Heuristic: If we are deep inside magenta, we might get gray. 
                        // Ideally we want to wait for neighbors. But this is fast enough.
                    }
                    remainingMagenta = []; // Assume processed (simplification for speed)
                }

                // 6. Cyan Cleanup
                for (const cp of cyanPixels) {
                    const [x, y] = cp.split(',').map(Number);
                    const i = (y * mapW + x) * 4;
                    const repl = pullNearbyPixel(data, x, y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }

                // 7. Create Foreground/Background Layers
                const bgData = new Uint8ClampedArray(data);
                const fgData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < fgData.length; i += 4) fgData[i + 3] = 0; // Clear Alpha

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (foregroundData[y][x]) {
                            const i = (y * mapW + x) * 4;
                            fgData[i] = data[i];
                            fgData[i + 1] = data[i + 1];
                            fgData[i + 2] = data[i + 2];
                            fgData[i + 3] = 255;
                        }
                    }
                }

                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = mapW; bgCanvas.height = mapH;
                bgCanvas.getContext('2d').putImageData(new ImageData(bgData, mapW, mapH), 0, 0);

                const fgCanvas = document.createElement('canvas');
                fgCanvas.width = mapW; fgCanvas.height = mapH;
                fgCanvas.getContext('2d').putImageData(new ImageData(fgData, mapW, mapH), 0, 0);

                bgImage = new Image();
                foregroundImage = new Image();

                bgImage.onload = () => {
                    gameReady = true;
                    if (document.getElementById('processingInfo')) document.getElementById('processingInfo').style.display = 'none';
                    if (document.getElementById('dropZone')) document.getElementById('dropZone').classList.add('hidden');
                    // Hide Loading Screen
                    const ls = document.getElementById('loading-screen');
                    if (ls) ls.style.display = 'none';

                    if (spawnPixel) {
                        // FIX: Blue pixel marks FOOT position, not sprite top
                        // Robust: use the same spriteH logic as checkCollisionAt

                        // 1. Update scale for spawn depth (initial guess)
                        if (mapH > 0) {
                            const yNorm = Math.max(0, Math.min(1, spawnPixel.y / mapH));
                            const depthFactor = 0.5 + (0.8 * yNorm);
                            SPRITE.scale = SPRITE.baseScale * depthFactor;
                        }

                        const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                        const FOOT_OFFSET_Y = 15; // Must match checkCollisionAt

                        player.x = spawnPixel.x - 8; // Center horizontally
                        player.y = spawnPixel.y - spriteH - FOOT_OFFSET_Y; // Feet at spawnPixel.y

                        console.log(`Spawn: Blue(${spawnPixel.x},${spawnPixel.y}) -> Feet at Y=${spawnPixel.y}, SpriteH=${spriteH.toFixed(1)}, Player.y=${player.y.toFixed(1)}`);
                    } else {
                        player.x = mapW / 2;
                        player.y = mapH / 2;
                    }

                    // Center Camera
                    camX = targetCamX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                    camY = targetCamY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));

                    // Init Extras
                    initParticles();
                    initClouds();

                    // Start Audio (aux tracks are gated to avoid SC widget pause races)
                    if (typeof ambientAudio !== 'undefined') {
                        syncAuxScPlayback('game-ready');
                    }

                    startGameLoop();
                    console.log("Map Processed & Ready.");
                };
                bgImage.onerror = (e) => {
                    console.error("Processed background image failed to load", e);
                };
                foregroundImage.onerror = (e) => {
                    console.error("Processed foreground image failed to load", e);
                };
                bgImage.src = bgCanvas.toDataURL();
                foregroundImage.src = fgCanvas.toDataURL();


            } catch (e) {
                console.error("Advanced Processing Crash", e);
                // Fallback to RAW if crash
                bgImage = img;
                foregroundImage = null;
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false)); // Safe init
                gameReady = true;
                startGameLoop();
            }
        }

        // Fallback: Audio starten bei erster Interaktion, falls Autoplay blockiert wurde
        document.addEventListener('click', () => {
            if (gameReady && ambientAudio.paused && allowAuxScPlayback()) {
                ambientAudio.play().catch(e => console.warn("Ambient play failed:", e));
            }
        }, { once: true }); // Nur einmal ausfÃ¼hren

        // ============================================
        // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
        // ============================================
        let wasAmbientPlaying = false;
        let wasPlayerPlaying = false;
        let visibilityResumeToken = 0;
        window.gamePaused = false; // Flag for Game Loop
        window.visualFreezeActive = !!window.visualFreezeActive;

        document.addEventListener('visibilitychange', () => {
            const token = ++visibilityResumeToken;
            if (document.hidden) {
                // APP BACKGROUNDED -> PAUSE ALL
                window.gamePaused = true; // Stop loop logic
                saveCurrentContentState({ preferCachedTime: true, reason: 'visibility:hidden' });
                indexDebugNote('visibility', 'hidden');

                if (typeof ambientAudio !== 'undefined') {
                    wasAmbientPlaying = (typeof ambientAudio.isProbablyPlaying === 'function')
                        ? ambientAudio.isProbablyPlaying()
                        : !ambientAudio.paused;
                    ambientAudio.pause();
                    indexDebugNote('ambient', `pause hidden (wasPlaying=${wasAmbientPlaying})`);
                } else {
                    wasAmbientPlaying = false;
                }

                if (typeof audioPlayer !== 'undefined') {
                    wasPlayerPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                        ? audioPlayer.isProbablyPlaying()
                        : !audioPlayer.paused;
                    audioPlayer.pause();
                    indexDebugNote('player', `pause hidden (wasPlaying=${wasPlayerPlaying})`);
                } else {
                    wasPlayerPlaying = false;
                }

                if (typeof footstepSound !== 'undefined') footstepSound.pause();

            } else {
                // APP FOREGROUND -> RESUME IF WAS PLAYING
                // Reset time to prevent delta spikes
                lastTime = 0;
                window.gamePaused = false;
                if (!window.visualFreezeActive) {
                    startGameLoop();
                }
                indexDebugNote('visibility', 'visible');

                setTimeout(() => {
                    if (token !== visibilityResumeToken || document.hidden) return;
                    if (contentSwitchInProgress) {
                        indexDebugNote('visibility', 'resume skipped (content switch active)');
                        return;
                    }
                    applySceneAudioMix('visibility:resume');
                    if (wasAmbientPlaying && typeof ambientAudio !== 'undefined' && allowAuxScPlayback()) {
                        ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                        wasAmbientPlaying = false;
                        indexDebugNote('ambient', 'resume on visible');
                    }
                    if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                        audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                        wasPlayerPlaying = false;
                        indexDebugNote('player', 'resume on visible');
                    }
                }, 100);
            }
        });

        window.addEventListener('pagehide', () => {
            visibilityResumeToken += 1;
            saveCurrentContentState({ preferCachedTime: true, reason: 'pagehide' });
            if (typeof ambientAudio !== 'undefined') ambientAudio.pause();
            if (typeof audioPlayer !== 'undefined') audioPlayer.pause();
            indexDebugNote('lifecycle', 'pagehide');
        });

        function findSafeStart() {
            // Suche ausgehend von der Mitte nach einer Position ohne Kollision
            const startX = Math.floor(mapW / 2);
            const startY = Math.floor(mapH / 2);

            for (let radius = 0; radius < 100; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < mapW - 16 && y >= 0 && y < mapH - 16) {
                            if (!checkCollisionAt(x, y)) {
                                player.x = x;
                                player.y = y;
                                return;
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // FLOOD FILL MIT DILATATION
        // ============================================
        function findEnclosedAreas(cyanPixels, w, h) {
            const visited = new Array(h).fill(null).map(() => new Array(w).fill(0));

            // Dilatation der Cyan-Grenzen
            const dilationRadius = 2;
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                    for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) <= dilationRadius) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                visited[ny][nx] = 2;
                            }
                        }
                    }
                }
            }

            // Flood Fill vom Rand
            const queue = [];
            for (let x = 0; x < w; x++) {
                if (visited[0][x] === 0) queue.push([x, 0]);
                if (visited[h - 1][x] === 0) queue.push([x, h - 1]);
            }
            for (let y = 0; y < h; y++) {
                if (visited[y][0] === 0) queue.push([0, y]);
                if (visited[y][w - 1] === 0) queue.push([w - 1, y]);
            }

            let idx = 0;
            while (idx < queue.length) {
                const [x, y] = queue[idx++];
                if (x < 0 || x >= w || y < 0 || y >= h || visited[y][x] !== 0) continue;
                visited[y][x] = 1;
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Innere Bereiche markieren
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (visited[y][x] === 0 || visited[y][x] === 2) {
                        foregroundData[y][x] = true;
                    }
                }
            }

            // Original Cyan-Pixel auch markieren
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                foregroundData[y][x] = true;
            }
        }

        // ============================================
        // PIXEL-PULLING (SpiralfÃ¶rmige Suche fÃ¼r alle Linienrichtungen)
        // ============================================
        function pullNearbyPixel(data, x, y, w, h, cyanPixels) {
            // SpiralfÃ¶rmige Suche: Sucht in expandierenden Kreisen
            // Funktioniert fÃ¼r horizontale, vertikale UND diagonale Linien
            const maxRadius = 15;  // Maximaler Suchradius

            for (let radius = 1; radius <= maxRadius; radius++) {
                // Alle Punkte auf dem aktuellen "Quadrat-Ring" durchsuchen
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        // Nur Randpunkte des Quadrats (nicht innere)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                        const ni = (ny * w + nx) * 4;
                        const r = data[ni], g = data[ni + 1], b = data[ni + 2];

                        // Skip Magenta (Kollision) und Cyan (Vordergrund)
                        if (r > 200 && g < 80 && b > 200) continue;
                        if (r < 80 && g > 200 && b > 200) continue;
                        if (cyanPixels.has(`${nx},${ny}`)) continue;

                        // GÃ¼ltiges Pixel gefunden!
                        return { r, g, b };
                    }
                }
            }

            // Fallback: Neutrales Grau-Braun (passt zu den meisten Umgebungen)
            return { r: 60, g: 55, b: 50 };
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function startGameLoop() {
            if (window.gameLoopRunning) return;
            if (window.visualFreezeActive) return;
            window.gameLoopRunning = true;
            lastTime = 0;
            console.log("startGameLoop");
            requestAnimationFrame(gameLoop);
        }

        // Global vars for timing
        let lastTime = 0;
        let autoWalkFacingLockTimer = 0;

        function chooseAutoWalkDirection(dx, dy, fallbackDir) {
            const ax = Math.abs(dx);
            const ay = Math.abs(dy);
            if (ax < 0.001 && ay < 0.001) return fallbackDir;

            // Keep current facing near diagonals to avoid rapid direction flicker.
            const dominance = Math.abs(ax - ay);
            if (dominance < 0.35) return fallbackDir;

            if (ax > ay) return dx > 0 ? 3 : 2;
            return dy > 0 ? 0 : 1;
        }

        function gameLoop(timestamp) {
            if (window.visualFreezeActive) {
                window.gameLoopRunning = false;
                return;
            }

            if (window.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Clamp DT to prevent speed spikes (e.g. after lag/pause)
            if (dt > 0.1) dt = 0.1;

            // Cap delta time (prevent spirals of death)
            if (dt > 0.1) dt = 0.1;

            // Update Game Logic
            update(dt);
            updateLoreSystem(); // Lore-Proximity prÃ¼fen

            // Draw
            draw();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // UPDATE - MIT ROBUSTER KOLLISION
        // ============================================
        function update(dt) {
            if (!dt) dt = 0.016;
            if (!gameReady) return;
            if (autoWalkFacingLockTimer > 0) {
                autoWalkFacingLockTimer = Math.max(0, autoWalkFacingLockTimer - dt);
            }

            // --- DYNAMIC SCALING (Depth Effect) ---
            if (mapH > 0) {
                // Normalisierte Y-Position (0.0 oben bis 1.0 unten)
                const yNorm = Math.max(0, Math.min(1, player.y / mapH));

                // Skalierung: 50% (oben) bis 130% (unten)
                // Formel: 0.5 + (0.8 * yNorm) -> 
                // yNorm=0 -> 0.5 | yNorm=1 -> 1.3
                const depthFactor = 0.5 + (0.8 * yNorm);

                SPRITE.scale = SPRITE.baseScale * depthFactor;
            }

            let dx = 0, dy = 0;
            player.isMoving = false;

            // Input von Tastatur
            if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) { dy = -1; player.dir = 1; }
            if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) { dy = 1; player.dir = 0; }
            if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) { dx = -1; player.dir = 2; }
            if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) { dx = 1; player.dir = 3; }

            // Click-to-Move: Wenn kein Tastatur-Input und Ziel gesetzt
            // Fix: Movement allowed during Lore (unless Reading Mode active)
            if (dx === 0 && dy === 0 && moveTarget && !isReadingMode) {
                const tdx = moveTarget.x - player.x;
                const tdy = moveTarget.y - player.y;
                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Ziel erreicht? (innerhalb von 3px)
                if (tdist < 3) {
                    moveTarget = null;
                } else {
                    // Richtung zum Ziel
                    dx = tdx / tdist;
                    dy = tdy / tdist;

                    // Blickrichtung setzen
                    if (Math.abs(tdx) > Math.abs(tdy)) {
                        player.dir = tdx > 0 ? 3 : 2; // Rechts oder Links
                    } else {
                        player.dir = tdy > 0 ? 0 : 1; // Unten oder Oben
                    }
                }
            }

            // --- AUTO-WALK (READING MODE & COASTDOWN) ---
            if ((isReadingMode || (player.slowdownTimer > 0)) && autoWalkPath.length > 0) {
                // Initialize Slowdown Timer
                if (isReadingMode) {
                    player.slowdownTimer = 1.0; // 1 Second Coastdown buffer (float seconds now)
                } else {
                    player.slowdownTimer -= dt;
                }

                // Calculate Foot Position
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const footX = player.x + spriteW / 2;
                const footY = player.y + spriteH + 15;

                // Target logic
                let target = autoWalkPath[autoWalkIndex];
                const tdx = target.x - footX;
                const tdy = target.y - footY;
                const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Speed Calculation (Linked to player.speed)
                let walkSpeed = player.speed;
                if (!isReadingMode) {
                    // Coastdown Fade
                    walkSpeed *= Math.max(0, player.slowdownTimer);
                }
                const step = walkSpeed * dt;

                if (dist < 4) {
                    autoWalkIndex++;
                    if (autoWalkIndex >= autoWalkPath.length) {
                        autoWalkIndex = autoWalkPath.length - 1;
                        if (!isReadingMode) player.slowdownTimer = 0;
                    }
                }

                if (autoWalkIndex < autoWalkPath.length && player.slowdownTimer > 0) {
                    const nextTdx = target.x - footX;
                    const nextTdy = target.y - footY;
                    const nextDist = Math.sqrt(nextTdx * nextTdx + nextTdy * nextTdy);

                    if (nextDist > 1) {
                        const dx = (nextTdx / nextDist) * step;
                        const dy = (nextTdy / nextDist) * step;

                        player.x += dx;
                        player.y += dy;
                        player.isMoving = true;

                        // Direction: use a short look-ahead + hysteresis to avoid point-to-point flicker.
                        const lookAheadIndex = Math.min(autoWalkPath.length - 1, autoWalkIndex + 8);
                        const lookAheadTarget = autoWalkPath[lookAheadIndex];
                        const lookAheadDx = lookAheadTarget.x - footX;
                        const lookAheadDy = lookAheadTarget.y - footY;
                        const blendedDx = nextTdx * 0.35 + lookAheadDx * 0.65;
                        const blendedDy = nextTdy * 0.35 + lookAheadDy * 0.65;
                        const nextDir = chooseAutoWalkDirection(blendedDx, blendedDy, player.dir);
                        if (nextDir !== player.dir && autoWalkFacingLockTimer <= 0) {
                            player.dir = nextDir;
                            autoWalkFacingLockTimer = 0.14;
                        }

                        // Animation
                        player.animTimer += dt;

                        // 50% Slower Animation for Front (0) and Back (1) views

                        // 50% Slower Animation for Front/Back (0.30s vs 0.15s)
                        let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                        if (player.animTimer > animThreshold) {
                            player.animTimer = 0;
                            player.frame = (player.frame + 1) % 12;
                        }
                    }
                }
            }

            // --- MANUAL MOVEMENT ---
            if (dx !== 0 || dy !== 0) {
                player.isMoving = true;

                // Normalisieren (Diagonal Fix)
                if ((keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) && Math.abs(dx) === 1 && Math.abs(dy) === 1) {
                    const inv = 0.7071;
                    dx *= inv; dy *= inv;
                }

                // Apply Movement
                let moveSpeed = player.speed;
                if (isReadingMode) {
                    moveSpeed = player.speed * 0.175; // 50% of 35% = 17.5% (User Request: even slower)
                }

                // LOG SPEED for Debug (Throttle)
                if (player.isMoving && Math.random() < 0.01) {
                    console.log(`[DEBUG_SYS] Player Move Speed: Base=${player.speed}, Actual=${moveSpeed} (Mode=${isReadingMode ? 'READING' : 'GAME'})`);
                }

                const amount = moveSpeed * dt;

                // Collision Logic (restore if missing or use simplified slide)
                const vx = dx * amount;
                const vy = dy * amount;
                const targetX = player.x + vx;
                const targetY = player.y + vy;

                // Simple Slide or Full Collision
                // Assuming checkCollisionAt is available
                if (!checkCollisionAt(targetX, targetY)) {
                    player.x = targetX;
                    player.y = targetY;
                } else {
                    if (!checkCollisionAt(targetX, player.y)) player.x = targetX;
                    else if (!checkCollisionAt(player.x, targetY)) player.y = targetY;
                }

                // Animation
                player.animTimer += dt;
                // 50% Slower Animation for Front/Back
                let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                if (player.animTimer > animThreshold) {
                    player.animTimer = 0;
                    player.frame = (player.frame + 1) % 12;
                }
            }

            // Handle Animation & Sound for Movement
            if (player.isMoving) {
                // Initial Footstep
                if (audioUnlocked && !footstepPlaying && allowAuxScPlayback()) {
                    footstepSound.play().catch(() => { });
                    footstepPlaying = true;
                }
                if (!allowAuxScPlayback() && footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }

                // Dust Particles
                if (Math.random() > 0.9) { // Reduced freq for dt loop
                    const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                    const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                    const offsetY = Math.floor(spriteH * 0.22);
                    const shiftY = Math.floor(spriteH / 3) - 4;
                    const anchorY = player.y + spriteH + offsetY + shiftY;

                    dustParticles.push({
                        x: player.x + spriteW / 2 + (Math.random() - 0.5) * 6,
                        y: anchorY - 15 + (Math.random() - 0.5) * 2,
                        vx: (Math.random() - 0.5) * 10,  // px/sec (no dt at spawn)
                        vy: -Math.random() * 10,
                        life: 1.0,
                        size: 2 + Math.random() * 2
                    });
                }
            } else {
                // Stop Sound
                player.frame = 1; // Stand
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
            }

            // Update Dust
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const d = dustParticles[i];
                d.x += d.vx * dt;  // Frame-rate independent
                d.y += d.vy * dt;
                d.life -= 2.5 * dt;
                if (d.life <= 0) dustParticles.splice(i, 1);
            }

            // Map Bounds (with sprite size and foot offset)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const FOOT_OFFSET_Y = 15;
                player.x = Math.max(0, Math.min(player.x, mapW - spriteW));
                player.y = Math.max(0, Math.min(player.y, mapH - spriteH - FOOT_OFFSET_Y));
            }

            // Foreground Check
            player.isBehindForeground = checkForeground(player.x, player.y);

            // Smooth Camera (Time-based)
            targetCamX = player.x - SCREEN_W / 2 + 10;
            targetCamY = player.y - SCREEN_H * 0.30 + 10;
            targetCamX = Math.max(0, Math.min(targetCamX, Math.max(0, mapW - SCREEN_W)));
            targetCamY = Math.max(0, Math.min(targetCamY, Math.max(0, mapH - SCREEN_H)));

            camX += (targetCamX - camX) * 5.0 * dt;
            camY += (targetCamY - camY) * 5.0 * dt;

            // Update Particles
            nearbyLights = [];
            for (const p of particles) p.update(dt); // Ensure particle update accepts dt (or add it)
            for (const c of clouds) c.update(dt);

            // Screen-Shake Decay (frame-rate independent)
            if (screenShake > 0.01) {
                screenShake *= Math.pow(0.8, dt * 60);
            } else {
                screenShake = 0;
            }
        }

        // ============================================
        // KOLLISIONSPRÃœFUNG - ROBUST (Ecken-Check)
        // ============================================
        function checkCollisionAt(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            // Definition der FuÃŸ-Kollisionsbox relative zum Sprite-Ursprung (px, py)
            // Sprite ist ca 16x20. FÃ¼ÃŸe sind unten.
            // Wir definieren eine schmale Box mittig unten.

            const boxWidth = 8; // Schmaler als Sprite (damit man nicht an Ecken hÃ¤ngen bleibt)
            const boxHeight = 6;

            const centerX = px + spriteW / 2;
            const bottomY = py + spriteH + 15; // +15 wie bisher (visueller Offset)

            // PrÃ¼fpunkte:
            // 1. Unten Links
            // 2. Unten Rechts
            // (Optional auch Oben, wenn man eine tiefe Box hat, aber fÃ¼r RPG reicht meist eine 'Grundlinie')

            const left = Math.floor(centerX - boxWidth / 2);
            const right = Math.floor(centerX + boxWidth / 2);
            const yFn = Math.floor(bottomY);

            // PrÃ¼fe beide Ecken
            if (isSolid(left, yFn)) return true;
            if (isSolid(right, yFn)) return true;

            return false;
        }

        function isSolid(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true; // Map-Rand ist Wand
            if (collisionData[y][x]) return true;
            return false;
        }

        function checkForeground(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const cx = Math.floor(px + spriteW / 2);
            const cy = Math.floor(py + spriteH / 2);

            if (foregroundData && foregroundData[cy] && cy >= 0 && cy < mapH && cx >= 0 && cx < mapW) {
                return foregroundData[cy][cx];
            }
            return false;
        }

        // ============================================
        // DRAWING
        // ============================================
        let playerLightCanvas = null;
        let playerLightCtx = null;
        let playerMaskCanvas = null;
        let playerMaskCtx = null;
        let graySpriteCacheCanvas = null;
        let graySpriteCacheCtx = null;
        let graySpriteCacheKey = '';

        function draw() {
            // LCD Ghosting: Vorherigen Frame mit Transparenz beibehalten
            // Disable Ghosting
            // ctx.save(); ... ctx.restore();

            // Clear Canvas fully every frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameReady) return;

            ctx.save();
            // Screen-Shake anwenden
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            // SMOOTH CAMERA: Use sub-pixel values (remove Math.floor)
            ctx.translate(-camX + shakeX, -camY + shakeY);

            // screenShake decay moved to update(dt) for frame-rate independence

            // Hintergrund
            if (bgImage) ctx.drawImage(bgImage, 0, 0);

            // Partikel (Additives Leuchten)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) p.draw(ctx, camX, camY);
            ctx.restore();

            // Gelbe Lore-Lichter zeichnen
            for (const light of yellowLights) {
                light.draw(ctx);

                // Beleuchtung hinzufÃ¼gen wenn aktiv!
                if (activeLightSourceId === light.id && isLoreMode) {
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = light.x - px;
                    const ddy = light.y - py;
                    const dist = Math.sqrt(ddx * ddx + ddy * ddy);
                    nearbyLights.push({
                        x: light.x,
                        y: light.y,
                        dist: dist,
                        life: 1.0,
                        isYellow: true
                    });
                }
            }

            // Spieler-Schatten (diffuse Ellipse unter den FÃ¼ÃŸen)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

                // Offsets identisch zu drawPlayer berechnen
                const offsetY = Math.floor(spriteH * 0.22);
                const shiftY = Math.floor(spriteH / 3) - 4;
                const totalYOffset = offsetY + shiftY;

                // Schatten-Position: exakt unter den FÃ¼ÃŸen des Sprites
                const shadowCenterX = player.x + spriteW / 2;
                const shadowCenterY = player.y + totalYOffset + spriteH - 15; // Korrigiert

                // Schatten-GrÃ¶ÃŸe: klein und diffus
                const shadowWidth = spriteW * 0.4;
                const shadowHeight = 3;

                // Schatten-Deckkraft
                let shadowAlpha = 0.35;

                if (nearbyLights.length > 0) {
                    const light = nearbyLights[0];
                    const distFactor = 1 - (light.dist / 35);
                    shadowAlpha = 0.25 + distFactor * 0.15;
                }

                // Diffuser Schatten mit radialem Gradient
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    shadowCenterX, shadowCenterY, 0,
                    shadowCenterX, shadowCenterY, shadowWidth
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
                gradient.addColorStop(0.5, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(shadowCenterX, shadowCenterY, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Spieler NORMAL zeichnen (keine Transparenz!)
            drawPlayer(ctx, player.x, player.y, player.dir, player.frame);

            // DEBUG: Fadenkreuz an FuÃŸ-Position (nur im Reading Mode)
            if (isReadingMode && player.debugFootX !== undefined) {
                const fx = player.debugFootX;
                const fy = player.debugFootY;
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1;
                // Horizontale Linie
                ctx.beginPath();
                ctx.moveTo(fx - 8, fy);
                ctx.lineTo(fx + 8, fy);
                ctx.stroke();
                // Vertikale Linie
                ctx.beginPath();
                ctx.moveTo(fx, fy - 8);
                ctx.lineTo(fx, fy + 8);
                ctx.stroke();
                // Kreis
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Beleuchtung: Direktional mit Gradient
            if (nearbyLights.length > 0) {
                nearbyLights.sort((a, b) => a.dist - b.dist);

                const maxRadius = 65; // ErhÃ¶ht (war 35) fÃ¼r weichere ÃœbergÃ¤nge
                let totalIntensity = 0;
                let avgDx = 0, avgDy = 0;
                let useYellow = false;

                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const spriteW = coords.w;
                const spriteH = coords.h;
                const playerCX = coords.x + spriteW / 2;
                const playerCY = coords.y + spriteH / 2;

                const numLights = Math.min(2, nearbyLights.length);
                for (let i = 0; i < numLights; i++) {
                    const light = nearbyLights[i];
                    if (light.isYellow) useYellow = true;

                    // Distanz-Modulation: 0% am Rand, 100% direkt am Spieler
                    const distFactor = (1 - (light.dist / maxRadius));
                    // Gelbes Licht etwas intensiver
                    const intensity = distFactor * light.life * (light.isYellow ? 1.5 : 1.0);
                    totalIntensity += intensity * 0.4; // Subtiler (war 0.6)

                    // Richtung vom Licht zum Spieler (normalisiert)
                    const dx = playerCX - light.x;
                    const dy = playerCY - light.y;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    avgDx += (dx / len) * intensity;
                    avgDy += (dy / len) * intensity;
                }

                // Max 50% Aufhellung (subtiler Effekt), Gelb darf etwas heller sein (70%)
                totalIntensity = Math.min(useYellow ? 0.7 : 0.5, totalIntensity);

                if (totalIntensity > 0.02) {
                    // Normalisiere Durchschnittsrichtung
                    const dirLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy) || 1;
                    const ndx = avgDx / dirLen;
                    const ndy = avgDy / dirLen;

                    // OffScreen-Canvas fÃ¼r Gradient-Beleuchtung
                    if (!playerLightCanvas) {
                        playerLightCanvas = document.createElement('canvas');
                        playerLightCtx = playerLightCanvas.getContext('2d');
                    }
                    if (playerLightCanvas.width !== spriteW || playerLightCanvas.height !== spriteH) {
                        playerLightCanvas.width = spriteW;
                        playerLightCanvas.height = spriteH;
                    }
                    const lightCanvas = playerLightCanvas;
                    const lightCtx = playerLightCtx;
                    lightCtx.globalCompositeOperation = 'source-over';
                    lightCtx.clearRect(0, 0, spriteW, spriteH);

                    // Zeichne Sprite exakt so wie es auf dem Hauptcanvas erscheint, aber relativ zu (0,0)
                    lightCtx.save();
                    lightCtx.translate(-coords.x, -coords.y);
                    drawPlayer(lightCtx, player.x, player.y, player.dir, player.frame);
                    lightCtx.restore();

                    // GleichmÃ¤ÃŸigere Beleuchtung (statt harter Gradient)
                    // Wir fÃ¼llen das Sprite fast gleichmÃ¤ÃŸig auf (mit sehr weichem Rand-Ausfall)
                    const r = useYellow ? 255 : 255;
                    const g = useYellow ? 220 : 255;
                    const b = useYellow ? 50 : 255;

                    lightCtx.globalCompositeOperation = 'source-in';
                    // Fast gleichmÃ¤ÃŸige FÃ¼llung basierend auf IntensitÃ¤t
                    lightCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.8})`;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Ein ganz dezenter Gradient fÃ¼r DreidimensionalitÃ¤t
                    const rad = Math.max(spriteW, spriteH) * 2;
                    const gradient = lightCtx.createRadialGradient(
                        spriteW / 2 + ndx * (spriteW / 2),
                        spriteH / 2 + ndy * (spriteH / 2),
                        0,
                        spriteW / 2,
                        spriteH / 2,
                        rad
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    lightCtx.fillStyle = gradient;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Zeichne beleuchtetes Sprite an die berechnete Sprite-Position
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(lightCanvas, coords.x, coords.y);
                    ctx.restore();
                }
            }

            // Dust-Particles zeichnen
            ctx.save();
            for (const d of dustParticles) {
                ctx.globalAlpha = d.life * 0.4;
                ctx.fillStyle = '#a89070';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Vordergrund
            if (foregroundImage) ctx.drawImage(foregroundImage, 0, 0);

            // Graue Silhouette IMMER berechnen (Pixel-genaues Masking)
            if (foregroundImage && spriteReady) {
                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const px = coords.x;
                const py = coords.y;
                const dw = coords.w;
                const dh = coords.h;

                // OffScreen-Canvas fÃ¼r Masking
                const maskW = dw + 4;
                const maskH = dh + 4;
                if (!playerMaskCanvas) {
                    playerMaskCanvas = document.createElement('canvas');
                    playerMaskCtx = playerMaskCanvas.getContext('2d');
                }
                if (playerMaskCanvas.width !== maskW || playerMaskCanvas.height !== maskH) {
                    playerMaskCanvas.width = maskW;
                    playerMaskCanvas.height = maskH;
                }
                const maskCanvas = playerMaskCanvas;
                const maskCtx = playerMaskCtx;
                maskCtx.globalCompositeOperation = 'source-over';
                maskCtx.clearRect(0, 0, maskW, maskH);

                // 1. Zeichne den Foreground-Ausschnitt Ã¼ber dem Spieler
                maskCtx.drawImage(foregroundImage,
                    px - 2, py - 2, dw + 4, dh + 4,
                    0, 0, dw + 4, dh + 4);

                // 2. Source-In: Nur wo Foreground-Pixel existieren
                maskCtx.globalCompositeOperation = 'source-in';

                // 3. Zeichne graues Sprite
                const graySprite = createGraySpriteCanvas();
                if (graySprite) {
                    maskCtx.drawImage(graySprite, 2, 2);
                }

                // 4. Zeichne das Ergebnis
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(maskCanvas, px - 2, py - 2);
                ctx.restore();
            }

            // Wolken-Layer (Parallax, Ã¼ber allem)
            for (const c of clouds) c.draw(ctx, camX, camY);

            ctx.restore();
        }

        // NEU: Hilfsfunktion fÃ¼r konsistente Koordinatenberechnung
        // iOS Detection
        // const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent); // REMOVED DUPLICATE

        function getPlayerDrawCoords(x, y, dir, frame) {
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;
            const flipX = (dir === 3);

            let result = {};

            // FRONT (Marker-basiert, 6-Step)
            if (dir === 0) {
                const cycleIdx = frame % 6;
                const frameIdx = FRONT_ANIM_CYCLE[cycleIdx];
                const data = FRONT_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteFront.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteFront.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // BACK (NEU: Marker-basiert, 4-Step Cycle)
            else if (dir === 1) {
                const cycleIdx = frame % 4;
                const frameIdx = BACK_ANIM_CYCLE[cycleIdx];
                const data = BACK_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteBack.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteBack.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // SIDE (Marker-basiert, 6-Step Ping-Pong)
            else if (dir === 2 || dir === 3) {
                const cycleIdx = frame % 6;
                const frameIdx = SIDE_ANIM_CYCLE[cycleIdx];
                const data = SIDE_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = 175;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteSide.height * SPRITE.scale);

                let dx;
                if (flipX) {
                    // Gespiegelt: Ankerpunkt (x + refW/2) ist die Achse.
                    // Die linke Kante ist (Anker + verschobener_Anker) - Breite
                    dx = (x + refW / 2 + footRelX * SPRITE.scale) - dw;
                } else {
                    dx = x + refW / 2 - footRelX * SPRITE.scale;
                }
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: true, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteSide.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: flipX
                };
            } else {
                let sprite = (dir === 1) ? (spriteBack || spriteFront) : spriteFront;
                const sw = Math.floor(sprite.width / SPRITE.cols);
                const sh = sprite.height;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(sh * SPRITE.scale);
                const offsetY = Math.floor(dh * 0.22);

                const frameIdx = frame % 4;
                const sx = frameIdx * sw;

                const finalX = x;
                const finalY = y + offsetY + visualShiftY;
                result = {
                    x: finalX, y: finalY, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: sx, sw: sw, sh: sh,
                    flipX: false
                };
            }

            // iOS FIX: Force integer coordinates to prevent sub-pixel "wobble"
            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                result.x = Math.floor(result.x);
                result.y = Math.floor(result.y);
            }
            return result;
        }

        // ============================================
        // SPIELER SPRITE ZEICHNEN
        // ============================================
        function drawPlayer(ctx, x, y, dir, frame) {
            if (!spriteReady) return;

            const coords = getPlayerDrawCoords(x, y, dir, frame);
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;

            ctx.save();
            let sprite;
            if (dir === 0) sprite = spriteFront;
            else if (dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            // DEBUG-DOT an der FuÃŸ-Koordinate
            if (window.debugFoot) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + refW / 2, y + refH + visualShiftY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(x + refW / 2 - 2, y + refH + visualShiftY - 2, 4, 4);
                ctx.restore();
            }

            if (coords.isSide && coords.flipX) {
                // Spiegeln: Translate zur EXAKT berechneten linken Kante + Breite
                ctx.translate(coords.x + coords.w, coords.y);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            } else {
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, coords.x, coords.y, coords.w, coords.h);
            }

            ctx.restore();
        }

        window.debugFoot = false;

        // Erstellt ein einfarbig graues Sprite-Canvas
        function createGraySpriteCanvas() {
            if (!spriteReady) return null;

            const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
            const flipX = (player.dir === 3);

            let sprite;
            if (player.dir === 0) sprite = spriteFront;
            else if (player.dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            const cacheKey = [
                player.dir,
                player.frame,
                coords.w,
                coords.h,
                coords.sx,
                coords.sw,
                coords.sh,
                coords.flipX ? 1 : 0
            ].join(':');
            if (graySpriteCacheCanvas && graySpriteCacheKey === cacheKey) {
                return graySpriteCacheCanvas;
            }

            if (!graySpriteCacheCanvas) {
                graySpriteCacheCanvas = document.createElement('canvas');
                graySpriteCacheCtx = graySpriteCacheCanvas.getContext('2d');
            }
            if (graySpriteCacheCanvas.width !== coords.w || graySpriteCacheCanvas.height !== coords.h) {
                graySpriteCacheCanvas.width = coords.w;
                graySpriteCacheCanvas.height = coords.h;
            }
            const c = graySpriteCacheCanvas;
            const gc = graySpriteCacheCtx;
            gc.clearRect(0, 0, c.width, c.height);

            if (coords.isSide && flipX) {
                gc.translate(coords.w, 0);
                gc.scale(-1, 1);
            }
            gc.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            if (coords.isSide && flipX) {
                gc.setTransform(1, 0, 0, 1, 0, 0);
            }

            gc.globalCompositeOperation = 'source-in';
            gc.fillStyle = 'rgb(180, 180, 180)';
            gc.fillRect(0, 0, coords.w, coords.h);
            gc.globalCompositeOperation = 'source-over';
            graySpriteCacheKey = cacheKey;

            return c;
        }

        function drawPlayerOutline(ctx, x, y) {
            if (!spriteReady || !spriteFront) return;

            const dir = player.dir;
            let sprite;
            let flipX = false;

            switch (dir) {
                case 0: sprite = spriteFront; break;
                case 1: sprite = spriteBack || spriteFront; break;
                case 2: sprite = spriteSide || spriteFront; break;
                case 3: sprite = spriteSide || spriteFront; flipX = true; break;
                default: sprite = spriteFront;
            }

            const spriteW = Math.floor(sprite.width / SPRITE.cols);
            const spriteH = sprite.height;
            const drawW = Math.floor(spriteW * SPRITE.scale);
            const drawH = Math.floor(spriteH * SPRITE.scale);
            const frame = player.frame % SPRITE.cols;

            // Erstelle OffScreen-Canvas fÃ¼r einfarbige Silhouette
            const offCanvas = document.createElement('canvas');
            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');

            // Zeichne Sprite ins OffScreen-Canvas
            if (flipX) {
                offCtx.translate(drawW, 0);
                offCtx.scale(-1, 1);
            }
            offCtx.drawImage(sprite, frame * spriteW, 0, spriteW, spriteH, 0, 0, drawW, drawH);

            // Wandle alle sichtbaren Pixel in einheitliches Grau
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = 'rgb(200, 200, 200)'; // Helles Grau
            offCtx.fillRect(0, 0, drawW, drawH);

            // Zeichne die graue Silhouette halbtransparent
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(offCanvas, Math.floor(x), Math.floor(y));
            ctx.restore();
        }

        // AUDIO & SUBTITLE SYSTEM
        // ============================================

        // SoundCloud Audio Player via Widget API
        const audioPlayer = new SCAudioAdapter();
        // Index uses a dedicated visibility handler; avoid duplicate manager decisions.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(audioPlayer);
        }
        console.log('[Audio] Created SCAudioAdapter for main audio');
        let subtitleTracks = []; // Array aus { time: sekunden, text: string }
        let currentSubtitleIndex = -1;
        let isReadingMode = false;
        const READER_LAYOUT_STORAGE_KEY = 'gameboy_reader_sentence_layout';
        const READER_FONT_SIZE_STORAGE_KEY = 'gameboy_reader_font_size_px';
        const READER_BG_COLOR_STORAGE_KEY = 'gameboy_reader_bg_color';
        const READER_TEXT_COLOR_STORAGE_KEY = 'gameboy_reader_text_color';
        const READER_TEXT_VOLUME_STORAGE_KEY = 'gameboy_reader_text_volume';
        const READER_BACKGROUND_VOLUME_STORAGE_KEY = 'gameboy_reader_background_volume';
        const READER_LAYOUT_TIMESTAMPS = 'timestamps';
        const READER_LAYOUT_FLAT = 'flat';
        const READER_LAYOUT_BLAETTERN = 'blaettern';
        const READER_FONT_SIZE_MIN = 14;
        const READER_FONT_SIZE_MAX = 30;
        const READER_FONT_SIZE_DEFAULT = 18;
        const READER_VOLUME_DEFAULT = 1;
        let readerSentenceLayout = normalizeReaderSentenceLayout(localStorage.getItem(READER_LAYOUT_STORAGE_KEY));
        let readerFontSizePx = normalizeReaderFontSize(localStorage.getItem(READER_FONT_SIZE_STORAGE_KEY));
        let readerBgColor = normalizeReaderHexColor(localStorage.getItem(READER_BG_COLOR_STORAGE_KEY), null);
        let readerTextColor = normalizeReaderHexColor(localStorage.getItem(READER_TEXT_COLOR_STORAGE_KEY), null);
        let readerTextVolume = normalizeReaderVolume(localStorage.getItem(READER_TEXT_VOLUME_STORAGE_KEY));
        let readerBackgroundVolume = normalizeReaderVolume(localStorage.getItem(READER_BACKGROUND_VOLUME_STORAGE_KEY));
        const readerColorWheelSync = { bg: null, text: null };
        const readerColorPopoverState = { activeKey: null };
        let subtitleFollowLocked = false;
        let suppressFollowLockUntil = 0;
        let manualBackgroundDimLevel = 0;

        audioPlayer.volume = readerTextVolume;

        const uiContainer = document.getElementById('audioPlayerUI');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const audioControlsEl = document.getElementById('audioControls');
        const playBtn = document.getElementById('audioToggleBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipForwardBtn = document.getElementById('skipForwardBtn');
        const modeToggleBtn = document.getElementById('readingModeBtn');
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const iconFsEnter = document.getElementById('iconFsEnter');
        const iconFsExit = document.getElementById('iconFsExit');
        const subtitleRecenterBtn = document.getElementById('subtitleRecenterBtn');
        const RECENTER_MOBILE_RADIUS_PX = 75;
        let subtitleRecenterMobileRadius = document.getElementById('subtitleRecenterMobileRadius');
        if (!subtitleRecenterMobileRadius) {
            subtitleRecenterMobileRadius = document.createElement('div');
            subtitleRecenterMobileRadius.id = 'subtitleRecenterMobileRadius';
            subtitleRecenterMobileRadius.setAttribute('aria-hidden', 'true');
            document.body.appendChild(subtitleRecenterMobileRadius);
        }

        const BLAETTERN_CONTROLS_HIDE_DELAY_MS = 5000;
        const BLAETTERN_LONG_PRESS_DELAY_MS = 600;
        const BLAETTERN_SWIPE_TURN_RATIO = 0.18;
        const BLAETTERN_SWIPE_VELOCITY_THRESHOLD = 0.45;
        const BLAETTERN_SWIPE_SETTLE_MS = 220;
        const BLAETTERN_BOOKMARK_LABEL = 'Lesezeichen';
        const BLAETTERN_BOOKMARK_SAVED_LABEL = 'Gespeichert';
        let blaetternPages = [];
        let blaetternPageIndex = 0;
        let blaetternPaginationDirty = true;
        let blaetternPaginationKey = '';
        let blaetternSwipeAnimating = false;
        let blaetternSwipeState = null;
        let blaetternControlsVisible = true;
        let blaetternControlsHideTimer = null;
        let blaetternSwipeCommitTimer = null;
        let blaetternBookmarkHideTimer = null;
        let blaetternLongPressTimer = null;
        let blaetternSuppressTapUntil = 0;
        let blaetternLastSyncedSubtitleIndex = -1;

        function isBlaetternLayoutSelected() {
            return readerSentenceLayout === READER_LAYOUT_BLAETTERN;
        }

        function isBlaetternLayoutActive() {
            return !!(isReadingMode && isBlaetternLayoutSelected());
        }

        function markBlaetternPaginationDirty() {
            blaetternPaginationDirty = true;
            blaetternPaginationKey = '';
            blaetternLastSyncedSubtitleIndex = -1;
        }

        function normalizeReaderSentenceLayout(value) {
            if (value === 'kindle') return READER_LAYOUT_BLAETTERN;
            if (value === READER_LAYOUT_BLAETTERN) return READER_LAYOUT_BLAETTERN;
            if (value === READER_LAYOUT_FLAT) return READER_LAYOUT_FLAT;
            return READER_LAYOUT_TIMESTAMPS;
        }

        function normalizeReaderFontSize(value) {
            const parsed = Number(value);
            if (!Number.isFinite(parsed)) return READER_FONT_SIZE_DEFAULT;
            const rounded = Math.round(parsed);
            return Math.max(READER_FONT_SIZE_MIN, Math.min(READER_FONT_SIZE_MAX, rounded));
        }

        function normalizeReaderVolume(value) {
            if (value === null || value === undefined) return READER_VOLUME_DEFAULT;
            if (typeof value === 'string' && !value.trim()) return READER_VOLUME_DEFAULT;
            const parsed = Number(value);
            if (!Number.isFinite(parsed)) return READER_VOLUME_DEFAULT;
            const normalized = parsed > 1 ? (parsed / 100) : parsed;
            return Math.max(0, Math.min(1, normalized));
        }

        function normalizeReaderHexColor(value, fallback = null) {
            if (typeof value !== 'string') return fallback;
            const cleaned = value.trim().toLowerCase();
            if (!cleaned) return fallback;
            const match = cleaned.match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
            if (!match) return fallback;
            let hex = match[1];
            if (hex.length === 3) hex = hex.split('').map((ch) => `${ch}${ch}`).join('');
            return `#${hex.toLowerCase()}`;
        }

        function getReaderFallbackBgColor() {
            return document.body.classList.contains('scene-dimmer-light-mode') ? '#ede6d6' : '#11161d';
        }

        function getReaderFallbackTextColor() {
            return document.body.classList.contains('scene-dimmer-light-mode') ? '#1f1d18' : '#f2ecdc';
        }

        function mixHexColors(baseHex, tintHex, alpha = 0.5) {
            const base = hexToRgb(baseHex);
            const tint = hexToRgb(tintHex);
            if (!base || !tint) return baseHex;
            const a = Math.max(0, Math.min(1, Number(alpha) || 0));
            return rgbToHex(
                (base.r * (1 - a)) + (tint.r * a),
                (base.g * (1 - a)) + (tint.g * a),
                (base.b * (1 - a)) + (tint.b * a)
            );
        }

        function applyReaderDimmerTint() {
            const overlay = document.getElementById('sceneDimmerOverlay');
            if (!overlay) return;

            const base = document.body.classList.contains('scene-dimmer-light-mode') ? '#ffffff' : '#000000';
            const isFreezeMode = manualBackgroundDimLevel >= 100;
            if (!isFreezeMode || !readerBgColor) {
                overlay.style.backgroundColor = base;
                return;
            }

            const mixed = mixHexColors(base, readerBgColor, 0.5);
            overlay.style.backgroundColor = mixed;
        }

        let flatCompMeasureCanvas = null;
        let flatCompMeasureCtx = null;
        const flatCompMeasureCache = new Map();
        function getFlatLeadingCompensationPx(text, sampleEl) {
            if (readerSentenceLayout !== READER_LAYOUT_FLAT) return 0;
            if (!sampleEl || !text) return 0;
            if (!flatCompMeasureCanvas) {
                flatCompMeasureCanvas = document.createElement('canvas');
                flatCompMeasureCtx = flatCompMeasureCanvas.getContext('2d');
            }
            if (!flatCompMeasureCtx) return 0;

            const styles = window.getComputedStyle(sampleEl);
            const fontFamily = styles.fontFamily || 'serif';
            const fontSize = styles.fontSize || `${READER_FONT_SIZE_DEFAULT}px`;
            const fontStyle = styles.fontStyle || 'normal';
            const fontVariant = styles.fontVariant || 'normal';
            const cacheKey = `${fontStyle}|${fontVariant}|${fontSize}|${fontFamily}|${text}`;
            if (flatCompMeasureCache.has(cacheKey)) {
                return flatCompMeasureCache.get(cacheKey);
            }

            flatCompMeasureCtx.font = `${fontStyle} ${fontVariant} 400 ${fontSize} ${fontFamily}`;
            const normalWidth = flatCompMeasureCtx.measureText(text).width;
            flatCompMeasureCtx.font = `${fontStyle} ${fontVariant} 500 ${fontSize} ${fontFamily}`;
            const boldWidth = flatCompMeasureCtx.measureText(text).width;
            const compensationPx = Math.max(0, Math.ceil((boldWidth - normalWidth) * 100) / 100);
            flatCompMeasureCache.set(cacheKey, compensationPx);
            return compensationPx;
        }

        function applyFlatLeadingCompensation(lineEl, text) {
            if (!lineEl) return;
            if (readerSentenceLayout !== READER_LAYOUT_FLAT && readerSentenceLayout !== READER_LAYOUT_TIMESTAMPS) {
                lineEl.style.removeProperty('--flat-leading-comp');
                return;
            }
            const compensationPx = getFlatLeadingCompensationPx(text, lineEl);
            lineEl.style.setProperty('--flat-leading-comp', `${compensationPx}px`);
        }

        function applyReaderColorSettings() {
            const hasCustomText = typeof readerTextColor === 'string' && !!readerTextColor;
            subtitleContainer.classList.toggle('reader-custom-text', hasCustomText);

            if (hasCustomText) subtitleContainer.style.setProperty('--reader-custom-text', readerTextColor);
            else subtitleContainer.style.removeProperty('--reader-custom-text');
            applyReaderDimmerTint();
        }

        function applyReaderTextSettings(options = {}) {
            if (!subtitleContainer) return;
            const rerender = options.rerender !== false;
            const isFlatLayout = readerSentenceLayout === READER_LAYOUT_FLAT;
            const isBlaetternLayout = readerSentenceLayout === READER_LAYOUT_BLAETTERN;

            subtitleContainer.classList.toggle('reader-layout-flat', isFlatLayout);
            subtitleContainer.classList.toggle('reader-layout-blaettern', isBlaetternLayout);
            subtitleContainer.classList.toggle('reader-layout-timestamps', !isFlatLayout && !isBlaetternLayout);
            subtitleContainer.style.setProperty('--reader-font-size', `${readerFontSizePx}px`);
            applyReaderColorSettings();
            markBlaetternPaginationDirty();
            syncBlaetternUiState('reader-settings');

            // Open bookmark buttons may overlap after layout/font changes.
            subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((btn) => {
                btn.classList.remove('visible');
            });
            hideBlaetternBookmarkButton();

            if (rerender && typeof renderSubtitleLines === 'function') {
                subtitleContainer.dataset.version = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        }

        function syncReaderSettingsUi() {
            const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
            layoutInputs.forEach((input) => {
                input.checked = input.value === readerSentenceLayout;
            });

            const rangeInput = document.getElementById('readerFontSizeRange');
            const numberInput = document.getElementById('readerFontSizeNumber');
            const valueAsText = String(readerFontSizePx);
            if (rangeInput) rangeInput.value = valueAsText;
            if (numberInput) numberInput.value = valueAsText;

            const textVolumeRange = document.getElementById('readerTextVolumeRange');
            const textVolumeNumber = document.getElementById('readerTextVolumeNumber');
            const bgVolumeRange = document.getElementById('readerBackgroundVolumeRange');
            const bgVolumeNumber = document.getElementById('readerBackgroundVolumeNumber');
            const textVolumeValue = String(Math.round(readerTextVolume * 100));
            const bgVolumeValue = String(Math.round(readerBackgroundVolume * 100));
            if (textVolumeRange) textVolumeRange.value = textVolumeValue;
            if (textVolumeNumber) textVolumeNumber.value = textVolumeValue;
            if (bgVolumeRange) bgVolumeRange.value = bgVolumeValue;
            if (bgVolumeNumber) bgVolumeNumber.value = bgVolumeValue;

            const effectiveBg = readerBgColor || getReaderFallbackBgColor();
            const effectiveText = readerTextColor || getReaderFallbackTextColor();
            const bgPreview = document.getElementById('readerBgColorPreview');
            const textPreview = document.getElementById('readerTextColorPreview');
            if (bgPreview) bgPreview.style.background = effectiveBg;
            if (textPreview) textPreview.style.background = effectiveText;
            if (typeof readerColorWheelSync.bg === 'function') readerColorWheelSync.bg(effectiveBg);
            if (typeof readerColorWheelSync.text === 'function') readerColorWheelSync.text(effectiveText);

            updateAllSliderFills();
        }

        function setReaderSentenceLayout(nextLayout, options = {}) {
            const normalized = normalizeReaderSentenceLayout(nextLayout);
            if (!options.force && normalized === readerSentenceLayout) return;
            readerSentenceLayout = normalized;
            localStorage.setItem(READER_LAYOUT_STORAGE_KEY, readerSentenceLayout);
            applyReaderTextSettings({ rerender: true });
            syncReaderSettingsUi();
        }

        function setReaderFontSize(nextSize, options = {}) {
            const normalized = normalizeReaderFontSize(nextSize);
            if (!options.force && normalized === readerFontSizePx) return;
            readerFontSizePx = normalized;
            localStorage.setItem(READER_FONT_SIZE_STORAGE_KEY, String(readerFontSizePx));
            applyReaderTextSettings({
                rerender: readerSentenceLayout === READER_LAYOUT_FLAT || readerSentenceLayout === READER_LAYOUT_BLAETTERN
            });
            syncReaderSettingsUi();
        }

        function setReaderTextVolume(nextVolume, options = {}) {
            const normalized = normalizeReaderVolume(nextVolume);
            if (!options.force && normalized === readerTextVolume) return;
            readerTextVolume = normalized;
            localStorage.setItem(READER_TEXT_VOLUME_STORAGE_KEY, String(readerTextVolume));
            if (audioPlayer && typeof audioPlayer.volume === 'number') audioPlayer.volume = readerTextVolume;
            syncReaderSettingsUi();
        }

        function setReaderBackgroundVolume(nextVolume, options = {}) {
            const normalized = normalizeReaderVolume(nextVolume);
            if (!options.force && normalized === readerBackgroundVolume) return;
            readerBackgroundVolume = normalized;
            localStorage.setItem(READER_BACKGROUND_VOLUME_STORAGE_KEY, String(readerBackgroundVolume));
            if (typeof applySceneAudioMix === 'function') applySceneAudioMix('reader-background-volume');
            if (typeof applyBackgroundSfxVolume === 'function') applyBackgroundSfxVolume('reader-background-volume');
            syncReaderSettingsUi();
        }

        function setReaderBgColor(nextColor, options = {}) {
            const normalized = normalizeReaderHexColor(nextColor, null);
            if (!options.force && normalized === readerBgColor) return;
            readerBgColor = normalized;
            if (readerBgColor) localStorage.setItem(READER_BG_COLOR_STORAGE_KEY, readerBgColor);
            else localStorage.removeItem(READER_BG_COLOR_STORAGE_KEY);
            applyReaderTextSettings({ rerender: false });
            syncReaderSettingsUi();
        }

        function setReaderTextColor(nextColor, options = {}) {
            const normalized = normalizeReaderHexColor(nextColor, null);
            if (!options.force && normalized === readerTextColor) return;
            readerTextColor = normalized;
            if (readerTextColor) localStorage.setItem(READER_TEXT_COLOR_STORAGE_KEY, readerTextColor);
            else localStorage.removeItem(READER_TEXT_COLOR_STORAGE_KEY);
            applyReaderTextSettings({ rerender: false });
            syncReaderSettingsUi();
        }

        function clearBlaetternControlsHideTimer() {
            if (!blaetternControlsHideTimer) return;
            clearTimeout(blaetternControlsHideTimer);
            blaetternControlsHideTimer = null;
        }

        function clearBlaetternSwipeCommitTimer() {
            if (!blaetternSwipeCommitTimer) return;
            clearTimeout(blaetternSwipeCommitTimer);
            blaetternSwipeCommitTimer = null;
        }

        function clearBlaetternLongPressTimer() {
            if (!blaetternLongPressTimer) return;
            clearTimeout(blaetternLongPressTimer);
            blaetternLongPressTimer = null;
        }

        function clearBlaetternBookmarkHideTimer() {
            if (!blaetternBookmarkHideTimer) return;
            clearTimeout(blaetternBookmarkHideTimer);
            blaetternBookmarkHideTimer = null;
        }

        function setBlaetternControlsVisible(visible, reason = 'unspecified') {
            const shouldShow = !isBlaetternLayoutActive() ? true : !!visible;
            blaetternControlsVisible = shouldShow;
            if (!audioControlsEl) return;
            audioControlsEl.classList.toggle('blaettern-controls-hidden', !shouldShow);
            audioControlsEl.classList.toggle('blaettern-controls-visible', shouldShow);
            indexTrace('blaettern:controls', {
                reason,
                visible: shouldShow,
                readingMode: !!isReadingMode,
                layout: readerSentenceLayout
            });
        }

        function scheduleBlaetternControlsAutoHide(reason = 'idle') {
            clearBlaetternControlsHideTimer();
            if (!isBlaetternLayoutActive()) {
                setBlaetternControlsVisible(true, `${reason}:inactive`);
                return;
            }
            blaetternControlsHideTimer = setTimeout(() => {
                setBlaetternControlsVisible(false, `${reason}:timeout`);
            }, BLAETTERN_CONTROLS_HIDE_DELAY_MS);
        }

        function bumpBlaetternControlsAutoHide(reason = 'interaction') {
            if (!isBlaetternLayoutActive()) {
                clearBlaetternControlsHideTimer();
                setBlaetternControlsVisible(true, `${reason}:not-blaettern`);
                return;
            }
            setBlaetternControlsVisible(true, reason);
            scheduleBlaetternControlsAutoHide(reason);
        }

        function hideBlaetternBookmarkButton() {
            const root = subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
            const btn = root ? root.querySelector('.blaettern-bookmark-btn') : null;
            if (!btn) return;
            stopBlaetternBookmarkMapLayerLoop(btn);
            btn.classList.remove('visible', 'saved');
            btn.style.removeProperty('left');
            btn.style.removeProperty('top');
            btn.dataset.index = '';
            btn._flatLockedX = null;
            btn._flatLockedY = null;
            setBlaetternBookmarkButtonLabel(btn, BLAETTERN_BOOKMARK_LABEL);
            clearBlaetternBookmarkHideTimer();
        }

        function setBlaetternBookmarkButtonLabel(btn, label) {
            if (!btn) return;
            const labelNode = btn.querySelector('.bookmark-label');
            if (labelNode) labelNode.textContent = label;
            else btn.innerText = label;
        }

        function ensureBlaetternBookmarkButtonMode(btn) {
            if (!btn) return;
            if (btn.dataset.flatOverlay === '1') {
                btn.classList.add('bookmark-btn-flat-overlay');
                return;
            }

            btn.dataset.flatOverlay = '1';
            btn.innerHTML = '';
            const mapLayer = document.createElement('span');
            mapLayer.className = 'bookmark-map-layer';
            const mapCanvas = document.createElement('canvas');
            mapCanvas.className = 'bookmark-map-canvas';
            mapCanvas.setAttribute('aria-hidden', 'true');
            mapLayer.appendChild(mapCanvas);

            const overlayLayer = document.createElement('span');
            overlayLayer.className = 'bookmark-overlay-layer';
            const labelLayer = document.createElement('span');
            labelLayer.className = 'bookmark-label';
            labelLayer.textContent = BLAETTERN_BOOKMARK_LABEL;

            btn.appendChild(mapLayer);
            btn.appendChild(overlayLayer);
            btn.appendChild(labelLayer);
            btn.classList.add('bookmark-btn-flat-overlay');
        }

        function resolveBlaetternSceneCanvas() {
            const gameCanvas = document.getElementById('gameCanvas');
            if (gameCanvas instanceof HTMLCanvasElement) return gameCanvas;
            const anyCanvas = document.querySelector('canvas');
            return anyCanvas instanceof HTMLCanvasElement ? anyCanvas : null;
        }

        function drawBlaetternBookmarkMapLayer(btn) {
            if (!btn || !btn.classList.contains('bookmark-btn-flat-overlay')) return;
            const mapLayer = btn.querySelector('.bookmark-map-layer');
            const mapCanvas = mapLayer ? mapLayer.querySelector('.bookmark-map-canvas') : null;
            if (!(mapCanvas instanceof HTMLCanvasElement)) return;
            const drawCtx = mapCanvas.getContext('2d');
            if (!drawCtx || !mapLayer) return;
            const sceneCanvas = resolveBlaetternSceneCanvas();
            if (!sceneCanvas || typeof sceneCanvas.getBoundingClientRect !== 'function') {
                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                return;
            }
            try {
                const canvasRect = sceneCanvas.getBoundingClientRect();
                const btnRect = btn.getBoundingClientRect();
                if (!canvasRect.width || !canvasRect.height || !btnRect.width || !btnRect.height) return;
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const targetW = Math.max(1, Math.round(btnRect.width * dpr));
                const targetH = Math.max(1, Math.round(btnRect.height * dpr));
                if (mapCanvas.width !== targetW || mapCanvas.height !== targetH) {
                    mapCanvas.width = targetW;
                    mapCanvas.height = targetH;
                }
                drawCtx.clearRect(0, 0, targetW, targetH);

                const overlapLeft = Math.max(btnRect.left, canvasRect.left);
                const overlapTop = Math.max(btnRect.top, canvasRect.top);
                const overlapRight = Math.min(btnRect.right, canvasRect.right);
                const overlapBottom = Math.min(btnRect.bottom, canvasRect.bottom);
                if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) return;

                const scaleX = sceneCanvas.width / canvasRect.width;
                const scaleY = sceneCanvas.height / canvasRect.height;
                const srcX = (overlapLeft - canvasRect.left) * scaleX;
                const srcY = (overlapTop - canvasRect.top) * scaleY;
                const srcW = (overlapRight - overlapLeft) * scaleX;
                const srcH = (overlapBottom - overlapTop) * scaleY;
                const dstX = (overlapLeft - btnRect.left) * dpr;
                const dstY = (overlapTop - btnRect.top) * dpr;
                const dstW = (overlapRight - overlapLeft) * dpr;
                const dstH = (overlapBottom - overlapTop) * dpr;
                drawCtx.drawImage(sceneCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
            } catch (_) {
                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
            }
        }

        function stopBlaetternBookmarkMapLayerLoop(btn) {
            if (!btn || !btn._flatMapRaf) return;
            cancelAnimationFrame(btn._flatMapRaf);
            btn._flatMapRaf = 0;
        }

        function startBlaetternBookmarkMapLayerLoop(btn) {
            if (!btn || btn._flatMapRaf) return;
            const tick = () => {
                if (!btn.isConnected || !btn.classList.contains('visible') || !btn.classList.contains('bookmark-btn-flat-overlay')) {
                    btn._flatMapRaf = 0;
                    return;
                }
                drawBlaetternBookmarkMapLayer(btn);
                btn._flatMapRaf = requestAnimationFrame(tick);
            };
            tick();
        }

        function resetBlaetternInteractionState() {
            clearBlaetternLongPressTimer();
            clearBlaetternSwipeCommitTimer();
            blaetternSwipeState = null;
            blaetternSwipeAnimating = false;
            hideBlaetternBookmarkButton();
            const root = subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
            if (root) resetBlaetternLayerTransforms(root);
        }

        function syncBlaetternUiState(reason = 'unspecified') {
            if (!uiContainer) return;
            const active = isBlaetternLayoutActive();
            uiContainer.classList.toggle('blaettern-layout-active', active);
            if (!active) {
                clearBlaetternControlsHideTimer();
                setBlaetternControlsVisible(true, `${reason}:off`);
                resetBlaetternInteractionState();
                return;
            }
            if (!blaetternControlsVisible) {
                setBlaetternControlsVisible(false, `${reason}:keep-hidden`);
                scheduleBlaetternControlsAutoHide(`${reason}:keep-hidden`);
                return;
            }
            bumpBlaetternControlsAutoHide(`${reason}:on`);
        }

        function getBlaetternRoot() {
            return subtitleContainer ? subtitleContainer.querySelector('.blaettern-page-root') : null;
        }

        function getBlaetternLayerRefs(root) {
            if (!root) return null;
            const prev = root.querySelector('.blaettern-page-prev');
            const current = root.querySelector('.blaettern-page-current');
            const next = root.querySelector('.blaettern-page-next');
            if (!prev || !current || !next) return null;
            return { prev, current, next };
        }

        function getBlaetternViewportWidth() {
            const root = getBlaetternRoot();
            if (!root) return Math.max(1, subtitleContainer ? subtitleContainer.clientWidth : 1);
            return Math.max(1, root.clientWidth || subtitleContainer.clientWidth || 1);
        }

        function setBlaetternLayerTransition(root, enabled) {
            const refs = getBlaetternLayerRefs(root);
            if (!refs) return;
            const value = enabled ? `transform ${BLAETTERN_SWIPE_SETTLE_MS}ms ease` : 'none';
            refs.prev.style.transition = value;
            refs.current.style.transition = value;
            refs.next.style.transition = value;
        }

        function resetBlaetternLayerTransforms(root) {
            const refs = getBlaetternLayerRefs(root);
            const width = getBlaetternViewportWidth();
            if (!refs || !width) return;
            refs.prev.style.transform = `translate3d(${-width}px, 0, 0)`;
            refs.current.style.transform = 'translate3d(0, 0, 0)';
            refs.next.style.transform = `translate3d(${width}px, 0, 0)`;
        }

        function applyBlaetternSwipeOffset(root, rawOffsetPx) {
            const refs = getBlaetternLayerRefs(root);
            const width = getBlaetternViewportWidth();
            if (!refs || !width) return;
            const offsetPx = Number(rawOffsetPx) || 0;
            const hasPrev = blaetternPageIndex > 0;
            const hasNext = blaetternPageIndex < blaetternPages.length - 1;
            let clamped = offsetPx;
            const edgeClamp = width * 0.24;
            if (clamped < 0 && !hasNext) clamped = Math.max(clamped, -edgeClamp);
            if (clamped > 0 && !hasPrev) clamped = Math.min(clamped, edgeClamp);

            if (clamped < 0) {
                refs.prev.style.transform = `translate3d(${-width}px, 0, 0)`;
                refs.current.style.transform = `translate3d(${clamped}px, 0, 0)`;
                refs.next.style.transform = `translate3d(${width + clamped}px, 0, 0)`;
            } else {
                refs.prev.style.transform = `translate3d(${-width + clamped}px, 0, 0)`;
                refs.current.style.transform = `translate3d(${clamped}px, 0, 0)`;
                refs.next.style.transform = `translate3d(${width}px, 0, 0)`;
            }
            return clamped;
        }

        function createBlaetternLineElement(index, options = {}) {
            const track = subtitleTracks[index];
            const span = document.createElement('span');
            span.className = 'subtitle-line blaettern-line';
            span.dataset.index = String(index);
            span.innerText = track ? track.text : '';
            if (!options.forMeasure) {
                span.title = 'Tippen zum Abspielen';
                span.style.cursor = 'pointer';
                if (index === currentSubtitleIndex) span.classList.add('subtitle-current');
            }
            return span;
        }

        function clearBlaetternSmartLineStyle(lineEl) {
            if (!lineEl) return;
            lineEl.classList.remove('blaettern-line-smart');
            lineEl.style.removeProperty('--blaettern-smart-word-spacing');
            lineEl.style.removeProperty('--blaettern-smart-letter-spacing');
            lineEl.style.removeProperty('--blaettern-smart-stretch');
            lineEl.style.removeProperty('--blaettern-smart-wdth');
        }

        function applyBlaetternSmartJustification(layer) {
            if (!layer || layer.classList.contains('blaettern-page-empty')) return;
            const lineElements = Array.from(layer.querySelectorAll('.blaettern-line'));
            if (!lineElements.length) return;

            const layerRect = layer.getBoundingClientRect();
            const layerStyle = window.getComputedStyle(layer);
            const paddingLeft = parseFloat(layerStyle.paddingLeft) || 0;
            const paddingRight = parseFloat(layerStyle.paddingRight) || 0;
            const innerWidth = Math.max(1, layer.clientWidth - paddingLeft - paddingRight);
            if (innerWidth <= 20) return;
            const sampleLine = lineElements[0];
            const sampleLineStyle = sampleLine ? window.getComputedStyle(sampleLine) : null;
            const timestampGapPx = sampleLineStyle ? (parseFloat(sampleLineStyle.marginRight) || 0) : 0;

            const elementRectCount = new Map();
            const linesByTop = new Map();

            lineElements.forEach((lineEl) => {
                clearBlaetternSmartLineStyle(lineEl);
                const rects = Array.from(lineEl.getClientRects()).filter((rect) => rect.width > 1 && rect.height > 1);
                elementRectCount.set(lineEl, rects.length);
                rects.forEach((rect) => {
                    const key = Math.round(rect.top - layerRect.top);
                    let line = linesByTop.get(key);
                    if (!line) {
                        line = {
                            left: rect.left,
                            right: rect.right,
                            elements: new Set()
                        };
                        linesByTop.set(key, line);
                    } else {
                        line.left = Math.min(line.left, rect.left);
                        line.right = Math.max(line.right, rect.right);
                    }
                    line.elements.add(lineEl);
                });
            });

            const visualLines = Array.from(linesByTop.entries())
                .sort((a, b) => a[0] - b[0])
                .map((entry) => entry[1]);
            if (visualLines.length <= 1) return;

            for (let i = 0; i < visualLines.length - 1; i++) {
                const line = visualLines[i];
                const elements = Array.from(line.elements);
                if (!elements.length) continue;
                if (elements.some((el) => (elementRectCount.get(el) || 0) > 1)) continue;

                const lineWidth = Math.max(0, line.right - line.left);
                const boundaryCount = Math.max(0, elements.length - 1);
                const lineVisualWidth = lineWidth + (boundaryCount * timestampGapPx);
                const slack = innerWidth - lineVisualWidth;
                if (slack < 4 || slack > (innerWidth * 0.24)) continue;

                let letters = 0;
                let spaces = 0;
                elements.forEach((el) => {
                    const compact = (el.textContent || '').replace(/\s+/g, ' ').trim();
                    if (!compact) return;
                    letters += compact.replace(/\s/g, '').length;
                    const localSpaces = compact.match(/\s+/g);
                    if (localSpaces) spaces += localSpaces.length;
                });
                const totalGapUnits = spaces + boundaryCount;
                if (letters < 8) continue;
                if (totalGapUnits < 3 && slack > 20) continue;

                const sparseLine = totalGapUnits < 6;
                const wordShare = sparseLine ? 0.52 : 0.68;
                const letterShare = sparseLine ? 0.31 : 0.24;
                const stretchShare = 1 - wordShare - letterShare;

                const addWord = Math.min(1.35, Math.max(0, (slack * wordShare) / Math.max(1, totalGapUnits)));
                const addLetter = Math.min(0.21, Math.max(0, (slack * letterShare) / Math.max(36, letters)));
                const usedSlack = (addWord * totalGapUnits) + (addLetter * letters);
                const remainingSlack = Math.max(0, slack - usedSlack);
                const stretchScale = Math.min(1.085, 1 + ((remainingSlack * stretchShare) / Math.max(220, lineVisualWidth)));
                const stretchPercent = stretchScale * 100;
                const wdthValue = stretchPercent;

                if (addWord < 0.05 && addLetter < 0.01 && stretchScale <= 1.003) continue;

                elements.forEach((el) => {
                    el.classList.add('blaettern-line-smart');
                    el.style.setProperty('--blaettern-smart-word-spacing', `${addWord.toFixed(3)}px`);
                    el.style.setProperty('--blaettern-smart-letter-spacing', `${addLetter.toFixed(3)}px`);
                    el.style.setProperty('--blaettern-smart-stretch', `${stretchPercent.toFixed(2)}%`);
                    el.style.setProperty('--blaettern-smart-wdth', wdthValue.toFixed(2));
                });
            }
        }

        function findBlaetternPageIndexForSubtitle(subtitleIndex) {
            if (!blaetternPages.length) return 0;
            const idx = Math.max(0, Math.min(subtitleTracks.length - 1, Number(subtitleIndex) || 0));
            for (let i = 0; i < blaetternPages.length; i++) {
                const page = blaetternPages[i];
                if (idx >= page.startIndex && idx <= page.endIndex) return i;
            }
            return Math.max(0, blaetternPages.length - 1);
        }

        function ensureBlaetternPagination() {
            if (!subtitleContainer) return false;
            if (!subtitleTracks.length) {
                blaetternPages = [];
                blaetternPageIndex = 0;
                blaetternPaginationDirty = false;
                blaetternPaginationKey = '';
                return true;
            }

            const width = Math.round(subtitleContainer.clientWidth || 0);
            const height = Math.round(subtitleContainer.clientHeight || 0);
            if (width <= 20 || height <= 20) return false;

            const signature = [
                window.subtitleVersion || 0,
                subtitleTracks.length,
                readerFontSizePx,
                readerSentenceLayout,
                width,
                height
            ].join('|');

            if (!blaetternPaginationDirty && blaetternPaginationKey === signature && blaetternPages.length) {
                return true;
            }

            const measureLayer = document.createElement('div');
            measureLayer.className = 'blaettern-page-layer blaettern-page-layer-measure';
            measureLayer.setAttribute('aria-hidden', 'true');
            subtitleContainer.appendChild(measureLayer);

            const computedPages = [];
            let startIndex = 0;
            while (startIndex < subtitleTracks.length) {
                measureLayer.replaceChildren();
                let endIndex = startIndex - 1;

                for (let i = startIndex; i < subtitleTracks.length; i++) {
                    const node = createBlaetternLineElement(i, { forMeasure: true });
                    measureLayer.appendChild(node);
                    if (measureLayer.scrollHeight > (measureLayer.clientHeight + 1)) {
                        measureLayer.removeChild(node);
                        break;
                    }
                    endIndex = i;
                }

                if (endIndex < startIndex) {
                    endIndex = startIndex;
                    measureLayer.appendChild(createBlaetternLineElement(startIndex, { forMeasure: true }));
                }

                computedPages.push({ startIndex, endIndex });
                startIndex = endIndex + 1;
            }

            measureLayer.remove();
            blaetternPages = computedPages;
            blaetternPaginationDirty = false;
            blaetternPaginationKey = signature;

            const anchorIndex = Number.isFinite(currentSubtitleIndex) && currentSubtitleIndex >= 0
                ? currentSubtitleIndex
                : (blaetternPages[Math.max(0, Math.min(blaetternPageIndex, blaetternPages.length - 1))]?.startIndex || 0);
            blaetternPageIndex = findBlaetternPageIndexForSubtitle(anchorIndex);
            return true;
        }

        function renderBlaetternLayer(layer, pageIdx) {
            if (!layer) return;
            layer.replaceChildren();
            layer.dataset.pageIndex = String(pageIdx);

            if (pageIdx < 0 || pageIdx >= blaetternPages.length) {
                layer.classList.add('blaettern-page-empty');
                return;
            }

            layer.classList.remove('blaettern-page-empty');
            const page = blaetternPages[pageIdx];
            for (let i = page.startIndex; i <= page.endIndex; i++) {
                layer.appendChild(createBlaetternLineElement(i));
            }
            applyBlaetternSmartJustification(layer);
        }

        function updateBlaetternProgressBadge(root) {
            if (!root) return;
            const badge = root.querySelector('.blaettern-progress-indicator');
            if (!badge) return;
            if (!blaetternPages.length || !subtitleTracks.length) {
                badge.innerText = '0%';
                return;
            }
            const page = blaetternPages[Math.max(0, Math.min(blaetternPageIndex, blaetternPages.length - 1))];
            const percent = Math.max(0, Math.min(100, Math.floor((page.startIndex / Math.max(1, subtitleTracks.length)) * 100)));
            badge.innerText = `${percent}%`;
        }

        function ensureBlaetternRoot() {
            let root = getBlaetternRoot();
            if (root) return root;

            subtitleContainer.innerHTML = '';
            root = document.createElement('div');
            root.className = 'blaettern-page-root';

            const badge = document.createElement('div');
            badge.className = 'blaettern-progress-indicator';
            badge.setAttribute('aria-live', 'polite');
            root.appendChild(badge);

            const prev = document.createElement('div');
            prev.className = 'blaettern-page-layer blaettern-page-prev';
            root.appendChild(prev);

            const current = document.createElement('div');
            current.className = 'blaettern-page-layer blaettern-page-current';
            root.appendChild(current);

            const next = document.createElement('div');
            next.className = 'blaettern-page-layer blaettern-page-next';
            root.appendChild(next);

            const bookmarkBtn = document.createElement('button');
            bookmarkBtn.className = 'bookmark-btn blaettern-bookmark-btn bookmark-btn-flat-overlay';
            bookmarkBtn.type = 'button';
            bookmarkBtn.dataset.index = '';
            ensureBlaetternBookmarkButtonMode(bookmarkBtn);
            setBlaetternBookmarkButtonLabel(bookmarkBtn, BLAETTERN_BOOKMARK_LABEL);
            root.appendChild(bookmarkBtn);

            bookmarkBtn.addEventListener('click', async (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                const idx = Number(bookmarkBtn.dataset.index);
                if (!Number.isFinite(idx) || idx < 0 || idx >= subtitleTracks.length) return;
                const track = subtitleTracks[idx];
                if (!track || !window.GameState || typeof window.GameState.addBookmark !== 'function') return;

                const loreId = (isLoreMode && Number.isFinite(activeLoreId)) ? Number(activeLoreId) : null;
                const loreMeta = loreId && window.GameState && typeof window.GameState.getLore === 'function'
                    ? window.GameState.getLore(loreId)
                    : null;
                const bookmarkContentKey = loreId ? `lore${loreId}` : MAIN_CONTENT_KEY;
                const bookmarkChapter = loreId ? `lore${loreId}` : CURRENT_CHAPTER;
                const bookmarkChapterTitle = loreId
                    ? (loreMeta && loreMeta.title ? `Lore ${loreId}: ${loreMeta.title}` : `Lore ${loreId}`)
                    : CURRENT_CHAPTER_TITLE;
                const bookmarkAudioRef = loreId
                    ? ((loreMeta && loreMeta.audio) || (loreData && loreData.audio ? loreData.audio[loreId] : '') || `assets/lore${loreId}.mp3`)
                    : LEVEL.audioUrl;
                const bookmarkTextRef = loreId
                    ? ((loreMeta && loreMeta.text) || `assets/lore${loreId}.txt`)
                    : LEVEL.subtitleFile;
                const bm = {
                    id: Date.now(),
                    chapter: bookmarkChapter,
                    chapterTitle: bookmarkChapterTitle,
                    page: CURRENT_PAGE,
                    time: track.time,
                    textPreview: (track.text || '').substring(0, 60),
                    contentKey: bookmarkContentKey,
                    loreId: loreId,
                    audioRef: bookmarkAudioRef,
                    textRef: bookmarkTextRef,
                    createdAt: Date.now()
                };

                const added = await window.GameState.addBookmark(bm);
                if (added) {
                    bookmarkBtn.classList.add('saved', 'visible');
                    setBlaetternBookmarkButtonLabel(bookmarkBtn, BLAETTERN_BOOKMARK_SAVED_LABEL);
                    if (typeof updateBookmarkList === 'function') updateBookmarkList();
                    clearBlaetternBookmarkHideTimer();
                    blaetternBookmarkHideTimer = setTimeout(() => {
                        hideBlaetternBookmarkButton();
                    }, 1200);
                    return;
                }
                hideBlaetternBookmarkButton();
            });

            subtitleContainer.appendChild(root);
            return root;
        }

        function positionBlaetternBookmarkButton(btn, lineEl, point = null, options = {}) {
            if (!btn || !lineEl || !subtitleContainer) return;
            ensureBlaetternBookmarkButtonMode(btn);
            const containerRect = subtitleContainer.getBoundingClientRect();
            const lineRect = lineEl.getBoundingClientRect();
            const btnW = btn.offsetWidth || 118;
            const btnH = btn.offsetHeight || 36;
            const margin = 8;

            if (options.lockToExisting && Number.isFinite(btn._flatLockedX) && Number.isFinite(btn._flatLockedY)) {
                btn.style.left = `${Math.round(btn._flatLockedX)}px`;
                btn.style.top = `${Math.round(btn._flatLockedY)}px`;
                startBlaetternBookmarkMapLayerLoop(btn);
                drawBlaetternBookmarkMapLayer(btn);
                return;
            }

            let x = point && Number.isFinite(point.clientX)
                ? point.clientX - (btnW / 2)
                : lineRect.left + ((lineRect.width - btnW) / 2);
            let y = lineRect.top - btnH - 10;
            if (y < containerRect.top + margin) y = lineRect.bottom + 10;

            x = Math.max(margin, Math.min(window.innerWidth - btnW - margin, x));
            y = Math.max(margin, Math.min(window.innerHeight - btnH - margin, y));
            btn._flatLockedX = Math.round(x);
            btn._flatLockedY = Math.round(y);
            btn.style.left = `${btn._flatLockedX}px`;
            btn.style.top = `${btn._flatLockedY}px`;
            startBlaetternBookmarkMapLayerLoop(btn);
            drawBlaetternBookmarkMapLayer(btn);
        }

        function showBlaetternBookmarkButton(lineIndex, point = null) {
            const root = ensureBlaetternRoot();
            const lineEl = root.querySelector(`.blaettern-page-current .blaettern-line[data-index="${lineIndex}"]`);
            const btn = root.querySelector('.blaettern-bookmark-btn');
            if (!lineEl || !btn) return;
            btn.dataset.index = String(lineIndex);
            ensureBlaetternBookmarkButtonMode(btn);
            setBlaetternBookmarkButtonLabel(btn, BLAETTERN_BOOKMARK_LABEL);
            btn.classList.remove('saved');
            btn.classList.add('visible');
            positionBlaetternBookmarkButton(btn, lineEl, point);
            clearBlaetternBookmarkHideTimer();
            blaetternBookmarkHideTimer = setTimeout(() => {
                if (!btn.classList.contains('saved')) hideBlaetternBookmarkButton();
            }, 4000);
        }

        function renderBlaetternPageWindow() {
            const root = ensureBlaetternRoot();
            const refs = getBlaetternLayerRefs(root);
            if (!refs) return;
            renderBlaetternLayer(refs.prev, blaetternPageIndex - 1);
            renderBlaetternLayer(refs.current, blaetternPageIndex);
            renderBlaetternLayer(refs.next, blaetternPageIndex + 1);
            setBlaetternLayerTransition(root, false);
            resetBlaetternLayerTransforms(root);
            updateBlaetternProgressBadge(root);
            hideBlaetternBookmarkButton();
        }

        function renderBlaetternReadingPage(centerIndex) {
            syncReadingTopFadeMask(-1);
            if (!subtitleTracks.length) {
                subtitleContainer.innerHTML = '';
                const emptyLine = document.createElement('div');
                emptyLine.className = 'subtitle-line subtitle-current';
                emptyLine.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(emptyLine);
                return;
            }

            if (!ensureBlaetternPagination()) return;
            const safeIndex = Math.max(
                0,
                Math.min(
                    subtitleTracks.length - 1,
                    Number.isFinite(centerIndex) && centerIndex >= 0 ? centerIndex : 0
                )
            );

            if (!blaetternSwipeAnimating && !subtitleFollowLocked) {
                if (blaetternLastSyncedSubtitleIndex !== safeIndex) {
                    blaetternPageIndex = findBlaetternPageIndexForSubtitle(safeIndex);
                }
            }
            blaetternLastSyncedSubtitleIndex = safeIndex;
            renderBlaetternPageWindow();
        }

        function resolveBlaetternSwipeDirection(offsetPx, velocityPxPerMs) {
            const width = getBlaetternViewportWidth();
            if (!width || blaetternPages.length <= 1) return 0;
            const hasPrev = blaetternPageIndex > 0;
            const hasNext = blaetternPageIndex < blaetternPages.length - 1;
            const turnThreshold = width * BLAETTERN_SWIPE_TURN_RATIO;

            if (offsetPx < 0 && hasNext) {
                if (Math.abs(offsetPx) > turnThreshold || velocityPxPerMs <= -BLAETTERN_SWIPE_VELOCITY_THRESHOLD) return 1;
            }
            if (offsetPx > 0 && hasPrev) {
                if (Math.abs(offsetPx) > turnThreshold || velocityPxPerMs >= BLAETTERN_SWIPE_VELOCITY_THRESHOLD) return -1;
            }
            return 0;
        }

        function finishBlaetternSwipe(direction) {
            const root = getBlaetternRoot();
            if (!root) return;
            const refs = getBlaetternLayerRefs(root);
            const width = getBlaetternViewportWidth();
            if (!refs || !width) return;

            blaetternSwipeAnimating = true;
            setBlaetternLayerTransition(root, true);

            if (direction === 1) {
                refs.current.style.transform = `translate3d(${-width}px, 0, 0)`;
                refs.next.style.transform = 'translate3d(0, 0, 0)';
            } else if (direction === -1) {
                refs.prev.style.transform = 'translate3d(0, 0, 0)';
                refs.current.style.transform = `translate3d(${width}px, 0, 0)`;
            } else {
                resetBlaetternLayerTransforms(root);
            }

            clearBlaetternSwipeCommitTimer();
            blaetternSwipeCommitTimer = setTimeout(() => {
                blaetternSwipeAnimating = false;
                if (direction === 1) blaetternPageIndex = Math.min(blaetternPages.length - 1, blaetternPageIndex + 1);
                if (direction === -1) blaetternPageIndex = Math.max(0, blaetternPageIndex - 1);
                if (direction !== 0 && isBlaetternLayoutActive()) {
                    setSubtitleFollowLocked(true, 'blaettern-swipe');
                }
                renderBlaetternPageWindow();
                if (isBlaetternLayoutActive()) scheduleBlaetternControlsAutoHide('swipe-finish');
            }, BLAETTERN_SWIPE_SETTLE_MS + 10);
        }

        async function handleBlaetternTimestampTap(lineIndex) {
            if (!Number.isFinite(lineIndex) || lineIndex < 0 || lineIndex >= subtitleTracks.length) return;
            if (contentSwitchInProgress) return;
            if (Date.now() < blaetternSuppressTapUntil) return;
            const track = subtitleTracks[lineIndex];
            if (!track) return;
            setSubtitleFollowLocked(false, 'blaettern-tap');
            await seekAndSyncSubtitle(track.time, `blaettern-click:${lineIndex}`);
            try {
                await audioPlayer.play();
            } catch (_) {
                // ignore autoplay restrictions
            }
            bumpBlaetternControlsAutoHide('blaettern-tap');
        }

        function onBlaetternPointerDown(event) {
            if (!isBlaetternLayoutActive()) return;
            if (contentSwitchInProgress) return;
            if (blaetternSwipeAnimating) {
                event.preventDefault();
                return;
            }
            if (event.button !== undefined && event.button !== 0) return;
            if (event.target && typeof event.target.closest === 'function' && event.target.closest('.blaettern-bookmark-btn')) {
                bumpBlaetternControlsAutoHide('blaettern-bookmark-touch');
                return;
            }

            const targetLine = event.target && typeof event.target.closest === 'function'
                ? event.target.closest('.blaettern-line')
                : null;
            const consumeTap = !blaetternControlsVisible;
            bumpBlaetternControlsAutoHide('blaettern-touch');
            if (consumeTap) blaetternSuppressTapUntil = Date.now() + 300;

            hideBlaetternBookmarkButton();
            blaetternSwipeState = {
                pointerId: event.pointerId,
                startX: event.clientX,
                startY: event.clientY,
                lastX: event.clientX,
                lastY: event.clientY,
                startTime: performance.now(),
                mode: 'pending',
                offsetPx: 0,
                lineIndex: targetLine ? Number(targetLine.dataset.index) : -1,
                consumeTap,
                movedBeyondTap: false
            };

            if (subtitleContainer && typeof subtitleContainer.setPointerCapture === 'function') {
                try {
                    subtitleContainer.setPointerCapture(event.pointerId);
                } catch (_) {
                    // no-op
                }
            }

            clearBlaetternLongPressTimer();
            if (!consumeTap && targetLine && Number.isFinite(blaetternSwipeState.lineIndex) && blaetternSwipeState.lineIndex >= 0) {
                blaetternLongPressTimer = setTimeout(() => {
                    if (!blaetternSwipeState || blaetternSwipeState.mode !== 'pending') return;
                    blaetternSwipeState.mode = 'longpress';
                    blaetternSuppressTapUntil = Date.now() + 500;
                    showBlaetternBookmarkButton(blaetternSwipeState.lineIndex, {
                        clientX: blaetternSwipeState.lastX,
                        clientY: blaetternSwipeState.lastY
                    });
                }, BLAETTERN_LONG_PRESS_DELAY_MS);
            }

            event.preventDefault();
        }

        function onBlaetternPointerMove(event) {
            if (!isBlaetternLayoutActive()) return;
            if (!blaetternSwipeState) return;
            if (event.pointerId !== blaetternSwipeState.pointerId) return;

            const dx = event.clientX - blaetternSwipeState.startX;
            const dy = event.clientY - blaetternSwipeState.startY;
            blaetternSwipeState.lastX = event.clientX;
            blaetternSwipeState.lastY = event.clientY;

            if (blaetternSwipeState.mode === 'pending') {
                if (Math.abs(dx) > 14 && Math.abs(dx) > Math.abs(dy) * 1.1) {
                    blaetternSwipeState.mode = 'swipe';
                    blaetternSwipeState.movedBeyondTap = true;
                    clearBlaetternLongPressTimer();
                } else if (Math.hypot(dx, dy) > 9) {
                    blaetternSwipeState.movedBeyondTap = true;
                    clearBlaetternLongPressTimer();
                }
            }

            if (blaetternSwipeState.mode !== 'swipe') return;
            const root = getBlaetternRoot();
            if (!root) return;
            setBlaetternLayerTransition(root, false);
            blaetternSwipeState.offsetPx = applyBlaetternSwipeOffset(root, dx);
            event.preventDefault();
        }

        function onBlaetternPointerEnd(event) {
            if (!isBlaetternLayoutActive()) return;
            if (!blaetternSwipeState) return;
            if (event.pointerId !== blaetternSwipeState.pointerId) return;

            const localState = blaetternSwipeState;
            blaetternSwipeState = null;
            clearBlaetternLongPressTimer();
            if (subtitleContainer && typeof subtitleContainer.releasePointerCapture === 'function') {
                try {
                    subtitleContainer.releasePointerCapture(event.pointerId);
                } catch (_) {
                    // no-op
                }
            }

            if (event.type === 'pointercancel') return;

            if (localState.mode === 'swipe') {
                const elapsed = Math.max(1, performance.now() - localState.startTime);
                const velocity = (localState.lastX - localState.startX) / elapsed;
                const direction = resolveBlaetternSwipeDirection(localState.offsetPx, velocity);
                finishBlaetternSwipe(direction);
                event.preventDefault();
                return;
            }

            if (localState.mode === 'longpress') {
                event.preventDefault();
                return;
            }

            if (localState.consumeTap) {
                event.preventDefault();
                return;
            }

            if (localState.movedBeyondTap) {
                event.preventDefault();
                return;
            }

            if (Number.isFinite(localState.lineIndex) && localState.lineIndex >= 0) {
                handleBlaetternTimestampTap(localState.lineIndex);
                event.preventDefault();
            }
        }

        function clamp01(value) {
            if (!Number.isFinite(value)) return 0;
            if (value <= 0) return 0;
            if (value >= 1) return 1;
            return value;
        }

        function hexToRgb(hex) {
            const normalized = normalizeReaderHexColor(hex, null);
            if (!normalized) return null;
            const raw = normalized.slice(1);
            return {
                r: parseInt(raw.slice(0, 2), 16),
                g: parseInt(raw.slice(2, 4), 16),
                b: parseInt(raw.slice(4, 6), 16)
            };
        }

        function rgbToHex(r, g, b) {
            const toHex = (value) => {
                const clamped = Math.max(0, Math.min(255, Math.round(value)));
                return clamped.toString(16).padStart(2, '0');
            };
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function rgbToHsl(r, g, b) {
            const rr = r / 255;
            const gg = g / 255;
            const bb = b / 255;
            const max = Math.max(rr, gg, bb);
            const min = Math.min(rr, gg, bb);
            const delta = max - min;
            let h = 0;
            const l = (max + min) / 2;
            let s = 0;

            if (delta !== 0) {
                s = delta / (1 - Math.abs((2 * l) - 1));
                if (max === rr) h = 60 * (((gg - bb) / delta) % 6);
                else if (max === gg) h = 60 * (((bb - rr) / delta) + 2);
                else h = 60 * (((rr - gg) / delta) + 4);
            }

            if (!Number.isFinite(h)) h = 0;
            if (h < 0) h += 360;
            return { h, s: clamp01(s), l: clamp01(l) };
        }

        function hslToRgb(h, s, l) {
            const hue = ((Number(h) % 360) + 360) % 360;
            const sat = clamp01(s);
            const lig = clamp01(l);
            const c = (1 - Math.abs((2 * lig) - 1)) * sat;
            const hh = hue / 60;
            const x = c * (1 - Math.abs((hh % 2) - 1));
            let r1 = 0;
            let g1 = 0;
            let b1 = 0;

            if (hh >= 0 && hh < 1) { r1 = c; g1 = x; }
            else if (hh < 2) { r1 = x; g1 = c; }
            else if (hh < 3) { g1 = c; b1 = x; }
            else if (hh < 4) { g1 = x; b1 = c; }
            else if (hh < 5) { r1 = x; b1 = c; }
            else { r1 = c; b1 = x; }

            const m = lig - (c / 2);
            return {
                r: Math.round((r1 + m) * 255),
                g: Math.round((g1 + m) * 255),
                b: Math.round((b1 + m) * 255)
            };
        }

        function getWheelColorAtOffset(offsetX, offsetY, radius) {
            const safeRadius = Math.max(1, radius);
            const distance = Math.min(1, Math.hypot(offsetX, offsetY) / safeRadius);
            const hue = ((Math.atan2(offsetY, offsetX) * (180 / Math.PI)) + 360) % 360;
            const saturation = 0.18 + (distance * 0.82);
            const lightness = 0.64 - (distance * 0.24);
            const rgb = hslToRgb(hue, saturation, lightness);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }

        function setReaderWheelMarkerFromHex(markerEl, wheelEl, hexColor) {
            if (!markerEl || !wheelEl) return;
            const rgb = hexToRgb(hexColor);
            if (!rgb) return;
            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            const size = Math.min(wheelEl.clientWidth || wheelEl.width || 0, wheelEl.clientHeight || wheelEl.height || 0);
            if (!size) return;
            const radius = size / 2;
            const sat = clamp01((hsl.s - 0.18) / 0.82);
            const angle = (hsl.h * Math.PI) / 180;
            const markerRadius = sat * radius;
            const x = radius + (Math.cos(angle) * markerRadius);
            const y = radius + (Math.sin(angle) * markerRadius);
            markerEl.style.left = `${x}px`;
            markerEl.style.top = `${y}px`;
        }

        function drawReaderGoetheColorWheel(canvasEl) {
            if (!canvasEl) return;
            const width = Number(canvasEl.width) || 168;
            const height = Number(canvasEl.height) || 168;
            const ctx = canvasEl.getContext('2d');
            if (!ctx) return;

            const cx = width / 2;
            const cy = height / 2;
            const radius = Math.min(width, height) / 2;
            const image = ctx.createImageData(width, height);
            const data = image.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x + 0.5 - cx;
                    const dy = y + 0.5 - cy;
                    const dist = Math.hypot(dx, dy);
                    const index = (y * width + x) * 4;
                    if (dist > radius) {
                        data[index + 3] = 0;
                        continue;
                    }
                    const distNorm = dist / radius;
                    const hue = ((Math.atan2(dy, dx) * (180 / Math.PI)) + 360) % 360;
                    const saturation = 0.18 + (distNorm * 0.82);
                    const lightness = 0.64 - (distNorm * 0.24);
                    const rgb = hslToRgb(hue, saturation, lightness);
                    data[index] = rgb.r;
                    data[index + 1] = rgb.g;
                    data[index + 2] = rgb.b;
                    data[index + 3] = 255;
                }
            }

            ctx.clearRect(0, 0, width, height);
            ctx.putImageData(image, 0, 0);
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, radius - 0.5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.36, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }

        function initReaderColorWheelControl(config) {
            const canvasEl = document.getElementById(config.canvasId);
            const markerEl = document.getElementById(config.markerId);
            const previewEl = document.getElementById(config.previewId);
            if (!canvasEl || !markerEl || !previewEl || typeof config.onPick !== 'function') {
                return null;
            }

            drawReaderGoetheColorWheel(canvasEl);

            const updatePreviewAndMarker = (hexColor) => {
                const normalized = normalizeReaderHexColor(hexColor, null);
                if (!normalized) return;
                previewEl.style.background = normalized;
                setReaderWheelMarkerFromHex(markerEl, canvasEl, normalized);
            };

            const pickFromClientPoint = (clientX, clientY) => {
                const rect = canvasEl.getBoundingClientRect();
                if (!rect.width || !rect.height) return;
                const radius = Math.min(rect.width, rect.height) / 2;
                const localX = clientX - (rect.left + (rect.width / 2));
                const localY = clientY - (rect.top + (rect.height / 2));
                const hex = getWheelColorAtOffset(localX, localY, radius);
                config.onPick(hex);
            };

            let pointerActive = false;
            const onPointerMove = (event) => {
                if (!pointerActive) return;
                pickFromClientPoint(event.clientX, event.clientY);
            };
            const onPointerUp = () => {
                pointerActive = false;
            };
            canvasEl.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                pointerActive = true;
                pickFromClientPoint(event.clientX, event.clientY);
            });
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('pointercancel', onPointerUp);

            canvasEl.addEventListener('touchstart', (event) => {
                if (!event.touches || !event.touches.length) return;
                const t = event.touches[0];
                pickFromClientPoint(t.clientX, t.clientY);
            }, { passive: true });
            canvasEl.addEventListener('touchmove', (event) => {
                if (!event.touches || !event.touches.length) return;
                const t = event.touches[0];
                pickFromClientPoint(t.clientX, t.clientY);
            }, { passive: true });

            return updatePreviewAndMarker;
        }

        // --- Slider fill gradient for WebKit (Chrome/Safari/Electron) ---
        function updateSliderFill(rangeEl) {
            // Gold fill removed â€” plain white track only
            if (rangeEl) rangeEl.style.background = '';
        }

        function updateAllSliderFills() {
            ['readerFontSizeRange', 'readerTextVolumeRange', 'readerBackgroundVolumeRange'].forEach(id => {
                updateSliderFill(document.getElementById(id));
            });
        }

        function initReaderSettingsControls() {
            const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
            layoutInputs.forEach((input) => {
                input.addEventListener('change', () => {
                    if (!input.checked) return;
                    setReaderSentenceLayout(input.value);
                });
            });

            const rangeInput = document.getElementById('readerFontSizeRange');
            const numberInput = document.getElementById('readerFontSizeNumber');
            if (rangeInput) {
                rangeInput.addEventListener('input', (event) => {
                    setReaderFontSize(event.target.value);
                    updateSliderFill(event.target);
                });
            }
            if (numberInput) {
                numberInput.addEventListener('input', (event) => {
                    setReaderFontSize(event.target.value);
                });
                numberInput.addEventListener('change', (event) => {
                    setReaderFontSize(event.target.value, { force: true });
                });
            }

            const bindVolumeInputs = (rangeId, numberId, setter) => {
                const rangeEl = document.getElementById(rangeId);
                const numberEl = document.getElementById(numberId);
                if (rangeEl) {
                    rangeEl.addEventListener('input', (event) => {
                        setter(event.target.value);
                        updateSliderFill(event.target);
                    });
                }
                if (numberEl) {
                    numberEl.addEventListener('input', (event) => {
                        setter(event.target.value);
                    });
                    numberEl.addEventListener('change', (event) => {
                        setter(event.target.value, { force: true });
                    });
                }
            };

            bindVolumeInputs('readerTextVolumeRange', 'readerTextVolumeNumber', setReaderTextVolume);
            bindVolumeInputs('readerBackgroundVolumeRange', 'readerBackgroundVolumeNumber', setReaderBackgroundVolume);

            readerColorWheelSync.bg = initReaderColorWheelControl({
                canvasId: 'readerBgColorWheel',
                markerId: 'readerBgColorMarker',
                previewId: 'readerBgColorPreview',
                onPick: (hexColor) => setReaderBgColor(hexColor)
            });

            readerColorWheelSync.text = initReaderColorWheelControl({
                canvasId: 'readerTextColorWheel',
                markerId: 'readerTextColorMarker',
                previewId: 'readerTextColorPreview',
                onPick: (hexColor) => setReaderTextColor(hexColor)
            });

            const colorControls = {
                bg: {
                    key: 'bg',
                    button: document.getElementById('readerBgColorToggleBtn'),
                    popover: document.getElementById('readerBgColorPickerPopover'),
                    sync: () => {
                        if (typeof readerColorWheelSync.bg === 'function') {
                            readerColorWheelSync.bg(readerBgColor || getReaderFallbackBgColor());
                        }
                    }
                },
                text: {
                    key: 'text',
                    button: document.getElementById('readerTextColorToggleBtn'),
                    popover: document.getElementById('readerTextColorPickerPopover'),
                    sync: () => {
                        if (typeof readerColorWheelSync.text === 'function') {
                            readerColorWheelSync.text(readerTextColor || getReaderFallbackTextColor());
                        }
                    }
                }
            };

            const closeAllColorPopovers = () => {
                Object.values(colorControls).forEach((control) => {
                    if (!control || !control.popover || !control.button) return;
                    control.popover.hidden = true;
                    control.button.setAttribute('aria-expanded', 'false');
                });
                readerColorPopoverState.activeKey = null;
            };

            const openColorPopover = (key) => {
                const control = colorControls[key];
                if (!control || !control.popover || !control.button) return;
                closeAllColorPopovers();
                control.popover.hidden = false;
                control.button.setAttribute('aria-expanded', 'true');
                control.sync();
                readerColorPopoverState.activeKey = key;
            };

            Object.values(colorControls).forEach((control) => {
                if (!control || !control.button || !control.popover) return;
                control.button.addEventListener('click', (event) => {
                    event.preventDefault();
                    const shouldOpen = readerColorPopoverState.activeKey !== control.key;
                    if (shouldOpen) openColorPopover(control.key);
                    else closeAllColorPopovers();
                });
            });

            document.addEventListener('click', (event) => {
                if (!readerColorPopoverState.activeKey) return;
                const activeControl = colorControls[readerColorPopoverState.activeKey];
                if (!activeControl || !activeControl.button || !activeControl.popover) return;
                const target = event.target;
                if (activeControl.button.contains(target) || activeControl.popover.contains(target)) return;
                closeAllColorPopovers();
            });

            document.addEventListener('keydown', (event) => {
                if (event.key !== 'Escape') return;
                if (!readerColorPopoverState.activeKey) return;
                closeAllColorPopovers();
            });

            const resetColorsBtn = document.getElementById('readerColorResetBtn');
            if (resetColorsBtn) {
                resetColorsBtn.addEventListener('click', () => {
                    setReaderBgColor(null, { force: true });
                    setReaderTextColor(null, { force: true });
                });
            }

            syncReaderSettingsUi();
            applyReaderTextSettings({ rerender: false });
        }

        initReaderSettingsControls();

        const globalVisualDimmer = window.GlobalVisualDimmer
            ? window.GlobalVisualDimmer.init({
                overlayId: 'sceneDimmerOverlay',
                toggleButtonId: 'sceneDimmerToggleBtn',
                iconFullId: 'sceneDimmerIconFull',
                iconHalfId: 'sceneDimmerIconHalf',
                iconCrescentId: 'sceneDimmerIconCrescent',
                iconSunId: 'sceneDimmerIconSun'
            })
            : null;
        manualBackgroundDimLevel = globalVisualDimmer ? globalVisualDimmer.getLevel() : 0;
        let pendingForceReadingFromFreeze = false;
        let shouldResumePlaybackAfterDimmerUnfreeze = false;
        let dimmerResumeToken = 0;
        let modeSwitchInitialized = false;
        if (globalVisualDimmer) {
            globalVisualDimmer.onChange(({ level, frozen }) => {
                manualBackgroundDimLevel = level;
                window.visualFreezeActive = frozen;
                applyReaderDimmerTint();
                dimmerResumeToken += 1;
                const changeToken = dimmerResumeToken;

                const currentlyPlaying = (typeof audioPlayer?.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !!audioPlayer && !audioPlayer.paused;

                if (frozen) {
                    shouldResumePlaybackAfterDimmerUnfreeze = shouldResumePlaybackAfterDimmerUnfreeze || currentlyPlaying;
                    pendingForceReadingFromFreeze = true;
                    if (modeSwitchInitialized) {
                        setReadingMode(true, 'dimmer-freeze');
                        pendingForceReadingFromFreeze = false;
                    }
                } else {
                    pendingForceReadingFromFreeze = false;
                    if (shouldResumePlaybackAfterDimmerUnfreeze && !contentSwitchInProgress && !document.hidden) {
                        setTimeout(async () => {
                            try {
                                if (changeToken !== dimmerResumeToken) return;
                                if (document.hidden || contentSwitchInProgress) return;

                                const likelyPlaying = (typeof audioPlayer?.isProbablyPlaying === 'function')
                                    ? audioPlayer.isProbablyPlaying()
                                    : !!audioPlayer && !audioPlayer.paused;

                                if (!likelyPlaying || audioPlayer.paused) {
                                    const started = await verifyPlaybackStarted(3, 260);
                                    indexDebugNote('dimmer-resume', `started=${started} lore=${isLoreMode}`);
                                }
                                syncPlayPauseIcon();
                            } catch (e) {
                                indexDebugNote('dimmer-resume-error', e && e.message ? e.message : String(e));
                            }
                        }, 80);
                    }
                    shouldResumePlaybackAfterDimmerUnfreeze = false;
                }
                if (!frozen && gameReady && !document.hidden) {
                    lastTime = 0;
                    startGameLoop();
                }
            });
            window.visualFreezeActive = globalVisualDimmer.isFrozen();
            pendingForceReadingFromFreeze = window.visualFreezeActive;

        }
        applyReaderDimmerTint();

        function isAudioTransportPaused() {
            if (!audioPlayer) return true;
            if (typeof audioPlayer.isTransportPaused === 'function') {
                return audioPlayer.isTransportPaused();
            }
            return !!audioPlayer.paused;
        }

        function syncPlayPauseIcon() {
            const isPaused = isAudioTransportPaused();
            iconPlay.style.display = isPaused ? 'block' : 'none';
            iconPause.style.display = isPaused ? 'none' : 'block';
            indexTrace('icon:sync', {
                paused: isPaused,
                iconPlay: iconPlay.style.display,
                iconPause: iconPause.style.display,
                currentTime: Number(((audioPlayer && audioPlayer.currentTime) || 0).toFixed(3))
            });
        }

        audioPlayer.addEventListener('play', syncPlayPauseIcon);
        audioPlayer.addEventListener('pause', syncPlayPauseIcon);
        audioPlayer.addEventListener('ended', syncPlayPauseIcon);
        audioPlayer.addEventListener('canplay', syncPlayPauseIcon);
        syncPlayPauseIcon();

        // FORCE REMOVE FOCUS FROM BUTTONS
        // This prevents the "Orange Box" from appearing when using arrow keys after clicking a button
        document.querySelectorAll('button').forEach(btn => {
            // Option 1: Blur on click
            btn.addEventListener('click', () => {
                btn.blur();
                window.focus();
            });
            // Option 2: Build wall against focus
            btn.addEventListener('focus', () => {
                btn.blur();
            });
            // Option 3: Prevent default on mousedown (stops focus, keeps click)
            btn.addEventListener('mousedown', (e) => {
                if (document.activeElement !== btn) {
                    e.preventDefault();
                }
            });
        });

        // Ambient und Schritte Audio via SC Adapter
        const ambientAudio = new SCAudioAdapter();
        ambientAudio.src = getSCUrl('assets/medieval_town.mp3');
        ambientAudio.volume = AUDIO_PROFILE.ambient * readerBackgroundVolume;
        // Index uses a dedicated visibility handler; avoid duplicate manager decisions.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(ambientAudio);
        }

        function isPrimaryNarrationPlaying() {
            if (!audioPlayer) return false;
            return (typeof audioPlayer.isProbablyPlaying === 'function')
                ? audioPlayer.isProbablyPlaying()
                : !audioPlayer.paused;
        }

        function allowAuxScPlayback() {
            return !isPrimaryNarrationPlaying() && !contentSwitchInProgress && !document.hidden;
        }

        function syncAuxScPlayback(reason = 'unspecified') {
            if (!allowAuxScPlayback()) {
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
                if (!ambientAudio.paused) {
                    ambientAudio.pause();
                }
                indexDebugNote('aux-audio', `${reason} blocked`);
                return;
            }

            if (audioUnlocked && gameReady && ambientAudio.paused) {
                ambientAudio.play().catch(() => { });
            }
            indexDebugNote('aux-audio', `${reason} allowed`);
        }

        function applySceneAudioMix(reason = 'unspecified') {
            let ambientTarget = AUDIO_PROFILE.ambient;
            let footstepTarget = AUDIO_PROFILE.footsteps;

            if (isLoreMode) ambientTarget *= 0.68;
            if (isReadingMode) footstepTarget *= 0.65;
            if (isLoreMode) footstepTarget *= 0.45;

            ambientTarget *= readerBackgroundVolume;
            footstepTarget *= readerBackgroundVolume;
            ambientAudio.volume = Math.max(0, Math.min(1, ambientTarget));
            footstepSound.volume = Math.max(0, Math.min(1, footstepTarget));
            syncAuxScPlayback(`mix:${reason}`);
            indexDebugNote('audio-mix', `${reason} ambient=${ambientAudio.volume.toFixed(3)} foot=${footstepSound.volume.toFixed(3)} ios=${isIOSDevice}`);
        }

        function applyBackgroundSfxVolume(reason = 'unspecified') {
            shimmerSound.volume = Math.max(0, Math.min(1, SHIMMER_BASE_VOLUME * readerBackgroundVolume));
            indexDebugNote('bg-sfx', `${reason} shimmer=${shimmerSound.volume.toFixed(3)}`);
        }
        applySceneAudioMix('init');
        applyBackgroundSfxVolume('init');

        // Audio unlock on first interaction (required for mobile autoplay policies)
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            syncAuxScPlayback('unlock');
        }
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        audioPlayer.addEventListener('play', () => syncAuxScPlayback('main-play'));
        audioPlayer.addEventListener('pause', () => syncAuxScPlayback('main-pause'));
        audioPlayer.addEventListener('ended', () => syncAuxScPlayback('main-ended'));

        console.log('[Audio] Created SCAudioAdapters for main/ambient/footsteps');

        // Berechne die Anzahl sichtbarer Zeilen basierend auf BildschirmhÃ¶he
        function getMaxVisibleLines() {
            if (!isReadingMode) return 3;
            const lineHeight = 28; // UngefÃ¤hre ZeilenhÃ¶he in px
            const availableHeight = window.innerHeight * 0.6; // 60% der BildschirmhÃ¶he
            return Math.min(15, Math.max(5, Math.floor(availableHeight / lineHeight)));
        }

        // Custom Smooth Scroll with Variable Duration (1s-3s based on distance)
        // No jumping - always smooth glide
        let currentScrollAnimation = null;
        function smoothScrollToElement(container, targetEl) {
            if (!container || !targetEl) return;
            if (container === subtitleContainer && isBlaetternLayoutActive()) return;

            // Cancel any existing animation
            if (currentScrollAnimation) {
                cancelAnimationFrame(currentScrollAnimation);
                currentScrollAnimation = null;
            }

            const startY = container.scrollTop;

            // Calculate target position from live rects so inline reading-mode timestamps center correctly.
            const containerRect = container.getBoundingClientRect();
            const clientRects = targetEl.getClientRects();
            const anchorRect = clientRects.length > 0 ? clientRects[0] : targetEl.getBoundingClientRect();
            const relativeTop = (anchorRect.top - containerRect.top) + container.scrollTop;
            const targetHeight = Math.max(anchorRect.height || 0, targetEl.clientHeight || 0, 1);
            const targetY = relativeTop - (container.clientHeight / 2) + (targetHeight / 2);

            const distance = Math.abs(targetY - startY);

            // Skip if already very close (within 5px)
            if (distance < 5) return;

            // Dynamic Duration: 1s (near) to 3s (far)
            // "Near" = within 200px, "Far" = 1000px+
            let duration = 1000; // Base 1s
            if (distance > 200) {
                // Scale from 1s to 3s between 200px and 1000px
                const extraDist = Math.min(800, distance - 200);
                duration = 1000 + (extraDist / 800) * 2000;
            }
            duration = Math.min(3000, duration); // Cap at 3s

            console.log(`[SmoothScroll] Dist=${distance.toFixed(0)}px -> Duration=${duration.toFixed(0)}ms`);

            const startTime = performance.now();

            // Easing function for smooth deceleration
            const easeOutQuad = (t) => t * (2 - t);

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                if (elapsed >= duration) {
                    container.scrollTop = targetY; // Snap to final
                    currentScrollAnimation = null;
                    return;
                }

                const progress = elapsed / duration;
                const eased = easeOutQuad(progress);

                container.scrollTop = startY + (targetY - startY) * eased;

                currentScrollAnimation = requestAnimationFrame(animate);
            };

            currentScrollAnimation = requestAnimationFrame(animate);
        }

        function updateRecenterButtonVisibility(reason = 'unspecified') {
            if (!subtitleRecenterBtn) return;
            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            syncRecenterButtonMount(isMobileLayout);

            const show = isReadingMode && subtitleFollowLocked;
            if (!show) {
                subtitleRecenterBtn.style.setProperty('display', 'none', 'important');
                subtitleRecenterBtn.setAttribute('aria-hidden', 'true');
                if (subtitleRecenterMobileRadius) {
                    subtitleRecenterMobileRadius.style.display = 'none';
                }
                return;
            }

            subtitleRecenterBtn.style.setProperty('display', 'inline-flex', 'important');
            subtitleRecenterBtn.setAttribute('aria-hidden', 'false');
            requestAnimationFrame(() => positionRecenterButton(`visibility-show:${reason}`));
        }

        function setSubtitleFollowLocked(nextLocked, reason = 'unspecified') {
            const normalized = !!nextLocked;
            subtitleFollowLocked = normalized;
            if (!subtitleFollowLocked && isBlaetternLayoutActive()) {
                blaetternLastSyncedSubtitleIndex = -1;
            }
            updateRecenterButtonVisibility(reason);
        }

        function syncRecenterButtonMount(isMobileLayout = window.matchMedia('(max-width: 768px)').matches) {
            if (!subtitleRecenterBtn) return;

            if (isBlaetternLayoutActive()) {
                if (subtitleRecenterBtn.parentElement !== document.body) {
                    document.body.appendChild(subtitleRecenterBtn);
                }
                subtitleRecenterBtn.style.position = 'fixed';
                return;
            }

            if (isMobileLayout) {
                if (subtitleRecenterBtn.parentElement !== document.body) {
                    // Mobile uses a viewport-fixed overlay placement.
                    document.body.appendChild(subtitleRecenterBtn);
                }
                subtitleRecenterBtn.style.position = 'fixed';
                return;
            }

            const desktopHost = audioControlsEl || document.getElementById('audioControls');
            if (desktopHost) {
                if (subtitleRecenterBtn.parentElement !== desktopHost) {
                    // Desktop: use the same flex layout flow as the other control icons.
                    desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                } else if (desktopHost.firstElementChild !== subtitleRecenterBtn) {
                    desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                }
            }
            subtitleRecenterBtn.style.position = 'static';
            subtitleRecenterBtn.style.left = '';
            subtitleRecenterBtn.style.top = '';
        }

        function isMobileRecenterZoneActive() {
            if (!subtitleRecenterBtn || !subtitleRecenterMobileRadius) return false;
            if (!window.matchMedia('(max-width: 768px)').matches) return false;
            const btnStyle = window.getComputedStyle(subtitleRecenterBtn);
            return btnStyle.display !== 'none' && isReadingMode && subtitleFollowLocked;
        }

        function updateMobileRecenterRadius(left, top, width, height) {
            if (!subtitleRecenterMobileRadius) return;
            if (!isMobileRecenterZoneActive()) {
                subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            const diameter = RECENTER_MOBILE_RADIUS_PX * 2;
            const centerX = left + (width * 0.5);
            const centerY = top + (height * 0.5);
            subtitleRecenterMobileRadius.style.width = `${diameter}px`;
            subtitleRecenterMobileRadius.style.height = `${diameter}px`;
            subtitleRecenterMobileRadius.style.left = `${centerX - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.top = `${centerY - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.display = 'block';
        }

        function eventPointInMobileRecenterZone(e) {
            if (!isMobileRecenterZoneActive()) return false;
            if (!e) return false;

            const point = Number.isFinite(e.clientX) && Number.isFinite(e.clientY)
                ? { x: e.clientX, y: e.clientY }
                : (e.changedTouches && e.changedTouches.length > 0
                    ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }
                    : (e.touches && e.touches.length > 0
                        ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
                        : null));
            if (!point) return false;

            const rect = subtitleRecenterBtn.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) return false;
            const centerX = rect.left + (rect.width * 0.5);
            const centerY = rect.top + (rect.height * 0.5);
            const dx = point.x - centerX;
            const dy = point.y - centerY;
            return (dx * dx + dy * dy) <= (RECENTER_MOBILE_RADIUS_PX * RECENTER_MOBILE_RADIUS_PX);
        }

        function positionRecenterButton(reason = 'unspecified') {
            if (!subtitleRecenterBtn || subtitleRecenterBtn.style.display === 'none') return;

            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            syncRecenterButtonMount(isMobileLayout);
            const btnRect = subtitleRecenterBtn.getBoundingClientRect();
            const gap = 10;
            const isBlaetternLayout = isBlaetternLayoutActive();

            if (isBlaetternLayout) {
                const subtitleRect = subtitleContainer.getBoundingClientRect();
                const controlsRef = audioControlsEl || document.getElementById('audioControls');
                const controlsRect = controlsRef ? controlsRef.getBoundingClientRect() : null;
                let left = subtitleRect.left + (subtitleRect.width - btnRect.width) * 0.5;
                let top = subtitleRect.bottom - btnRect.height - gap;

                if (controlsRect && controlsRect.top > 0) {
                    top = Math.min(top, controlsRect.top - btnRect.height - gap);
                }

                left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
                top = Math.max(subtitleRect.top + 6, Math.min(window.innerHeight - btnRect.height - 6, top));
                subtitleRecenterBtn.style.left = `${left}px`;
                subtitleRecenterBtn.style.top = `${top}px`;
                if (isMobileLayout) updateMobileRecenterRadius(left, top, btnRect.width, btnRect.height);
                else if (subtitleRecenterMobileRadius) subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            if (!isMobileLayout) {
                if (subtitleRecenterMobileRadius) subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            const anchorRect = fullscreenBtn ? fullscreenBtn.getBoundingClientRect() : null;
            if (!anchorRect) return;

            const rawLeft = anchorRect.left + (anchorRect.width - btnRect.width) * 0.5;
            let rawTop = anchorRect.top - btnRect.height - gap;

            if (isMobileLayout) {
                const subtitleRect = subtitleContainer.getBoundingClientRect();
                const targetCenterY = subtitleRect.top + subtitleRect.height * 0.5;
                rawTop = targetCenterY - btnRect.height * 0.5;
            }

            let left = rawLeft;
            let top = rawTop;
            left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
            top = Math.max(6, Math.min(window.innerHeight - btnRect.height - 6, top));

            subtitleRecenterBtn.style.left = `${left}px`;
            subtitleRecenterBtn.style.top = `${top}px`;
            updateMobileRecenterRadius(left, top, btnRect.width, btnRect.height);
        }

        function recenterToCurrentTimestamp() {
            if (!subtitleTracks || subtitleTracks.length === 0) {
                setSubtitleFollowLocked(false, 'recenter-no-tracks');
                return;
            }

            const fallbackIndex = findSubtitleIndexForTime(audioPlayer.currentTime || 0);
            const safeIndex = Math.max(
                0,
                Math.min(
                    subtitleTracks.length - 1,
                    Number.isFinite(currentSubtitleIndex) && currentSubtitleIndex >= 0 ? currentSubtitleIndex : fallbackIndex
                )
            );

            setSubtitleFollowLocked(false, 'recenter');
            suppressFollowLockUntil = Date.now() + 450;
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false';
            currentSubtitleIndex = safeIndex;
            if (isBlaetternLayoutActive()) blaetternLastSyncedSubtitleIndex = -1;
            renderSubtitleLines(safeIndex);

            if (isBlaetternLayoutActive()) {
                bumpBlaetternControlsAutoHide('blaettern-recenter');
                return;
            }

            const activeEl = subtitleContainer.children[safeIndex];
            if (activeEl) {
                smoothScrollToElement(subtitleContainer, activeEl);
            }
        }

        let lastRecenterActivationAt = 0;
        let suppressSubtitleClickUntil = 0;
        function handleRecenterActivate(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            const now = Date.now();
            if (now - lastRecenterActivationAt < 260) return;
            lastRecenterActivationAt = now;
            // Touch devices may emit a delayed "ghost click" after the recenter tap.
            // Keep subtitle timestamp clicks muted briefly to avoid accidental seeks.
            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            suppressSubtitleClickUntil = isMobileLayout ? now + 600 : now;
            recenterToCurrentTimestamp();
        }

        if (subtitleRecenterBtn) {
            subtitleRecenterBtn.addEventListener('pointerdown', handleRecenterActivate);
            subtitleRecenterBtn.addEventListener('touchstart', handleRecenterActivate, { passive: false });
            subtitleRecenterBtn.addEventListener('click', handleRecenterActivate);
        }

        window.addEventListener('resize', () => {
            positionRecenterButton('resize');
            markBlaetternPaginationDirty();
            if (isBlaetternLayoutActive()) renderSubtitleLines(Math.max(0, currentSubtitleIndex));
        });
        window.addEventListener('orientationchange', () => {
            positionRecenterButton('orientationchange');
            markBlaetternPaginationDirty();
            if (isBlaetternLayoutActive()) renderSubtitleLines(Math.max(0, currentSubtitleIndex));
        });

        const TOP_FADE_BYPASS_COUNT = 2;
        function syncReadingTopFadeMask(activeIndex) {
            if (!subtitleContainer) return;
            const shouldDisableTopFade =
                isReadingMode &&
                Number.isFinite(activeIndex) &&
                activeIndex >= 0 &&
                activeIndex < TOP_FADE_BYPASS_COUNT;
            subtitleContainer.classList.toggle('no-top-fade', shouldDisableTopFade);
        }

        // Generiert die Untertitel-Zeilen dynamisch
        function renderSubtitleLines(centerIndex) {
            // A) Reading Mode: Rendere ALLE Zeilen (fÃ¼r Scrollbar)
            if (isReadingMode) {
                // Version Check: Ensure we are rendering the current set of subtitles
                if (subtitleTracks.length === 0) {
                    syncReadingTopFadeMask(-1);
                    subtitleContainer.innerHTML = '';
                    const emptyLine = document.createElement('div');
                    emptyLine.className = 'subtitle-line subtitle-current';
                    emptyLine.innerText = 'Warte auf Audio/Text...';
                    subtitleContainer.appendChild(emptyLine);
                    return;
                }

                if (readerSentenceLayout === READER_LAYOUT_BLAETTERN) {
                    renderBlaetternReadingPage(centerIndex);
                    return;
                }

                const currentVersion = window.subtitleVersion || 0;
                const renderedVersion = parseInt(subtitleContainer.dataset.version || '-1');

                // Nur neu bauen, wenn Anzahl nicht stimmt ODER Version anders ist
                if (subtitleContainer.children.length !== subtitleTracks.length || renderedVersion !== currentVersion) {
                    subtitleContainer.innerHTML = '';
                    subtitleContainer.dataset.version = currentVersion;

                    subtitleTracks.forEach((track, i) => {
                        const div = document.createElement('div');
                        div.className = 'subtitle-line';
                        div.innerText = track.text;
                        div.dataset.index = i;

                        // Click to Seek
                        div.title = "Klicken zum Springen";
                        div.style.cursor = "pointer";
                        div.addEventListener('click', async (e) => {
                            if (contentSwitchInProgress) {
                                indexTrace('ui:timestamp:blocked', { reason: 'contentSwitchInProgress', index: i, targetTime: track.time });
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            if (eventPointInMobileRecenterZone(e)) {
                                indexTrace('ui:timestamp:blocked', { reason: 'mobileRecenterZone', index: i, targetTime: track.time });
                                handleRecenterActivate(e);
                                return;
                            }
                            if (Date.now() < suppressSubtitleClickUntil) {
                                indexTrace('ui:timestamp:blocked', { reason: 'suppressSubtitleClickUntil', index: i, targetTime: track.time });
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            if (subtitleContainer.dataset.wasDragging === 'true') {
                                console.log("Click ignored due to drag");
                                indexTrace('ui:timestamp:blocked', { reason: 'wasDragging', index: i, targetTime: track.time });
                                return;
                            }
                            // If a bookmark button is visible and was the click target, skip seek
                            if (e.target && typeof e.target.closest === 'function' && e.target.closest('.bookmark-btn')) {
                                indexTrace('ui:timestamp:blocked', { reason: 'bookmark-btn', index: i, targetTime: track.time });
                                return;
                            }
                            setSubtitleFollowLocked(false, 'timestamp-click');
                            console.log(`Seek to ${track.time}s`);
                            indexTrace('ui:timestamp:seek', { index: i, targetTime: track.time });
                            await seekAndSyncSubtitle(track.time, `reading-click:${i}`);
                            try {
                                await audioPlayer.play();
                                indexTrace('ui:timestamp:autoplay-ok', { index: i, targetTime: track.time });
                            } catch (_) {
                                // ignore autoplay gesture restrictions
                                indexTrace('ui:timestamp:autoplay-failed', { index: i, targetTime: track.time });
                            }
                            // Smooth scroll to clicked element
                            smoothScrollToElement(subtitleContainer, div);
                        });

                        // --- BOOKMARK BUTTON (mobile long-press / desktop right-click) ---
                        div.style.position = 'relative';
                        div.style.overflow = 'visible';
                        let _bmTimer = null;
                        let _bmTouchStart = null;
                        let _bmLastTouch = null;
                        let _bmLongPressReady = false;
                        let _bmDocTouchMoveHandler = null;
                        let _bmDocTouchEndHandler = null;
                        let _bmDocTouchCancelHandler = null;
                        const BOOKMARK_MAX_TOUCH_MOVE_PX = 200;
                        const BOOKMARK_LABEL = 'Lesezeichen';
                        const BOOKMARK_SAVED_LABEL = 'Gespeichert';
                        const isDesktopPointer = () => window.matchMedia('(hover: hover) and (pointer: fine)').matches;
                        const clampBookmarkCoord = (value, min, max) => Math.max(min, Math.min(max, value));
                        const rectOverlapArea = (x, y, width, height, rect) => {
                            const overlapW = Math.max(0, Math.min(x + width, rect.right) - Math.max(x, rect.left));
                            const overlapH = Math.max(0, Math.min(y + height, rect.bottom) - Math.max(y, rect.top));
                            return overlapW * overlapH;
                        };
                        const isFlatBookmarkLayout = () =>
                            subtitleContainer.classList.contains('reader-layout-flat')
                            || subtitleContainer.classList.contains('reader-layout-timestamps');
                        const setBookmarkButtonLabel = (btn, label) => {
                            if (!btn) return;
                            const labelNode = btn.querySelector('.bookmark-label');
                            if (labelNode) labelNode.textContent = label;
                            else btn.innerText = label;
                        };
                        const ensureBookmarkButtonMode = (btn, useFlatOverlay) => {
                            if (!btn) return;
                            if (useFlatOverlay) {
                                if (btn.dataset.flatOverlay !== '1') {
                                    btn.dataset.flatOverlay = '1';
                                    btn.innerHTML = '';
                                    const mapLayer = document.createElement('span');
                                    mapLayer.className = 'bookmark-map-layer';
                                    const mapCanvas = document.createElement('canvas');
                                    mapCanvas.className = 'bookmark-map-canvas';
                                    mapCanvas.setAttribute('aria-hidden', 'true');
                                    mapLayer.appendChild(mapCanvas);
                                    const overlayLayer = document.createElement('span');
                                    overlayLayer.className = 'bookmark-overlay-layer';
                                    const labelLayer = document.createElement('span');
                                    labelLayer.className = 'bookmark-label';
                                    labelLayer.textContent = BOOKMARK_LABEL;
                                    btn.appendChild(mapLayer);
                                    btn.appendChild(overlayLayer);
                                    btn.appendChild(labelLayer);
                                }
                                btn.classList.add('bookmark-btn-flat-overlay');
                            } else {
                                if (btn._flatMapRaf) {
                                    cancelAnimationFrame(btn._flatMapRaf);
                                    btn._flatMapRaf = 0;
                                }
                                btn._flatLockedX = null;
                                btn._flatLockedY = null;
                                btn.classList.remove('bookmark-btn-flat-overlay');
                                if (btn.dataset.flatOverlay === '1') {
                                    btn.dataset.flatOverlay = '0';
                                    btn.replaceChildren(document.createTextNode(BOOKMARK_LABEL));
                                }
                            }
                        };
                        const resolveSceneCanvas = () => {
                            const gameCanvas = document.getElementById('gameCanvas');
                            if (gameCanvas instanceof HTMLCanvasElement) return gameCanvas;
                            const anyCanvas = document.querySelector('canvas');
                            return anyCanvas instanceof HTMLCanvasElement ? anyCanvas : null;
                        };
                        const drawFlatBookmarkMapLayer = (btn) => {
                            if (!btn || !btn.classList.contains('bookmark-btn-flat-overlay')) return;
                            const mapLayer = btn.querySelector('.bookmark-map-layer');
                            const mapCanvas = mapLayer ? mapLayer.querySelector('.bookmark-map-canvas') : null;
                            if (!(mapCanvas instanceof HTMLCanvasElement)) return;
                            const drawCtx = mapCanvas.getContext('2d');
                            if (!drawCtx) return;
                            if (!mapLayer) return;
                            const sceneCanvas = resolveSceneCanvas();
                            if (!sceneCanvas || typeof sceneCanvas.getBoundingClientRect !== 'function') {
                                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                                return;
                            }
                            try {
                                const canvasRect = sceneCanvas.getBoundingClientRect();
                                const btnRect = btn.getBoundingClientRect();
                                if (!canvasRect.width || !canvasRect.height || !btnRect.width || !btnRect.height) return;
                                const dpr = Math.max(1, window.devicePixelRatio || 1);
                                const targetW = Math.max(1, Math.round(btnRect.width * dpr));
                                const targetH = Math.max(1, Math.round(btnRect.height * dpr));
                                if (mapCanvas.width !== targetW || mapCanvas.height !== targetH) {
                                    mapCanvas.width = targetW;
                                    mapCanvas.height = targetH;
                                }
                                drawCtx.clearRect(0, 0, targetW, targetH);

                                const overlapLeft = Math.max(btnRect.left, canvasRect.left);
                                const overlapTop = Math.max(btnRect.top, canvasRect.top);
                                const overlapRight = Math.min(btnRect.right, canvasRect.right);
                                const overlapBottom = Math.min(btnRect.bottom, canvasRect.bottom);
                                if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) return;

                                const scaleX = sceneCanvas.width / canvasRect.width;
                                const scaleY = sceneCanvas.height / canvasRect.height;
                                const srcX = (overlapLeft - canvasRect.left) * scaleX;
                                const srcY = (overlapTop - canvasRect.top) * scaleY;
                                const srcW = (overlapRight - overlapLeft) * scaleX;
                                const srcH = (overlapBottom - overlapTop) * scaleY;
                                const dstX = (overlapLeft - btnRect.left) * dpr;
                                const dstY = (overlapTop - btnRect.top) * dpr;
                                const dstW = (overlapRight - overlapLeft) * dpr;
                                const dstH = (overlapBottom - overlapTop) * dpr;
                                drawCtx.drawImage(sceneCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
                            } catch (_) {
                                drawCtx.clearRect(0, 0, mapCanvas.width || 0, mapCanvas.height || 0);
                            }
                        };
                        const stopFlatBookmarkMapLayerLoop = (btn) => {
                            if (!btn || !btn._flatMapRaf) return;
                            cancelAnimationFrame(btn._flatMapRaf);
                            btn._flatMapRaf = 0;
                        };
                        const startFlatBookmarkMapLayerLoop = (btn) => {
                            if (!btn || btn._flatMapRaf) return;
                            const tick = () => {
                                if (!btn.isConnected || !btn.classList.contains('visible') || !btn.classList.contains('bookmark-btn-flat-overlay')) {
                                    btn._flatMapRaf = 0;
                                    return;
                                }
                                drawFlatBookmarkMapLayer(btn);
                                btn._flatMapRaf = requestAnimationFrame(tick);
                            };
                            tick();
                        };
                        const collectLineTextRects = (lineEl, containerRect) => {
                            const rects = [];
                            if (!lineEl) return rects;
                            for (const node of lineEl.childNodes) {
                                if (node.nodeType !== Node.TEXT_NODE) continue;
                                if (!(node.textContent || '').trim()) continue;
                                const range = document.createRange();
                                range.selectNodeContents(node);
                                for (const rect of range.getClientRects()) {
                                    if (rect.width <= 0 || rect.height <= 0) continue;
                                    if (rect.bottom < containerRect.top || rect.top > containerRect.bottom) continue;
                                    rects.push(rect);
                                }
                            }
                            return rects;
                        };
                        const collectSubtitleTextRects = () => {
                            const rects = [];
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            subtitleContainer.querySelectorAll('.subtitle-line').forEach((lineEl) => {
                                rects.push(...collectLineTextRects(lineEl, containerRect));
                            });
                            if (subtitleRecenterBtn && subtitleRecenterBtn.offsetParent !== null) {
                                const recenterRect = subtitleRecenterBtn.getBoundingClientRect();
                                if (recenterRect.width > 0 && recenterRect.height > 0) rects.push(recenterRect);
                            }
                            return { rects, containerRect };
                        };
                        const getPointerPoint = (event) => {
                            if (!event) return null;
                            if (event.touches && event.touches.length > 0) {
                                return { clientX: event.touches[0].clientX, clientY: event.touches[0].clientY };
                            }
                            if (event.changedTouches && event.changedTouches.length > 0) {
                                return { clientX: event.changedTouches[0].clientX, clientY: event.changedTouches[0].clientY };
                            }
                            if (event.clientX !== undefined && event.clientY !== undefined) {
                                return { clientX: event.clientX, clientY: event.clientY };
                            }
                            return null;
                        };
                        const clearLongPressTracking = () => {
                            if (_bmDocTouchMoveHandler) {
                                document.removeEventListener('touchmove', _bmDocTouchMoveHandler);
                                _bmDocTouchMoveHandler = null;
                            }
                            if (_bmDocTouchEndHandler) {
                                document.removeEventListener('touchend', _bmDocTouchEndHandler);
                                _bmDocTouchEndHandler = null;
                            }
                            if (_bmDocTouchCancelHandler) {
                                document.removeEventListener('touchcancel', _bmDocTouchCancelHandler);
                                _bmDocTouchCancelHandler = null;
                            }
                            _bmTouchStart = null;
                            _bmLastTouch = null;
                            _bmLongPressReady = false;
                        };
                        const getLongPressMovement = () => {
                            if (!_bmTouchStart) return { pointerDistance: 0, scrollDistance: 0 };
                            const lastPoint = _bmLastTouch || _bmTouchStart;
                            const dx = lastPoint.clientX - _bmTouchStart.clientX;
                            const dy = lastPoint.clientY - _bmTouchStart.clientY;
                            return {
                                pointerDistance: Math.hypot(dx, dy),
                                scrollDistance: Math.abs(subtitleContainer.scrollTop - _bmTouchStart.scrollTop)
                            };
                        };
                        const isLongPressBlockedByMovement = () => {
                            const movement = getLongPressMovement();
                            return movement.pointerDistance > BOOKMARK_MAX_TOUCH_MOVE_PX
                                || movement.scrollDistance > BOOKMARK_MAX_TOUCH_MOVE_PX;
                        };
                        const cancelLongPress = () => {
                            if (_bmTimer) {
                                clearTimeout(_bmTimer);
                                _bmTimer = null;
                            }
                            clearLongPressTracking();
                        };
                        const finalizeLongPress = () => {
                            if (!_bmTouchStart) {
                                cancelLongPress();
                                return;
                            }
                            const triggerPoint = _bmLastTouch || _bmTouchStart;
                            const shouldShow = _bmLongPressReady && !isLongPressBlockedByMovement();
                            cancelLongPress();
                            if (shouldShow) {
                                showBookmarkButton({ clientX: triggerPoint.clientX, clientY: triggerPoint.clientY });
                            }
                        };
                        const updateLongPressMovement = (event) => {
                            if (!_bmTouchStart) return;
                            const point = getPointerPoint(event);
                            if (!point) return;
                            _bmLastTouch = { clientX: point.clientX, clientY: point.clientY };
                            if (isLongPressBlockedByMovement()) {
                                cancelLongPress();
                            }
                        };
                        const startLongPress = (e) => {
                            if (isDesktopPointer()) return;
                            cancelLongPress();
                            const point = getPointerPoint(e);
                            if (!point) return;
                            _bmTouchStart = {
                                clientX: point.clientX,
                                clientY: point.clientY,
                                scrollTop: subtitleContainer.scrollTop
                            };
                            _bmLastTouch = { clientX: point.clientX, clientY: point.clientY };
                            _bmLongPressReady = false;
                            _bmDocTouchMoveHandler = (event) => updateLongPressMovement(event);
                            _bmDocTouchEndHandler = () => finalizeLongPress();
                            _bmDocTouchCancelHandler = () => cancelLongPress();
                            document.addEventListener('touchmove', _bmDocTouchMoveHandler, { passive: true });
                            document.addEventListener('touchend', _bmDocTouchEndHandler, { passive: true });
                            document.addEventListener('touchcancel', _bmDocTouchCancelHandler, { passive: true });

                            _bmTimer = setTimeout(() => {
                                _bmTimer = null;
                                if (!_bmTouchStart) return;
                                if (isLongPressBlockedByMovement()) {
                                    cancelLongPress();
                                    return;
                                }
                                _bmLongPressReady = true;
                            }, 600);
                        };

                        const positionBookmarkButton = (btn, options = {}) => {
                            const useFlatOverlay = isFlatBookmarkLayout();
                            ensureBookmarkButtonMode(btn, useFlatOverlay);
                            const lineRect = div.getBoundingClientRect();
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            if (!lineRect.width || !lineRect.height || !containerRect.width || !containerRect.height) return;
                            const btnWidth = btn.offsetWidth || 0;
                            const btnHeight = btn.offsetHeight || 0;

                            if (useFlatOverlay) {
                                const lockToExisting = !!options.lockToExisting;
                                if (lockToExisting && Number.isFinite(btn._flatLockedX) && Number.isFinite(btn._flatLockedY)) {
                                    btn.style.left = `${Math.round(btn._flatLockedX)}px`;
                                    btn.style.top = `${Math.round(btn._flatLockedY)}px`;
                                    startFlatBookmarkMapLayerLoop(btn);
                                    drawFlatBookmarkMapLayer(btn);
                                    return;
                                }
                                const lineTextRects = collectLineTextRects(div, containerRect);
                                const anchorRect = lineTextRects.length > 0 ? lineTextRects[0] : lineRect;
                                const edgeMargin = 6;
                                const x = clampBookmarkCoord(anchorRect.left, edgeMargin, Math.max(edgeMargin, window.innerWidth - btnWidth - edgeMargin));
                                const y = clampBookmarkCoord(anchorRect.top - btnHeight - 6, edgeMargin, Math.max(edgeMargin, window.innerHeight - btnHeight - edgeMargin));
                                btn._flatLockedX = Math.round(x);
                                btn._flatLockedY = Math.round(y);
                                btn.style.left = `${btn._flatLockedX}px`;
                                btn.style.top = `${btn._flatLockedY}px`;
                                startFlatBookmarkMapLayerLoop(btn);
                                drawFlatBookmarkMapLayer(btn);
                                return;
                            }

                            stopFlatBookmarkMapLayerLoop(btn);
                            btn._flatLockedX = null;
                            btn._flatLockedY = null;

                            // NEW LOGIC: Based on touch/click point
                            if (options.clientX !== undefined && options.clientY !== undefined && options.clientX !== null && options.clientY !== null) {
                                let x = options.clientX - (btnWidth / 2);
                                let y = options.clientY - 200; // 200px above

                                // Fallback if too close to top (<150px space) or offscreen
                                if (y < 150) {
                                    y = options.clientY + 200; // 200px below
                                }

                                // Prevent horizontal clipping
                                const margin = 8;
                                x = clampBookmarkCoord(x, containerRect.left + margin, containerRect.right - btnWidth - margin);

                                btn.style.left = `${Math.round(x - lineRect.left)}px`;
                                btn.style.top = `${Math.round(y - lineRect.top)}px`;
                                return;
                            }

                            // Fallback if no coordinates available (e.g. keyboard triggers or contextmenu)
                            const { rects: textRects } = collectSubtitleTextRects();
                            const margin = 8;
                            const minX = containerRect.left + margin;
                            const maxX = Math.max(minX, containerRect.right - btnWidth - margin);
                            const minY = containerRect.top + margin;
                            const maxY = Math.max(minY, containerRect.bottom - btnHeight - margin);
                            const lineTextRects = collectLineTextRects(div, containerRect);
                            const anchorRect = lineTextRects.length > 0 ? lineTextRects[lineTextRects.length - 1] : lineRect;
                            const fallbackY = clampBookmarkCoord(
                                anchorRect.top + ((anchorRect.height - btnHeight) / 2),
                                minY,
                                maxY
                            );
                            const xCandidates = [
                                clampBookmarkCoord(anchorRect.right + margin, minX, maxX),
                                clampBookmarkCoord(anchorRect.right - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(anchorRect.left - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(containerRect.right - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(containerRect.left + margin, minX, maxX)
                            ];
                            const yCandidates = [
                                fallbackY,
                                clampBookmarkCoord(anchorRect.top - btnHeight - margin, minY, maxY),
                                clampBookmarkCoord(anchorRect.bottom + margin, minY, maxY),
                                clampBookmarkCoord(lineRect.top + ((lineRect.height - btnHeight) / 2), minY, maxY)
                            ];

                            let best = { score: Number.POSITIVE_INFINITY, x: xCandidates[0], y: yCandidates[0] };
                            for (const y of yCandidates) {
                                for (const x of xCandidates) {
                                    let overlapScore = 0;
                                    for (const rect of textRects) {
                                        overlapScore += rectOverlapArea(x, y, btnWidth, btnHeight, rect);
                                    }
                                    const centerPenalty = Math.abs((y + (btnHeight / 2)) - (anchorRect.top + (anchorRect.height / 2))) * 0.08;
                                    const idealCenterX = clampBookmarkCoord(
                                        anchorRect.right + margin + (btnWidth / 2),
                                        minX + (btnWidth / 2),
                                        maxX + (btnWidth / 2)
                                    );
                                    const sidePenalty = Math.abs((x + (btnWidth / 2)) - idealCenterX) * 0.03;
                                    const score = overlapScore + centerPenalty + sidePenalty;
                                    if (score < best.score) best = { score, x, y };
                                }
                            }

                            btn.style.left = `${Math.round(best.x - lineRect.left)}px`;
                            btn.style.top = `${Math.round(best.y - lineRect.top)}px`;
                        };

                        const showBookmarkButton = (options = {}) => {
                            let btn = div.querySelector('.bookmark-btn');
                            if (!btn) {
                                btn = document.createElement('button');
                                btn.className = 'bookmark-btn';
                                setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                btn.addEventListener('click', async (ev) => {
                                    ev.stopPropagation();
                                    ev.preventDefault();
                                    btn.classList.remove('pop');
                                    void btn.offsetWidth;
                                    btn.classList.add('pop');
                                    setTimeout(() => btn.classList.remove('pop'), 220);
                                    const loreId = (isLoreMode && Number.isFinite(activeLoreId)) ? Number(activeLoreId) : null;
                                    const loreMeta = loreId && window.GameState && typeof window.GameState.getLore === 'function'
                                        ? window.GameState.getLore(loreId)
                                        : null;
                                    const bookmarkContentKey = loreId ? `lore${loreId}` : MAIN_CONTENT_KEY;
                                    const bookmarkChapter = loreId ? `lore${loreId}` : CURRENT_CHAPTER;
                                    const bookmarkChapterTitle = loreId
                                        ? (loreMeta && loreMeta.title ? `Lore ${loreId}: ${loreMeta.title}` : `Lore ${loreId}`)
                                        : CURRENT_CHAPTER_TITLE;
                                    const bookmarkAudioRef = loreId
                                        ? ((loreMeta && loreMeta.audio) || loreData.audio[loreId] || `assets/lore${loreId}.mp3`)
                                        : LEVEL.audioUrl;
                                    const bookmarkTextRef = loreId
                                        ? ((loreMeta && loreMeta.text) || `assets/lore${loreId}.txt`)
                                        : LEVEL.subtitleFile;
                                    const bm = {
                                        id: Date.now(),
                                        chapter: bookmarkChapter,
                                        chapterTitle: bookmarkChapterTitle,
                                        page: CURRENT_PAGE,
                                        time: track.time,
                                        textPreview: (track.text || '').substring(0, 60),
                                        contentKey: bookmarkContentKey,
                                        loreId: loreId,
                                        audioRef: bookmarkAudioRef,
                                        textRef: bookmarkTextRef,
                                        createdAt: Date.now()
                                    };
                                    const added = await window.GameState.addBookmark(bm);
                                    if (added) {
                                        btn.classList.add('saved');
                                        setBookmarkButtonLabel(btn, BOOKMARK_SAVED_LABEL);

                                        // Store locked coordinates based on current actual position
                                        const currentLeft = parseFloat(btn.style.left) || 0;
                                        const currentTop = parseFloat(btn.style.top) || 0;
                                        const lineRect = div.getBoundingClientRect();

                                        // If useFlatOverlay is active lockToExisting uses these:
                                        btn._flatLockedX = currentLeft + lineRect.left;
                                        btn._flatLockedY = currentTop + lineRect.top;

                                        positionBookmarkButton(btn, { lockToExisting: true });
                                        setTimeout(() => {
                                            btn.classList.remove('visible', 'saved');
                                            stopFlatBookmarkMapLayerLoop(btn);
                                            ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                                            setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                            btn._flatLockedX = null;
                                            btn._flatLockedY = null;
                                        }, 1200);
                                    } else {
                                        stopFlatBookmarkMapLayerLoop(btn);
                                        btn.classList.remove('visible');
                                    }
                                });
                                div.appendChild(btn);
                            }
                            ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                            if (!btn.classList.contains('saved')) setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                            subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((otherBtn) => {
                                if (otherBtn !== btn) {
                                    otherBtn.classList.remove('visible');
                                    stopFlatBookmarkMapLayerLoop(otherBtn);
                                    otherBtn._flatLockedX = null;
                                    otherBtn._flatLockedY = null;
                                }
                            });
                            btn.classList.add('visible');
                            positionBookmarkButton(btn, { lockToExisting: false, clientX: options.clientX, clientY: options.clientY });
                            // Auto-hide after 4 seconds
                            setTimeout(() => {
                                if (!btn.classList.contains('saved')) {
                                    btn.classList.remove('visible');
                                    stopFlatBookmarkMapLayerLoop(btn);
                                    btn._flatLockedX = null;
                                    btn._flatLockedY = null;
                                }
                            }, 4000);
                        };

                        div.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            startLongPress(e);
                        });
                        div.addEventListener('contextmenu', (e) => {
                            if (!isDesktopPointer()) return;
                            e.preventDefault();
                            e.stopPropagation();
                            cancelLongPress();
                            showBookmarkButton({ clientX: e.clientX, clientY: e.clientY });
                        });
                        div.addEventListener('touchstart', startLongPress, { passive: true });
                        div.addEventListener('mouseup', cancelLongPress);
                        div.addEventListener('mouseleave', cancelLongPress);
                        div.addEventListener('touchend', finalizeLongPress);
                        div.addEventListener('touchcancel', cancelLongPress);

                        subtitleContainer.appendChild(div);
                        applyFlatLeadingCompensation(div, track.text);
                    });
                }

                // Highlighting aktualisieren
                const oldActive = subtitleContainer.querySelector('.subtitle-current');
                if (oldActive) oldActive.classList.remove('subtitle-current');

                // Ensure centerIndex is valid
                const normalizedIndex = Number.isFinite(centerIndex) ? centerIndex : 0;
                const safeIndex = Math.max(0, Math.min(subtitleTracks.length - 1, normalizedIndex));
                syncReadingTopFadeMask(safeIndex);

                if (subtitleContainer.children.length > safeIndex) {
                    const activeEl = subtitleContainer.children[safeIndex];
                    activeEl.classList.add('subtitle-current');

                    // Auto-Scroll only if user is NOT actively dragging AND audio is playing
                    // Uses custom smooth scroll with variable duration (1-3s)
                    const isPlaying = !audioPlayer.paused;
                    if (subtitleContainer.dataset.isDragging !== 'true' && !subtitleFollowLocked && isPlaying) {
                        smoothScrollToElement(subtitleContainer, activeEl);
                    }
                }
                return;
            }

            // B) Game Mode: Nur kleines Fenster rendern (3 Zeilen)
            syncReadingTopFadeMask(-1);
            subtitleContainer.innerHTML = '';

            if (subtitleTracks.length === 0) {
                const div = document.createElement('div');
                div.className = 'subtitle-line subtitle-current';
                div.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(div);
                return;
            }

            // Fixe 3 Zeilen im Spielmodus
            const startIdx = Math.max(0, centerIndex - 1);
            const endIdx = Math.min(subtitleTracks.length - 1, centerIndex + 1);

            for (let i = startIdx; i <= endIdx; i++) {
                const div = document.createElement('div');
                div.className = 'subtitle-line';

                const distance = Math.abs(i - centerIndex);

                if (i === centerIndex) {
                    div.classList.add('subtitle-current');
                } else {
                    // Verblassen
                    if (distance >= 5) div.classList.add('fade-far');
                    else if (distance >= 3) div.classList.add('fade-mid');
                }

                div.innerText = subtitleTracks[i].text;
                subtitleContainer.appendChild(div);
            }
        }



        // 2. Parser fÃ¼r Timestamps - CORRECTLY distinguishes between formats:
        // [hh:mm:ss] - Colon before third part means SECONDS (kapitel1.txt uses [00:mm:ss])
        // [mm:ss.xx] - Dot before third part means CENTISECONDS (lore format)
        function parseSubtitles(rawText) {
            subtitleTracks = [];
            currentSubtitleIndex = -1;
            const lines = rawText.split('\n');

            // Capture the separator character to distinguish formats:
            // Group 1: first number
            // Group 2: second number  
            // Group 3: separator (: or .) - captured separately!
            // Group 4: third number if exists
            // Group 5: text
            const timeReg = /^\[(\d{1,2}):(\d{2})([:.])(\d{1,2}(?:\.\d+)?)\]\s*(.*)|\[(\d{1,2}):(\d{2})\]\s*(.*)/;

            let matchCount = 0;
            lines.forEach((line, idx) => {
                const match = line.match(timeReg);
                if (match) {
                    matchCount++;
                    let totalSeconds;
                    let text;

                    if (match[1] !== undefined) {
                        // Three-part format: [xx:xx:xx] or [xx:xx.xx]
                        const first = parseFloat(match[1]);
                        const second = parseFloat(match[2]);
                        const separator = match[3]; // ':' or '.'
                        const third = parseFloat(match[4]);
                        text = match[5] ? match[5].trim() : '';

                        if (separator === ':') {
                            // [hh:mm:ss] format - third part is SECONDS
                            totalSeconds = first * 3600 + second * 60 + third;
                        } else {
                            // [mm:ss.xx] format - third part is CENTISECONDS
                            totalSeconds = first * 60 + second + (third / 100);
                        }
                    } else {
                        // Two-part format: [mm:ss]
                        const first = parseFloat(match[6]);
                        const second = parseFloat(match[7]);
                        text = match[8] ? match[8].trim() : '';
                        totalSeconds = first * 60 + second;
                    }

                    if (text && text.length > 0) {
                        subtitleTracks.push({
                            time: totalSeconds,
                            text: text
                        });
                    }
                }
            });

            console.log(`[DEBUG] parseSubtitles: ${matchCount} matches from ${lines.length} lines, ${subtitleTracks.length} tracks with text`);
            if (subtitleTracks.length > 0) {
                console.log(`[DEBUG] First subtitle at ${subtitleTracks[0].time}s: "${subtitleTracks[0].text.substring(0, 40)}..."`);
                if (subtitleTracks.length > 1) {
                    console.log(`[DEBUG] Second subtitle at ${subtitleTracks[1].time}s: "${subtitleTracks[1].text.substring(0, 30)}..."`);
                }
            }

            subtitleTracks.sort((a, b) => a.time - b.time);
            setSubtitleFollowLocked(false, 'parse-subtitles');
            markBlaetternPaginationDirty();

            // Increment version to force re-render in Reading Mode
            window.subtitleVersion = (window.subtitleVersion || 0) + 1;
        }

        // 3. Update-Funktion fÃ¼r Anzeige
        function updateSubtitleDisplay(index) {
            if (index === currentSubtitleIndex) return;
            currentSubtitleIndex = index;
            renderSubtitleLines(Math.max(0, index));
        }

        // 4. Synchronisation (lÃ¤uft bei jedem Audio-Update)
        audioPlayer.addEventListener('timeupdate', () => {
            const t = audioPlayer.currentTime;

            let newIndex = -1;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (t >= subtitleTracks[i].time) {
                    newIndex = i;
                    break;
                }
            }

            updateSubtitleDisplay(newIndex);
        });

        // 4b. Chapter Transition Logic (Main Audio Ended)
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode) {
                indexTrace('audio:ended:lore', { activeLoreId: activeLoreId || null });
                if (window.restoreMainAudio) {
                    window.restoreMainAudio({ saveCurrent: false, forceResume: true });
                }
                return;
            } else {
                // MAIN CHAPTER FINISHED
                console.log("Chapter 1 Finished. ReadingMode:", isReadingMode);

                // BUGFIX: Prevent transition if Text is not finished!
                // Only if we are in Reading Mode (where text matters).
                // Or generally? User said "Cut off bug".

                let textFinished = true;
                if (subtitleTracks.length > 0) {
                    // If we are significantly behind? use small buffer (e.g. within last 3 lines)
                    if (currentSubtitleIndex < subtitleTracks.length - 1) {
                        textFinished = false;
                    }
                }

                // Debug Decision
                console.log(`[DEBUG_SYS] Audio Ended. SubtitleIndex=${currentSubtitleIndex}/${subtitleTracks.length}. TextFinished=${textFinished}`);
                indexDebugNote('audio-ended', `idx=${currentSubtitleIndex}/${subtitleTracks.length} textFinished=${textFinished} reading=${isReadingMode}`);
                indexTrace('audio:ended:main', {
                    subtitleIndex: currentSubtitleIndex,
                    subtitleCount: subtitleTracks.length,
                    textFinished: !!textFinished,
                    readingMode: !!isReadingMode
                });
                const shouldClearMainState = !isReadingMode || textFinished;
                if (shouldClearMainState) {
                    clearContentState(MAIN_CONTENT_KEY);
                }

                if (isReadingMode) {
                    if (textFinished) {
                        transitionToNextChapter();
                    } else {
                        console.log("[DEBUG_SYS] Audio ended but text incomplete. Pausing audio, keeping Reading Mode open.");
                        // Stop audio but do not transition. 
                        // User can read remaining text, then manual action needed? 
                        // Or maybe we don't need to do anything, just let it stop.
                        audioPlayer.pause();
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else if (LEVEL.nextChapterTarget) {
                    // Game Mode: Show Button (nur wenn Folgekapitel vorhanden)
                    const btn = document.getElementById('nextChapterBtn');
                    if (btn) btn.classList.add('visible');

                    // UI Polish: switch to Pause icon? No, audio ended means it stopped.
                    // Just ensure logic state.
                }
            }
        });

        // PINCH-TO-ZOOM REMOVED per user request (caused jitter issues)


        window.transitionToNextChapter = async function () {
            const overlay = document.getElementById('transitionOverlay');
            if (overlay) overlay.classList.add('active');

            const nextTarget = LEVEL.nextChapterTarget;
            if (!nextTarget) return; // Kein Folgekapitel fÃ¼r dieses Level

            await waitForContentSwitchIdle('transition:next-chapter');
            await saveCurrentContentState({ reason: 'transition:next-chapter' });
            indexDebugNote('transition', `to ${nextTarget}`);
            markChapterAutoplayIntent('liminal_library', 'auto', 'chapter-transition');
            writeStateHandoff('liminal_library');

            // Fade out any remaining audio
            fadeAudio(audioPlayer, 0, 1500);

            setTimeout(() => {
                window.location.href = nextTarget;
            }, 2000); // 2s Fade Time
        };

        const nextChapterBtn = document.getElementById('nextChapterBtn');
        if (nextChapterBtn) {
            nextChapterBtn.addEventListener('click', () => {
                nextChapterBtn.classList.remove('visible');
                transitionToNextChapter();
            });
        }


        // 11. Custom Drag-to-Scroll Logic for Subtitle Container (with Momentum)
        let isDown = false;
        let startY;
        let scrollTop;
        let lastMoveY = 0;
        let lastMoveTime = 0;
        let swipeVelocity = 0;
        let momentumAnimId = null;

        function cancelMomentum() {
            if (momentumAnimId) {
                cancelAnimationFrame(momentumAnimId);
                momentumAnimId = null;
            }
        }

        const handleDown = (e) => {
            if (isBlaetternLayoutActive()) return;
            cancelMomentum();
            isDown = true;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false'; // Reset for next click check
            const pageY = e.pageY || e.touches[0].pageY;
            startY = pageY - subtitleContainer.offsetTop;
            scrollTop = subtitleContainer.scrollTop;
            lastMoveY = pageY;
            lastMoveTime = performance.now();
            swipeVelocity = 0;
            // Optional: Cursor style
            subtitleContainer.style.cursor = 'grabbing';
        };

        const handleMove = (e) => {
            if (isBlaetternLayoutActive()) return;
            if (!isDown) return;
            e.preventDefault(); // Prevent text selection
            const pageY = e.pageY || e.touches[0].pageY;
            const y = pageY - subtitleContainer.offsetTop;
            const walk = (y - startY) * 1.0; // Scroll speed

            // Track velocity for momentum
            const now = performance.now();
            const elapsed = now - lastMoveTime;
            if (elapsed > 0) {
                // velocity in px/ms, smoothed
                const instantVelocity = (pageY - lastMoveY) / elapsed;
                swipeVelocity = swipeVelocity * 0.6 + instantVelocity * 0.4;
            }
            lastMoveY = pageY;
            lastMoveTime = now;

            // Threshold check
            if (Math.abs(walk) > 5) {
                subtitleContainer.dataset.isDragging = 'true';
                subtitleContainer.dataset.wasDragging = 'true';
                if (isReadingMode && Date.now() >= suppressFollowLockUntil) {
                    setSubtitleFollowLocked(true, 'drag-threshold');
                }
                subtitleContainer.scrollTop = scrollTop - walk;
            }
        };

        const handleUp = () => {
            if (isBlaetternLayoutActive()) return;
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.style.cursor = 'auto';

            // Start momentum animation if velocity is significant
            const velocityPxPerMs = swipeVelocity;
            let velocityPxPerSec = -velocityPxPerMs * 1000 * 1.2; // Negate + moderate amplify
            const MAX_VELOCITY = 5000;
            const MIN_VELOCITY = 15;
            velocityPxPerSec = Math.max(-MAX_VELOCITY, Math.min(MAX_VELOCITY, velocityPxPerSec));

            if (Math.abs(velocityPxPerSec) > MIN_VELOCITY) {
                let lastFrame = performance.now();
                const animateMomentum = (now) => {
                    const dt = (now - lastFrame) / 1000;
                    lastFrame = now;

                    // Apply velocity
                    subtitleContainer.scrollTop += velocityPxPerSec * dt;

                    // Decay â€” 0.96 is much gentler than 0.92, so hard swipes coast far
                    velocityPxPerSec *= Math.pow(0.96, dt * 60);

                    // Stop when effectively still
                    if (Math.abs(velocityPxPerSec) < 0.5) {
                        momentumAnimId = null;
                        return;
                    }

                    momentumAnimId = requestAnimationFrame(animateMomentum);
                };
                momentumAnimId = requestAnimationFrame(animateMomentum);
            }
        };

        subtitleContainer.addEventListener('mousedown', handleDown);
        subtitleContainer.addEventListener('touchstart', handleDown, { passive: true });

        subtitleContainer.addEventListener('mouseleave', handleUp);
        subtitleContainer.addEventListener('mouseup', handleUp);
        subtitleContainer.addEventListener('touchend', handleUp);

        subtitleContainer.addEventListener('mousemove', handleMove);
        subtitleContainer.addEventListener('touchmove', handleMove, { passive: false });

        subtitleContainer.addEventListener('pointerdown', onBlaetternPointerDown);
        subtitleContainer.addEventListener('pointermove', onBlaetternPointerMove);
        subtitleContainer.addEventListener('pointerup', onBlaetternPointerEnd);
        subtitleContainer.addEventListener('pointercancel', onBlaetternPointerEnd);

        // 10. Scrollbar Auto-Hide Logic
        let scrollTimeout;
        subtitleContainer.addEventListener('scroll', () => {
            subtitleContainer.classList.add('is-scrolling');
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                subtitleContainer.classList.remove('is-scrolling');
            }, 1000); // 1 Sekunde nach Scroll-Ende ausblenden
        });

        // 5. Play/Pause Steuerung
        playBtn.addEventListener('click', () => {
            if (contentSwitchInProgress) {
                indexTrace('ui:play-toggle:blocked', { reason: 'contentSwitchInProgress' });
                return;
            }
            const transportPaused = isAudioTransportPaused();
            console.log("Play Button Clicked. Current Src:", audioPlayer.src, "Paused:", audioPlayer.paused);
            indexTrace('ui:play-toggle:click', {
                src: audioPlayer.src,
                paused: audioPlayer.paused,
                transportPaused,
                iconPlay: iconPlay.style.display,
                iconPause: iconPause.style.display
            });
            if (transportPaused) {
                audioPlayer.play()
                    .then(() => syncPlayPauseIcon())
                    .catch(e => {
                        console.error("Play verification failed:", e);
                        syncPlayPauseIcon();
                    });
            } else {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        });

        // 6. Skip Buttons (Â±15 Sekunden)
        async function skipBySecondsGlobal(deltaSec, reason = 'skip') {
            if (contentSwitchInProgress) return;
            const delta = Number(deltaSec) || 0;
            if (!delta) return;

            const wasPausedBeforeSkip = !!audioPlayer.paused;
            let before = Number(audioPlayer.currentTime);
            if (!Number.isFinite(before) || before < 0) before = 0;
            if (!wasPausedBeforeSkip && typeof audioPlayer.getAccurateCurrentTime === 'function') {
                const measuredBefore = await audioPlayer.getAccurateCurrentTime(900);
                if (Number.isFinite(measuredBefore) && measuredBefore >= 0) before = measuredBefore;
            }

            const target = Math.max(0, before + delta);
            await seekAndSyncSubtitle(target, `${reason}:${delta > 0 ? 'forward' : 'back'}`);

            if (wasPausedBeforeSkip) {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        }

        skipBackBtn.addEventListener('click', () => {
            skipBySecondsGlobal(-15, 'btn-skip').catch((e) => {
                console.warn('[Skip] Back failed:', e);
            });
        });

        skipForwardBtn.addEventListener('click', () => {
            skipBySecondsGlobal(15, 'btn-skip').catch((e) => {
                console.warn('[Skip] Forward failed:', e);
            });
        });

        if (audioControlsEl) {
            audioControlsEl.addEventListener('pointerdown', () => {
                if (isBlaetternLayoutActive()) bumpBlaetternControlsAutoHide('controls-pointerdown');
            });
            audioControlsEl.addEventListener('click', () => {
                if (isBlaetternLayoutActive()) bumpBlaetternControlsAutoHide('controls-click');
            });
        }

        // 7. Modus-Wechsel mit robuster Animation
        let modeSwitchUiTimer = null;
        let modeSwitchLockUntil = 0;

        function syncModeToggleButton() {
            if (!modeToggleBtn) return;
            const nextModeLabel = isReadingMode ? 'Spielmodus aktivieren' : 'Lesemodus aktivieren';
            modeToggleBtn.title = nextModeLabel;
            modeToggleBtn.setAttribute('aria-label', nextModeLabel);
        }

        function setReadingMode(nextMode, reason = 'manual') {
            let normalized = !!nextMode;
            if (!normalized && globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                normalized = true;
            }
            const now = performance.now();

            if (now < modeSwitchLockUntil && normalized === isReadingMode) return;
            modeSwitchLockUntil = now + 120;

            isReadingMode = normalized;
            localStorage.setItem('gameboy_reading_mode', normalized ? 'true' : 'false');

            if (normalized) {
                syncAutoWalkToIndex();
                uiContainer.classList.add('reading-mode');
            } else {
                setSubtitleFollowLocked(false, 'mode-off');
                if (isLoreMode && !isMenuTriggeredLore) {
                    endLoreMode();
                }
                uiContainer.classList.remove('reading-mode');
            }
            markBlaetternPaginationDirty();
            syncBlaetternUiState(`mode-switch:${reason}`);

            syncModeToggleButton();
            moveTarget = null;
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));

            uiContainer.classList.add('mode-switching');
            if (modeSwitchUiTimer) clearTimeout(modeSwitchUiTimer);
            modeSwitchUiTimer = setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);

            indexDebugNote(
                'mode-switch',
                `${reason} reading=${isReadingMode} tracks=${subtitleTracks.length} switching=${contentSwitchInProgress}`
            );
            applySceneAudioMix(`mode-switch:${reason}`);
            updateRecenterButtonVisibility();
        }

        syncModeToggleButton();
        modeSwitchInitialized = true;
        if (pendingForceReadingFromFreeze) {
            setReadingMode(true, 'dimmer-freeze-init');
            pendingForceReadingFromFreeze = false;
        }

        modeToggleBtn.addEventListener('click', () => {
            // In frozen mode: reset dimmer to off + switch to game mode
            if (globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                globalVisualDimmer.setLevel(0, { forceEmit: true });
                setReadingMode(false, 'ui-mode-toggle-unfreeze');
            } else {
                setReadingMode(!isReadingMode, 'ui-mode-toggle');
            }
        });

        // HELPER: Sync AutoWalk Index to current Player Position
        function syncAutoWalkToIndex() {
            if (!autoWalkPath || autoWalkPath.length === 0) return;

            // Calculate Foot Position
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const footX = player.x + spriteW / 2;
            const footY = player.y + spriteH + 15;

            // Find closest index
            let closestIdx = 0;
            let minDistSq = Infinity;

            for (let i = 0; i < autoWalkPath.length; i++) {
                const node = autoWalkPath[i];
                const dx = node.x - footX;
                const dy = node.y - footY;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestIdx = i;
                }
            }

            // Set Index
            autoWalkIndex = closestIdx;
            console.log(`AutoWalk Synced to Index: ${closestIdx} / ${autoWalkPath.length}`);
        }

        // 8. Wenn Audio zu Ende ist, Reset
        // 8. Wenn Audio zu Ende ist
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode || contentSwitchInProgress) return;
            iconPlay.style.display = 'block';
            renderSubtitleLines(subtitleTracks.length - 1);
        });

        // 9. Bei Fenster-Resize: Canvas anpassen & Zeilen neu berechnen
        window.addEventListener('resize', () => {
            // A) Canvas Resize Logic (Vollbild UnterstÃ¼tzung)
            if (mapW > 0 && mapH > 0 && gameReady) {
                SCREEN_W = Math.min(mapW, window.innerWidth);
                SCREEN_H = Math.min(mapH, window.innerHeight);
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;

                // Kamera neu zentrieren
                camX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                camY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));
            }

            // B) Untertitel Logic: Force Rebuild bei Resize
            if (isReadingMode && subtitleTracks.length > 0) {
                // Leere Container um Rebuild zu erzwingen (Fix fÃ¼r Scrollbar Resize Bug)
                subtitleContainer.innerHTML = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // 10. Fullscreen Logic
        function getFullscreenElementSafe() {
            return document.fullscreenElement || document.webkitFullscreenElement || null;
        }

        function isFullscreenSupported() {
            const root = document.documentElement;
            return !!(
                document.fullscreenEnabled ||
                document.webkitFullscreenEnabled ||
                root.requestFullscreen ||
                root.webkitRequestFullscreen
            );
        }

        function requestFullscreenSafe() {
            const root = document.documentElement;
            if (root.requestFullscreen) return root.requestFullscreen();
            if (root.webkitRequestFullscreen) return Promise.resolve(root.webkitRequestFullscreen());
            return Promise.reject(new Error('Fullscreen API not supported'));
        }

        function exitFullscreenSafe() {
            if (document.exitFullscreen) return document.exitFullscreen();
            if (document.webkitExitFullscreen) return Promise.resolve(document.webkitExitFullscreen());
            return Promise.resolve();
        }

        function syncFullscreenUi() {
            if (getFullscreenElementSafe()) {
                iconFsEnter.style.display = 'none';
                iconFsExit.style.display = 'block';
            } else {
                iconFsEnter.style.display = 'block';
                iconFsExit.style.display = 'none';
            }
            positionRecenterButton();
        }

        fullscreenBtn.addEventListener('click', async () => {
            if (!isFullscreenSupported()) {
                showNotification('Vollbild wird auf diesem Geraet nicht unterstuetzt.');
                syncFullscreenUi();
                return;
            }

            try {
                if (!getFullscreenElementSafe()) {
                    await requestFullscreenSafe();
                } else {
                    await exitFullscreenSafe();
                }
            } catch (err) {
                console.warn(`Error attempting to toggle fullscreen: ${err && err.message ? err.message : err}`);
                showNotification('Vollbild konnte nicht aktiviert werden.');
            } finally {
                syncFullscreenUi();
            }
        });

        document.addEventListener('fullscreenchange', syncFullscreenUi);
        document.addEventListener('webkitfullscreenchange', syncFullscreenUi);
        document.addEventListener('fullscreenerror', () => {
            syncFullscreenUi();
            showNotification('Vollbild ist auf diesem Geraet nicht verfuegbar.');
        });
        document.addEventListener('webkitfullscreenerror', () => {
            syncFullscreenUi();
            showNotification('Vollbild ist auf diesem Geraet nicht verfuegbar.');
        });

        // 11. Custom Fullscreen Button (siehe oben)
        let lastBrightness = 0;


        let lastBrightnessCheck = 0;
        let backgroundBrightnessTimer = null;

        function scheduleBackgroundBrightnessCheck(delayMs = 600) {
            if (backgroundBrightnessTimer) clearTimeout(backgroundBrightnessTimer);
            backgroundBrightnessTimer = setTimeout(() => {
                requestAnimationFrame(checkBackgroundBrightness);
            }, Math.max(120, delayMs || 0));
        }
        function checkBackgroundBrightness(timestamp) {
            if (manualBackgroundDimLevel > 0) {
                subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            // Im Lesemodus immer dunkler Hintergrund
            if (isReadingMode) {
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            if (!gameReady || uiContainer.style.display === 'none') {
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            // Throttle: Nur alle 1000ms prÃ¼fen (Performance!)
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastBrightnessCheck < 1000) {
                scheduleBackgroundBrightnessCheck(260);
                return;
            }
            lastBrightnessCheck = timestamp;

            try {
                const uiRect = uiContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const sampleX = Math.max(0, (uiRect.left - canvasRect.left) * (canvas.width / canvasRect.width));
                const sampleY = Math.max(0, (uiRect.top - canvasRect.top) * (canvas.height / canvasRect.height));
                const sampleW = Math.min(canvas.width - sampleX, uiRect.width * (canvas.width / canvasRect.width));
                const sampleH = Math.min(canvas.height - sampleY, uiRect.height * (canvas.height / canvasRect.height));

                if (sampleW > 0 && sampleH > 0 && sampleX >= 0 && sampleY >= 0) {
                    const imageData = ctx.getImageData(
                        Math.floor(sampleX),
                        Math.floor(sampleY),
                        Math.floor(Math.min(sampleW, 100)),
                        Math.floor(Math.min(sampleH, 60))
                    );

                    let totalBrightness = 0;
                    const pixels = imageData.data;
                    const pixelCount = pixels.length / 4;

                    for (let i = 0; i < pixels.length; i += 16) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                    }

                    const avgBrightness = totalBrightness / (pixelCount / 4);
                    lastBrightness = lastBrightness * 0.85 + avgBrightness * 0.15;

                    // StÃ¤rkerer Kontrast: noch frÃ¼her einsetzen, hÃ¶here Basis
                    const threshold = 60;
                    const maxBrightness = 180;
                    const baseOpacity = 0.5;
                    const maxAdditionalOpacity = 0.8;

                    if (lastBrightness > threshold) {
                        const dynamicOpacity = ((lastBrightness - threshold) / (maxBrightness - threshold)) * maxAdditionalOpacity;
                        const opacity = Math.min(0.95, baseOpacity + dynamicOpacity);
                        const bgValue = `rgba(0, 0, 0, ${opacity.toFixed(2)})`;
                        subtitleContainer.style.background = bgValue;
                        audioControlsEl.style.background = bgValue;
                    } else {
                        subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                        audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                    }
                }
            } catch (e) {
                // Canvas-Zugriff kann bei bestimmten Bedingungen fehlschlagen
            }

            scheduleBackgroundBrightnessCheck(700);
        }

        // Starte die Hintergrund-PrÃ¼fung
        scheduleBackgroundBrightnessCheck(350);

        // Global Start Time for Grace Period
        const GAME_START_TIME = Date.now();

        // ============================================
        // LORE PROXIMITY SYSTEM
        // ============================================
        function updateLoreSystem() {
            // Grace Period: 3 Sekunden keine Trigger nach Start
            if (!gameReady || yellowLights.length === 0 || (Date.now() - GAME_START_TIME < 3000)) return;

            const refW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const refH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const offsetY = Math.floor(refH * 0.22);
            const hatOffset = Math.floor(refH * 0.15);

            // Bounding Box des Charakters (synchron mit der visuellen Anzeige)
            // Nur der "KÃ¶rper" (Hut bis FÃ¼ÃŸe) lÃ¶st den Trigger aus
            const pLeft = player.x;
            const pRight = player.x + refW;
            const pTop = player.y + offsetY + hatOffset;
            const pBottom = player.y + offsetY + refH;

            // Finde das nÃ¤chste Licht und die Distanz zur Bounding Box
            let nearestId = null;
            let minDist = Infinity;

            yellowLights.forEach(light => {
                // Finde den nÃ¤chsten Punkt auf der Bounding Box zum Licht
                const closestX = Math.max(pLeft, Math.min(light.x, pRight));
                const closestY = Math.max(pTop, Math.min(light.y, pBottom));

                const dx = light.x - closestX;
                const dy = light.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearestId = light.id;
                }
            });

            const TRIGGER_DIST = 6; // Reduced by ~70% (was 20)
            const EXIT_DIST = 25; // Adjusted Hysteresis

            // SHIMMER SOUND TRIGGER (UnabhÃ¤ngig vom Text)
            if (nearestId && minDist < TRIGGER_DIST) {
                // BUGFIX: Do not play shimmer if already collected!
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));

                if (!alreadyCollected) {
                    if (lastShimmerLightId !== nearestId) {
                        shimmerSound.currentTime = 0;
                        if (allowAuxScPlayback()) {
                            shimmerSound.play().catch(() => { });
                        }
                        lastShimmerLightId = nearestId;
                    }
                }
            } else if (!nearestId || minDist > EXIT_DIST) {
                // Reset, wenn man den Einflussbereich verlassen hat
                lastShimmerLightId = null;
            }

            // START LORE - Dynamic Sequential Unlock
            if (nearestId && minDist < TRIGGER_DIST && !isLoreMode) {
                // Safety Check: Ignore if Player or Light is at (0,0) (Spawn Glitch)
                const light = yellowLights.find(l => l.id === nearestId);
                if ((player.x === 0 && player.y === 0) || (light && light.x === 0 && light.y === 0)) {
                    return;
                }

                // Check if this specific light was already collected
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));
                if (alreadyCollected) {
                    return;
                }

                activeLightSourceId = nearestId;

                // Use GameState for unified persistence (syncs with YellowLight.draw check)
                if (window.GameState) {
                    window.GameState.collectLight(sc, nearestId).then(unlockedLoreId => {
                        if (unlockedLoreId) {
                            console.log("[GameState] Collected Light -> Unlocked Lore:", unlockedLoreId);
                            // Refresh archive menu so new lore appears immediately
                            if (typeof renderArchive === 'function') renderArchive();
                            // Start lore mode with the UNLOCKED lore ID (not the light ID!)
                            startLoreMode(unlockedLoreId);
                        } else {
                            console.log("[GameState] Light collected but all lore already unlocked.");
                        }
                    });
                } else {
                    // Fallback to local LoreSystem if GameState not available
                    if (!LoreSystem.state.collectedLights[sc]) LoreSystem.state.collectedLights[sc] = [];
                    LoreSystem.state.collectedLights[sc].push(nearestId);
                    LoreSystem.save();
                    const nextLore = LoreSystem.state.collectedLore.length + 1;
                    if (LoreSystem.unlock(nextLore)) {
                        console.log("[LoreSystem] Unlocked Lore:", nextLore);
                        startLoreMode(nextLore);
                    }
                }

            }
            // Lore intentionally keeps playing even after leaving the trigger area.
        } // End updateLoreSystem

        // NEW: Restore Main Audio Function (Replaces basic endLoreMode logic)
        function getActiveContentKey() {
            if (isLoreMode && activeLoreId) return `lore${activeLoreId}`;
            return MAIN_CONTENT_KEY;
        }

        function clearContentState(key) {
            if (!key) return;
            if (window.PlayerStateManager) {
                window.PlayerStateManager.clear(key);
            }

            if (key === MAIN_CONTENT_KEY) {
                mainAudioState.time = 0;
                mainAudioState.wasPlaying = false;
            } else if (key.startsWith('lore')) {
                const loreId = parseInt(key.replace('lore', ''), 10);
                if (Number.isFinite(loreId)) {
                    loreData.resumeTimes[loreId] = 0;
                }
            }
        }

        function isCurrentContentCompleted() {
            if (!subtitleTracks || subtitleTracks.length === 0) return false;
            const t = audioPlayer.currentTime || 0;
            const duration = audioPlayer.duration || 0;
            const reachedAudioEnd = duration > 0 && t >= Math.max(0, duration - 0.25);
            const reachedSubtitleEnd = currentSubtitleIndex >= subtitleTracks.length - 1;
            return reachedAudioEnd && reachedSubtitleEnd;
        }

        async function saveCurrentContentState(options = {}) {
            const {
                keyOverride = null,
                clear = false,
                preferCachedTime = false,
                reason = 'unspecified'
            } = options;

            const key = keyOverride || getActiveContentKey();
            if (!key || !audioPlayer) return;

            if (clear) {
                clearContentState(key);
                indexDebug.lastSave = { key, cleared: true, reason, at: Date.now() };
                indexDebugNote('state-clear', `${key} (${reason})`);
                return;
            }

            try {
                let currentTime = audioPlayer.currentTime || 0;
                if (!preferCachedTime && typeof audioPlayer.getAccurateCurrentTime === 'function') {
                    currentTime = await audioPlayer.getAccurateCurrentTime(800);
                }

                const wasPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !audioPlayer.paused;

                if (window.PlayerStateManager) {
                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        const sentence = window.PlayerStateManager.findSentenceStart(currentTime, subtitleTracks);
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: sentence.index,
                            sentenceTime: sentence.time,
                            wasPlaying
                        });

                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: sentence.index,
                            sentenceTime: Number((sentence.time || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} -> ${sentence.time.toFixed(2)}s idx=${sentence.index} play=${wasPlaying} (${reason})`);
                    } else {
                        window.PlayerStateManager.saveState(key, subtitleTracks, audioPlayer);
                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: null,
                            sentenceTime: Number((currentTime || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} (legacy) ${currentTime.toFixed(2)}s (${reason})`);
                    }
                }

                if (key === MAIN_CONTENT_KEY) {
                    mainAudioState.wasPlaying = wasPlaying;
                    mainAudioState.time = currentTime || 0;
                    mainAudioState.tracks = [...subtitleTracks];
                } else if (key.startsWith('lore')) {
                    const loreId = parseInt(key.replace('lore', ''), 10);
                    if (Number.isFinite(loreId)) {
                        loreData.resumeTimes[loreId] = currentTime || 0;
                    }
                }
            } catch (e) {
                console.warn('[State] saveCurrentContentState failed:', e);
                indexDebugNote('state-error', `${reason}: ${e && e.message ? e.message : e}`);
            }
        }

        async function ensureMainTextLoaded() {
            if (window.mainTextContent && window.mainTextContent.length > 0) {
                return window.mainTextContent;
            }
            const response = await fetch('assets/kapitel1.txt');
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            window.mainTextContent = await response.text();
            return window.mainTextContent;
        }

        async function ensureLoreTextLoaded(id) {
            if (loreData.text[id] && loreData.text[id].length > 0) {
                return loreData.text[id];
            }

            const content = window.GameState?.getLore(id);
            const textPath = content ? content.text : `assets/lore${id}.txt`;
            const response = await fetch(textPath);
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            loreData.text[id] = await response.text();
            return loreData.text[id];
        }

        function findSubtitleIndexForTime(timeSec) {
            if (!subtitleTracks || subtitleTracks.length === 0) return 0;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (timeSec >= subtitleTracks[i].time) return i;
            }
            return 0;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForContentSwitchIdle(reason, timeoutMs = 2200) {
            const endAt = Date.now() + Math.max(300, timeoutMs || 0);
            let waited = 0;
            while (contentSwitchInProgress && Date.now() < endAt) {
                await wait(60);
                waited += 60;
            }
            if (contentSwitchInProgress) {
                indexDebugNote('switch-wait-timeout', `${reason || 'unknown'} waited=${waited}ms`);
            } else if (waited > 0) {
                indexDebugNote('switch-wait', `${reason || 'unknown'} waited=${waited}ms`);
            }
        }

        async function seekAndSyncSubtitle(targetTime, reason) {
            const safeTarget = Math.max(0, Number(targetTime) || 0);
            indexTrace('seek:start', {
                reason,
                target: Number(safeTarget.toFixed(3)),
                before: Number(((audioPlayer && audioPlayer.currentTime) || 0).toFixed(3))
            });
            let seekResult = {
                ok: false,
                target: safeTarget,
                position: audioPlayer.currentTime || 0,
                attempts: 0
            };

            try {
                if (typeof audioPlayer.seekAndConfirm === 'function') {
                    seekResult = await audioPlayer.seekAndConfirm(safeTarget, {
                        maxAttempts: 5,
                        settleMs: 220,
                        tolerance: 0.9
                    });
                } else {
                    audioPlayer.currentTime = safeTarget;
                    await wait(260);
                    const pos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                        ? await audioPlayer.getAccurateCurrentTime(900)
                        : (audioPlayer.currentTime || 0);
                    seekResult = {
                        ok: Math.abs(pos - safeTarget) <= 1.0 || pos >= safeTarget - 1.0,
                        target: safeTarget,
                        position: pos,
                        attempts: 1
                    };
                }
            } catch (e) {
                indexDebugNote('seek-error', `${reason}: ${e && e.message ? e.message : e}`);
            }

            const effectiveTime = Number.isFinite(seekResult.position) ? seekResult.position : safeTarget;
            currentSubtitleIndex = findSubtitleIndexForTime(effectiveTime);
            renderSubtitleLines(currentSubtitleIndex);
            indexDebugNote('seek', `${reason} target=${safeTarget.toFixed(2)} pos=${effectiveTime.toFixed(2)} ok=${seekResult.ok} tries=${seekResult.attempts}`);
            indexTrace('seek:end', {
                reason,
                ok: !!seekResult.ok,
                attempts: seekResult.attempts || 0,
                target: Number(safeTarget.toFixed(3)),
                position: Number((effectiveTime || 0).toFixed(3)),
                subtitleIndex: currentSubtitleIndex
            });
            return seekResult;
        }

        async function pauseWithFade(duration = 800) {
            if (!audioPlayer || audioPlayer.paused) return;
            await new Promise(resolve => {
                fadeAudio(audioPlayer, 0, duration, () => {
                    audioPlayer.pause();
                    resolve();
                });
            });
        }

        async function verifyPlaybackStarted(retries = 2, delayMs = 320) {
            let previousPos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                ? await audioPlayer.getAccurateCurrentTime(600)
                : (audioPlayer.currentTime || 0);
            let sawRecentProgress = (typeof audioPlayer.hasRecentProgress === 'function')
                ? audioPlayer.hasRecentProgress(1800)
                : false;
            indexTrace('verify-play:start', {
                retries,
                delayMs,
                startPos: Number((previousPos || 0).toFixed(3)),
                paused: !!audioPlayer.paused,
                transportPaused: isAudioTransportPaused(),
                sawRecentProgress
            });

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    await audioPlayer.play();
                } catch (e) {
                    console.warn(`[Audio] play() failed on attempt ${attempt + 1}:`, e);
                    indexTrace('verify-play:play-error', { attempt: attempt + 1, message: e && e.message ? e.message : String(e) });
                }

                await wait(delayMs);
                const currentPos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                    ? await audioPlayer.getAccurateCurrentTime(700)
                    : (audioPlayer.currentTime || 0);
                const advanced = Number.isFinite(currentPos) && Number.isFinite(previousPos)
                    ? (currentPos - previousPos) >= 0.08
                    : false;
                const probablyPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !audioPlayer.paused;
                const transportPaused = isAudioTransportPaused();
                const hasRecentProgress = (typeof audioPlayer.hasRecentProgress === 'function')
                    ? audioPlayer.hasRecentProgress(1800)
                    : false;
                sawRecentProgress = sawRecentProgress || hasRecentProgress;
                const started = !transportPaused && (advanced || hasRecentProgress);
                indexDebugNote(
                    'play-check',
                    `attempt=${attempt + 1} paused=${audioPlayer.paused} playing=${probablyPlaying} adv=${advanced} t=${currentPos.toFixed(2)}`
                );
                indexTrace('verify-play:attempt', {
                    attempt: attempt + 1,
                    paused: !!audioPlayer.paused,
                    transportPaused,
                    probablyPlaying: !!probablyPlaying,
                    advanced: !!advanced,
                    hasRecentProgress,
                    previousPos: Number((previousPos || 0).toFixed(3)),
                    currentPos: Number((currentPos || 0).toFixed(3)),
                    started
                });
                if (started) {
                    indexTrace('verify-play:success', { attempt: attempt + 1, currentPos: Number((currentPos || 0).toFixed(3)) });
                    return true;
                }
                previousPos = Number.isFinite(currentPos) ? currentPos : previousPos;
            }
            // Last fallback: if transport isn't paused and we observed recent progress,
            // treat playback as started even when sampling delta was too small.
            const finalTransportPaused = isAudioTransportPaused();
            if (!finalTransportPaused && sawRecentProgress) {
                indexTrace('verify-play:success-fallback', { sawRecentProgress: true });
                return true;
            }
            indexTrace('verify-play:failed', { retries, delayMs });
            return false;
        }

        async function restoreMainAudio(options = {}) {
            const {
                saveCurrent = true,
                forceResume = false
            } = options;
            indexTrace('switch:restore-main:enter', { saveCurrent: !!saveCurrent, forceResume: !!forceResume });

            if (!isLoreMode && !contentSwitchInProgress) {
                return;
            }

            if (contentSwitchInProgress) {
                indexTrace('switch:restore-main:blocked', { reason: 'contentSwitchInProgress' });
                return;
            }
            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;
            indexTrace('switch:restore-main:lock', { switchToken });

            try {
                const loreIdBeforeSwitch = activeLoreId;
                if (saveCurrent && loreIdBeforeSwitch) {
                    await saveCurrentContentState({ keyOverride: `lore${loreIdBeforeSwitch}`, reason: 'restore-main:save-lore' });
                } else if (!saveCurrent && loreIdBeforeSwitch) {
                    clearContentState(`lore${loreIdBeforeSwitch}`);
                }

                // --- RADICAL iOS FALLBACK RESTORE ---
                if (typeof isIOSDevice !== 'undefined' && isIOSDevice) {
                    if (ambientAudio && ambientAudio.audioNode && !ambientAudio.audioNode.src) {
                        ambientAudio.src = getSCUrl(AUDIO_PROFILE.ambientUrl || 'assets/wind.mp3');
                    }
                    if (footstepSound && footstepSound.audioNode && !footstepSound.audioNode.src) {
                        footstepSound.src = getSCUrl('assets/footstep.mp3');
                    }
                }
                // ------------------------------------

                isLoreMode = false;
                isMenuTriggeredLore = false;
                activeLoreId = null;
                activeLightSourceId = null;
                applySceneAudioMix('restore-main:mode');

                if (loreResumeTimeout) {
                    clearTimeout(loreResumeTimeout);
                    loreResumeTimeout = null;
                }

                uiContainer.classList.add('mode-switching');
                indexTrace('switch:restore-main:ui-mode-switching-on', { switchToken });

                await pauseWithFade(700);
                if (switchToken !== contentSwitchToken) return;

                audioPlayer.src = getSCUrl(window.mainAudioUrl || LEVEL.audioUrl);
                indexTrace('switch:restore-main:src-set', { switchToken, src: audioPlayer.src });

                const mainText = await ensureMainTextLoaded();
                if (switchToken !== contentSwitchToken) return;
                parseSubtitles(mainText);
                indexTrace('switch:restore-main:text-parsed', { switchToken, tracks: subtitleTracks.length });

                const savedMain = window.PlayerStateManager ? window.PlayerStateManager.getState(MAIN_CONTENT_KEY) : null;
                const resumeTime = savedMain && savedMain.sentenceTime !== undefined
                    ? savedMain.sentenceTime
                    : Math.max(0, mainAudioState.time || 0);
                indexTrace('switch:restore-main:resume-time', {
                    switchToken,
                    resumeTime: Number((resumeTime || 0).toFixed(3)),
                    hasSavedMain: !!savedMain
                });
                indexDebugNote('restore-main', `resume=${resumeTime.toFixed(2)}s saved=${!!savedMain}`);
                await seekAndSyncSubtitle(resumeTime, 'restore-main:pre-play');

                const shouldResumePlayback = forceResume || (savedMain ? !!savedMain.wasPlaying : !!mainAudioState.wasPlaying);
                indexTrace('switch:restore-main:resume-decision', { switchToken, shouldResumePlayback: !!shouldResumePlayback });
                if (shouldResumePlayback) {
                    audioPlayer.volume = 0;
                    const started = await verifyPlaybackStarted(4, 320);
                    indexTrace('switch:restore-main:verify-result', { switchToken, started: !!started });
                    if (started) {
                        // Re-render subtitles at the already-seeked position without re-seeking
                        currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                        renderSubtitleLines(currentSubtitleIndex);
                        fadeAudio(audioPlayer, readerTextVolume, 700);
                        iconPlay.style.display = 'none';
                        iconPause.style.display = 'block';
                    } else {
                        audioPlayer.volume = readerTextVolume;
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else {
                    audioPlayer.volume = readerTextVolume;
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error('[Switch] Failed to restore main audio:', e);
                indexTrace('switch:restore-main:error', { message: e && e.message ? e.message : String(e) });
                indexDebugNote('restore-main-error', e && e.message ? e.message : String(e));
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                    indexTrace('switch:restore-main:unlock', { switchToken });
                }
            }
        }

        async function startLoreMode(id, fromMenu = false) {
            indexTrace('switch:start-lore:enter', { id, fromMenu: !!fromMenu });
            if (isLoreMode && activeLoreId === id) return;
            if (contentSwitchInProgress) {
                await waitForContentSwitchIdle(`start-lore:${id}`);
                if (contentSwitchInProgress) {
                    indexTrace('switch:start-lore:blocked-after-wait', { id });
                    return;
                }
            }

            const content = window.GameState?.getLore(id) || {
                audio: loreData.audio[id] || `assets/lore${id}.mp3`,
                text: `assets/lore${id}.txt`
            };

            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;
            indexTrace('switch:start-lore:lock', { id, switchToken });

            try {
                await saveCurrentContentState({ reason: `start-lore:${id}` });

                // --- RADICAL iOS FALLBACK: Free hardware audio slot ---
                if (typeof isIOSDevice !== 'undefined' && isIOSDevice) {
                    if (ambientAudio && typeof ambientAudio.pause === 'function') ambientAudio.pause();
                    if (footstepSound && typeof footstepSound.pause === 'function') footstepSound.pause();
                    if (ambientAudio && ambientAudio.audioNode) {
                        ambientAudio.audioNode.removeAttribute('src');
                        ambientAudio.audioNode.load();
                    }
                    if (footstepSound && footstepSound.audioNode) {
                        footstepSound.audioNode.removeAttribute('src');
                        footstepSound.audioNode.load();
                    }
                }
                // -----------------------------------------------------

                isLoreMode = true;
                activeLoreId = id;
                isMenuTriggeredLore = !!fromMenu;
                moveTarget = null;
                applySceneAudioMix('start-lore:mode');

                if (isReadingMode) {
                    uiContainer.classList.add('reading-mode');
                } else {
                    uiContainer.classList.remove('reading-mode');
                }
                uiContainer.classList.add('mode-switching');
                indexTrace('switch:start-lore:ui-mode-switching-on', { id, switchToken });

                await pauseWithFade(800);
                if (switchToken !== contentSwitchToken) return;

                const loreText = await ensureLoreTextLoaded(id);
                if (switchToken !== contentSwitchToken) return;

                const loreAudioSrc = getSCUrl(content.audio || loreData.audio[id] || `assets/lore${id}.mp3`);
                audioPlayer.src = loreAudioSrc;
                indexTrace('switch:start-lore:src-set', { id, switchToken, src: loreAudioSrc });

                parseSubtitles(loreText);
                indexTrace('switch:start-lore:text-parsed', { id, switchToken, tracks: subtitleTracks.length });
                const savedLore = window.PlayerStateManager ? window.PlayerStateManager.getState(`lore${id}`) : null;
                const resumeTime = savedLore && savedLore.sentenceTime !== undefined
                    ? savedLore.sentenceTime
                    : Math.max(0, loreData.resumeTimes[id] || 0);
                indexTrace('switch:start-lore:resume-time', {
                    id,
                    switchToken,
                    resumeTime: Number((resumeTime || 0).toFixed(3)),
                    hasSavedLore: !!savedLore
                });
                indexDebugNote('start-lore', `id=${id} resume=${resumeTime.toFixed(2)}s saved=${!!savedLore} fromMenu=${!!fromMenu}`);
                await seekAndSyncSubtitle(resumeTime, `start-lore:${id}:pre-play`);

                audioPlayer.volume = 0;
                const started = await verifyPlaybackStarted(3, 320);
                indexTrace('switch:start-lore:verify-result', { id, switchToken, started: !!started });
                if (switchToken !== contentSwitchToken) return;

                if (started) {
                    // Re-render subtitles at the already-seeked position without re-seeking
                    currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                    renderSubtitleLines(currentSubtitleIndex);
                    fadeAudio(audioPlayer, readerTextVolume, 900);
                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';
                } else {
                    audioPlayer.volume = readerTextVolume;
                    console.warn(`[Switch] Lore ${id} loaded but playback did not start.`);
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error(`[Switch] Failed to start lore ${id}:`, e);
                indexTrace('switch:start-lore:error', { id, message: e && e.message ? e.message : String(e) });
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                    indexTrace('switch:start-lore:unlock', { id, switchToken });
                }
            }
        }

        function endLoreMode() {
            indexTrace('switch:end-lore', { activeLoreId: activeLoreId || null });
            restoreMainAudio({ saveCurrent: true });
        }

        function fadeAudio(audio, targetVolume, duration, callback) {
            const startVolume = audio.volume;
            const diff = targetVolume - startVolume;
            const startTime = Date.now();

            function tick() {
                const now = Date.now();
                const progress = Math.min(1, (now - startTime) / duration);
                audio.volume = startVolume + diff * progress;

                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (callback) {
                    callback();
                }
            }
            tick();
        }


    </script>
</body>

</html>

