<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heidelberg RPG</title>
    <!-- SoundCloud Widget API & System -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="assets/js/SoundCloudURLs.js"></script>
    <script src="assets/js/shared-game-systems.js"></script>
    <script src="assets/js/PlayerStateManager.js"></script>
    <script src="assets/js/AudioVisibilityManager.js"></script>
    <script src="assets/js/SCAudioAdapter.js"></script> <!-- Adapter AFTER Managers so it can register itself -->
    <!-- Main Stylesheet (extracted during refactoring) -->
    <link rel="stylesheet" href="assets/css/main.css">
    <!-- Critical inline CSS for loading screen (above-the-fold) -->
    <style>
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #444;
            font-family: 'Segoe UI', system-ui, sans-serif;
            transition: opacity 1s ease;
        }

        #loading-screen .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <!-- LOADING SCREEN (Ã¼ber ALLEM) -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING...</p>
    </div>

    <!-- SVG Filter Definitionen -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1"
        xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- PAL Filter: Horizontal Blur + leichte Farbverschiebung -->
            <filter id="pal-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.6 0" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="
                    0.9 0.1 0.0 0 0
                    0.0 0.9 0.1 0 0
                    0.0 0.0 0.9 0 0
                    0   0   0   1 0" result="colored" />
            </filter>

            <!-- Glitch Filter: Turbulenz Displacement -->
            <!-- Glitch Filter: Turbulenz Displacement -->
            <filter id="glitch-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.002 0.005" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="baseFrequency" dur="60s" values="0.002 0.005;0.005 0.01;0.002 0.005"
                        repeatCount="indefinite" />
                    <animate attributeName="seed" dur="3s" values="0;100;0" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R"
                    yChannelSelector="G" />
            </filter>
        </defs>
    </svg>

    <!-- DropZone removed for Electron App -->

    <div id="processingInfo">
        <div class="spinner"></div>
        <div>Verarbeite Karte...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>

    <!-- MAIN GAME AREA -->
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="crtOverlay"></div>
    </div>

    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer">
            <!-- Dynamisch generierte Zeilen -->
        </div>

        <!-- Next Chapter Button (Hidden by default) -->
        <button id="nextChapterBtn">Weiter</button>

        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn" tabindex="-1">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" tabindex="-1">
                    <!-- Resize Book Button by ~20% (scale 0.8 or smaller SVG) -->
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                </button>

                <button id="readingModeBtn" class="audio-btn" title="Lesemodus" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="gameModeBtn" class="audio-btn" title="Spielmodus" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild" tabindex="-1">
                    <!-- ENTER FULLSCREEN (Corners pointing OUT) -->
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square">
                        <path d="M7 10V7h3" />
                        <path d="M17 10V7h-3" />
                        <path d="M17 14v3h-3" />
                        <path d="M7 14v3h3" />
                    </svg>
                    <!-- EXIT FULLSCREEN (Corners pointing IN) -->
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square" style="display:none;">
                        <path d="M4 14h6v6" />
                        <path d="M20 14h-6v6" />
                        <path d="M20 10h-6V4" />
                        <path d="M4 10h6V4" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- DEBUG PANEL: Press 'D' to toggle -->
    <div id="debugPanel"
        style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: #0f0; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 99999; display: none; min-width: 280px;">
        <div style="font-weight: bold; margin-bottom: 10px; color: #ff0;">ðŸ”§ DEBUG PANEL (D = Toggle)</div>

        <div style="margin-bottom: 8px;">
            <label>Main Audio: <span id="dbgMainVol">100%</span></label><br>
            <input type="range" id="sliderMainVol" min="0" max="100" value="100" style="width: 100%;">
        </div>

        <div style="margin-bottom: 8px;">
            <label>Ambient: <span id="dbgAmbientVol">30%</span></label><br>
            <input type="range" id="sliderAmbientVol" min="0" max="100" value="30" style="width: 100%;">
        </div>

        <div style="margin-bottom: 8px;">
            <label>Footsteps: <span id="dbgFootstepsVol">40%</span></label><br>
            <input type="range" id="sliderFootstepsVol" min="0" max="100" value="40" style="width: 100%;">
        </div>

        <div id="dbgStatus"
            style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #333; color: #888; font-size: 10px;">
            Status: Loading...
        </div>
    </div>

    <!-- ARCHIVE MODAL (INHALT) -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title">Inhalt</div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>

            <div class="archive-content">
                <!-- LINKS: KAPITEL -->
                <div class="col-left" id="chapterList">
                    <div class="col-header">Kapitel</div>
                    <!-- Hardcoded Chapter 1 -->
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Der Marktplatz</div>
                    </div>

                    <!-- Chapter 1b -->
                    <div class="menu-item" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Liminal Library</div>
                    </div>

                    <!-- Chapter 1c -->
                    <div class="menu-item" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse</div>
                    </div>
                </div>

                <!-- RECHTS: LORE -->
                <div class="col-right" id="loreList">
                    <div class="col-header">Lore</div>
                    <!-- Dynamisch gefÃ¼llt -->
                </div>
            </div>
            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; display: flex; gap: 20px; justify-content: center;">
                <button id="btnSaveData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">SAVE
                    (Export)</button>
                <button id="btnLoadData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">LOAD
                    (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <!-- Shared Game Systems (Particle, Cloud, YellowLight) for code sharing - LOADED IN HEAD -->

    <script>
        // ============================================
        // SETUP & FILTER LOGIK
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const controlsHint = document.getElementById('controlsHint');



        const processingInfo = document.getElementById('processingInfo');
        const gameWrapper = document.getElementById('gameWrapper');

        // PAL + CRT Effekte permanent aktiviert
        console.log("Applying Visual Fixes..."); // DEBUG
        gameWrapper.classList.add('effect-pal');
        gameWrapper.classList.add('effect-crt');

        // Turbulenz fÃ¼r Glitch laufend aktualisieren fÃ¼r "Randomness"
        // const turb = document.querySelector('#glitch-filter feTurbulence');
        // const disp = document.querySelector('#glitch-filter feDisplacementMap');

        // Glitch Loop: Manchmal stÃ¤rker, manchmal schwÃ¤cher
        // setInterval(() => {
        //     if (Math.random() > 0.95) {
        //         // Kurzer starker Glitch
        //         disp.setAttribute('scale', (Math.random() * 30 + 10).toString());
        //         turb.setAttribute('seed', Math.floor(Math.random() * 100).toString());
        //         setTimeout(() => {
        //             disp.setAttribute('scale', '4'); // ZurÃ¼ck zu subtil
        //         }, 100);
        //     }
        // }, 500);

        let gameReady = false;
        const SCENE_NAME = 'marktplatz'; // Added SCENE_NAME
        let bgImage = null;
        let foregroundImage = null;
        let spriteReady = false;
        let collisionData = [];   // true = Wand
        let foregroundData = [];  // true = Vordergrund (verdeckt Spieler)
        let flowData = [];        // true = Magischer Fluss (GrÃ¼n)
        let magentaPixels = [];
        let cyanPixels = new Set();
        let greenPixels = [];     // Zum Verstecken
        let yellowLights = [];    // Lore Lights (Global)
        let autoWalkPath = [];
        let autoWalkIndex = 0;
        // isReadingMode is defined later in AUDIO & SUBTITLE SYSTEM

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================
        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        let GameState = null; // Will be loaded dynamically

        let mainAudioState = { time: 0, wasPlaying: false, tracks: [] };
        let activeLoreId = null;
        let activeLightSourceId = null;
        let isLoreMode = false;
        let isMenuTriggeredLore = false;
        let loreResumeTimeout = null;

        const loreData = {
            audio: {},
            text: {},
            resumeTimes: {}
        };

        // Initialize GameState
        (async function initGameState() {
            try {
                const module = await import('./assets/js/GameState.js');
                GameState = module.GameState;
                window.GameState = GameState; // Global Ref
                await GameState.init();
                console.log("[Index] GameState Loaded & Initialized");

                // Populate loreData for compatibility (audio + text)
                const db = GameState.getAllLore();
                for (const [id, content] of Object.entries(db)) {
                    loreData.audio[id] = content.audio;
                    // Pre-fetch text for reliability
                    try {
                        const res = await fetch(content.text);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`[Init] Pre-loaded text for lore ${id}`);
                        }
                    } catch (e) {
                        console.warn(`[Init] Could not pre-load text for lore ${id}:`, e);
                    }
                }
            } catch (e) {
                console.error("Failed to load GameState:", e);
            }
        })();

        // kapitel1.mp3 als Haupt-Audio
        window.mainAudioUrl = 'assets/kapitel1.mp3';

        // Unlock Logic Wrapper
        async function unlockLoreItem(id) {
            if (!GameState) return;
            const newUnlock = await GameState.unlockLore(id);
            if (newUnlock) {
                const item = GameState.getLore(id);
                showNotification(`Eintrag freigeschaltet: ${item ? item.title : 'Unbekannt'}`);
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('controlsHint');
            if (el) {
                el.innerText = msg;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
        }

        // --- MENU LOGIC ---
        function renderArchive() {
            const list = document.getElementById('loreList');
            // Keep Header
            const header = list.querySelector('.col-header') || document.createElement('div');
            if (!list.querySelector('.col-header')) {
                header.className = 'col-header';
                header.innerText = 'Lore';
            }
            list.innerHTML = '';
            list.appendChild(header);

            if (!window.GameState) return;

            const db = window.GameState.getAllLore();
            const collectedIds = window.GameState.state.collectedLore;

            if (collectedIds.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'menu-item locked';
                empty.innerText = 'Keine Lore gefunden';
                list.appendChild(empty);
            } else {
                collectedIds.sort((a, b) => a - b).forEach(id => {
                    const content = db[id];
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'menu-item';

                    if (isLoreMode && activeLoreId === id) {
                        item.classList.add('active');
                    }

                    const mainText = document.createElement('div');
                    mainText.className = 'item-main-text';
                    mainText.innerText = content.title;

                    const subText = document.createElement('div');
                    subText.className = 'item-sub-text';
                    subText.innerText = content.duration;

                    item.appendChild(mainText);
                    item.appendChild(subText);

                    item.addEventListener('click', () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        startLoreMode(id, true);
                    });
                    list.appendChild(item);
                });
            }
            // (Chapter Logic continues inside renderArchive)

            // Chapter Logic (Left Column)
            const ch1 = document.getElementById('chapter1Btn');
            if (ch1) {
                const newCh1 = ch1.cloneNode(true);
                ch1.parentNode.replaceChild(newCh1, ch1);

                newCh1.addEventListener('click', () => {
                    console.log("Loading Chapter 1...");
                    document.getElementById('archiveModal').classList.remove('visible');

                    // 1. RE-LOAD MAP 'platz3.png' (Only if needed)
                    // If we are already here, do not reload map! 
                    // processMap(mapImg); // REMOVED to prevent reload

                    // 2. Audio Logic
                    if (isLoreMode) {
                        // If listening to Lore, switch back to Chapter
                        restoreMainAudio();
                    } else {
                        // If already in Chapter mode, maybe just unpause?
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        }
                    }
                });
            }

            // Chapter 1b Logic
            const ch1b = document.getElementById('chapter1bBtn');
            if (ch1b) {
                // Remove old listeners by cloning (if any exist spread from updates)
                const newCh1b = ch1b.cloneNode(true);
                ch1b.parentNode.replaceChild(newCh1b, ch1b);

                newCh1b.addEventListener('click', () => {
                    console.log("Loading Chapter 1b...");
                    window.location.href = 'liminal library.html';
                });
            }

            // Chapter 1c Logic
            const ch1c = document.getElementById('chapter1cBtn');
            if (ch1c) {
                const newCh1c = ch1c.cloneNode(true);
                ch1c.parentNode.replaceChild(newCh1c, ch1c);

                newCh1c.addEventListener('click', () => {
                    console.log("Loading Chapter 1c...");
                    window.location.href = 'index3.html';
                });
            }
        }

        // LEGACY - DEACTIVATED
        // LEGACY REMOVED

        // EVENT LISTENERS FOR ARCHIVE
        document.getElementById('bookBtn').addEventListener('click', () => {
            renderArchive();
            document.getElementById('archiveModal').classList.add('visible');
        });

        document.getElementById('closeArchiveBtn').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('visible');
        });

        // SAVE / LOAD LOGIC
        const btnSave = document.getElementById('btnSaveData');
        const btnLoad = document.getElementById('btnLoadData');
        const fileInput = document.getElementById('fileInputSave');

        if (btnSave) {
            btnSave.addEventListener('click', () => {
                if (!window.GameState) return;
                const json = window.GameState.exportState();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'liminal_save_' + Date.now() + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        if (btnLoad) {
            btnLoad.addEventListener('click', () => {
                if (fileInput) fileInput.click();
            });
        }

        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (window.GameState) {
                        const success = await window.GameState.importState(ev.target.result);
                        if (success) {
                            alert("Save Data Imported Successfully! Reloading...");
                            window.location.reload();
                        } else {
                            alert("Invalid Save File.");
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        // YellowLight class - now loaded from assets/js/shared-game-systems.js

        // Click-to-Move fÃ¼r Mobile
        let moveTarget = null; // {x, y} oder null

        // ============================================
        // PARTIKEL SYSTEM
        // ============================================
        const particles = [];
        const NUM_PARTICLES = 300; // Reduziert um 50%
        let particleSprite = null;

        // Spotlight-System: Sammelt Lichtquellen mit Richtung und IntensitÃ¤t
        let nearbyLights = []; // {x, y, intensity}

        // Dust-Particles: Staubwolken beim Laufen
        const dustParticles = [];

        // Screen-Shake bei Kollision
        let screenShake = 0;

        // Wolken-System (Parallax, selten)
        const clouds = [];
        const MAX_CLOUDS = 3;
        let cloudSpawnTimer = 0;

        // Cloud class and initClouds() - now loaded from assets/js/shared-game-systems.js

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        const footstepSound = new SCAudioAdapter();
        footstepSound.src = getSCUrl('assets/footsteps.mp3');
        footstepSound.volume = 0.024; // +20% from 0.02

        const shimmerSound = new SCAudioAdapter();
        shimmerSound.src = getSCUrl('assets/shimmer.mp3');
        shimmerSound.volume = 0.4;
        let lastShimmerLightId = null;
        let footstepPlaying = false;

        let audioUnlocked = false;

        // Ambient-Sound (permanent)
        const ambientSound = new SCAudioAdapter();
        ambientSound.src = getSCUrl('assets/medieval_town.mp3');
        ambientSound.volume = 0.024; // +20% from 0.02

        // Audio entsperren bei erstem User-Input
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            // Starte Ambient-Sound
            ambientSound.play().catch(() => { });
        }
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        // Periodisch Ambient neu starten falls gestoppt
        setInterval(() => {
            if (audioUnlocked && ambientSound.paused) {
                ambientSound.play().catch(() => { });
            }
        }, 3000);

        // createGlowSprite(), Particle class, and initParticles()
        // now loaded from assets/js/shared-game-systems.js

        // ============================================
        // LORE PERSISTENCE - Uses GameState module
        // ============================================
        // NOTE: LoreSystem object was REMOVED (redundant with GameState.js)
        // All lore persistence is now handled by GameState:
        // - GameState.unlockLore(id) - unlock a lore entry
        // - GameState.isUnlocked(id) - check if unlocked
        // - GameState.collectLight(sceneName, lightId) - mark light as collected
        // - GameState.isLightCollected(sceneName, lightId) - check light status


        let mapW = 0, mapH = 0;

        // Dynamische AuflÃ¶sung
        let SCREEN_W = 320;
        let SCREEN_H = 240;

        function updateDimensions() {
            // Robust Responsive Logic
            // Aim for maintaining pixel density while filling the screen.
            // Base resolution reference: 320x240 (4:3)

            const targetRatio = 320 / 240; // 1.333
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const winRatio = winW / winH;

            if (winRatio > targetRatio) {
                // Window is wider than 4:3 (Landscape / Wide)
                // Fix Height at 240, expand Width
                SCREEN_H = 240;
                SCREEN_W = Math.ceil(SCREEN_H * winRatio);
            } else {
                // Window is taller/narrower than 4:3 (Portrait / Square)
                // Fix Width at 320, expand Height
                SCREEN_W = 320;
                SCREEN_H = Math.ceil(SCREEN_W / winRatio);
            }

            // Canvas GrÃ¶ÃŸe aktualisieren
            if (canvas) {
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;
            }
            console.log(`Resolution updated: ${SCREEN_W}x${SCREEN_H} (Win: ${winW}x${winH}, Ratio: ${winRatio.toFixed(2)})`);
        }

        // Initial und bei Resize
        // Initial resize
        updateDimensions(); // Keep the original initial call
        window.addEventListener('resize', () => { // Keep the original resize listener
            updateDimensions();
            // Auch Subtitles neu rendern falls nÃ¶tig
            if (isReadingMode && subtitleTracks.length > 0) {
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // --- VISUAL CALIBRATION TOOL ---
        let params = {
            brightness: 1.15,
            contrast: 1.10,
            saturate: 0.85
        };
        let activeParam = 'brightness';

        const dispBrit = document.getElementById('dispBrit');
        const dispCont = document.getElementById('dispCont');
        const dispSat = document.getElementById('dispSat');
        const dispSel = document.getElementById('dispSel');
        const debugCanvas = document.getElementById('gameCanvas');

        window.addEventListener('keydown', (e) => {
            // Select Parameter (only if debug elements exist)
            if (e.key === '1') { activeParam = 'brightness'; if (dispSel) dispSel.innerText = 'Brightness'; }
            if (e.key === '2') { activeParam = 'contrast'; if (dispSel) dispSel.innerText = 'Contrast'; }
            if (e.key === '3') { activeParam = 'saturate'; if (dispSel) dispSel.innerText = 'Saturation'; }

            // Adjust
            if (e.key === '+' || e.key === 'Add' || e.key === '=') {
                params[activeParam] = Math.round((params[activeParam] + 0.05) * 100) / 100;
                updateVisuals();
            } else if (e.key === '-' || e.key === 'Subtract' || e.key === '_') {
                params[activeParam] = Math.round((params[activeParam] - 0.05) * 100) / 100;
                updateVisuals();
            }
        });

        function updateVisuals() {
            // Apply override to canvas
            // Standard PAL structure
            if (debugCanvas) debugCanvas.style.filter = `url(#pal-filter) contrast(${params.contrast}) brightness(${params.brightness}) saturate(${params.saturate})`;

            if (dispBrit) dispBrit.innerText = params.brightness.toFixed(2);
            if (dispCont) dispCont.innerText = params.contrast.toFixed(2);
            if (dispSat) dispSat.innerText = params.saturate.toFixed(2);

            console.log(`Params: B=${params.brightness}, C=${params.contrast}, S=${params.saturate}`);
        }
        // Initialize with default values once to ensure UI matches
        // updateVisuals();
        // End of VISUAL CALIBRATION TOOL

        let camX = 0, camY = 0;
        let targetCamX = 0, targetCamY = 0;

        // Sprite Sheet Konfiguration
        const SPRITE = {
            frameWidth: 0,   // Wird berechnet
            frameHeight: 0,  // Wird berechnet
            cols: 4,         // 4 Frames pro Reihe
            baseScale: 0.15, // Original Skalierung
            scale: 0.15      // Dynamische Skalierung
        };

        // Spieler
        const player = {
            x: 50, y: 50,
            w: 14, h: 8,      // Kollisionsbox (FÃ¼ÃŸe)
            speed: 35,        // Pixels per second (was 0.54 per frame)
            dir: 0,           // 0=down, 1=up, 2=left, 3=right
            frame: 0,         // 0-3 fÃ¼r Animation
            animTimer: 0,
            isMoving: false,
            isBehindForeground: false
        };

        const keys = {};

        // ============================================
        // SPRITES LADEN (alle 4 Richtungen)
        // ============================================
        let spriteFront = null;   // Frontalansicht (down)
        let spriteBack = null;    // RÃ¼ckenansicht (up)
        let spriteSide = null;    // Seitenansicht (right, links wird gespiegelt)
        let spritesLoaded = 0;
        const TOTAL_SPRITES = 3;

        function loadAllSprites() {
            // Frontal (nach unten schauend, NEU: spriteneu.png)
            spriteFront = new Image();
            spriteFront.onload = function () {
                // WICHTIG: Math.floor() fÃ¼r ganzzahlige Frame-Breite!
                SPRITE.frameWidth = Math.floor(this.width / SPRITE.cols); // Fallback-Wert, wird fÃ¼r DrawCoords Ã¼berschrieben
                SPRITE.frameHeight = this.height;
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log(`Sprite Front (New) geladen: ${this.width}x${this.height}`);
            };
            spriteFront.src = 'assets/spriteneu.png';
            spriteFront.onerror = () => console.warn('assets/spriteneu.png nicht gefunden');

            // RÃ¼cken (nach oben schauend, NEU: spriterueckenneu.png)
            spriteBack = new Image();
            spriteBack.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Back (New) geladen');
            };
            spriteBack.src = 'assets/spriterueckenneu.png';
            spriteBack.onerror = () => console.warn('assets/spriterueckenneu.png nicht gefunden');

            // Seitlich (fÃ¼r rechts, links wird gespiegelt)
            spriteSide = new Image();
            spriteSide.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Side (New) geladen');
            };
            spriteSide.src = 'assets/seitlichneu.png';
            spriteSide.onerror = () => console.warn('assets/seitlichneu.png nicht gefunden');
        }

        // Front (spriteneu.png)
        const FRONT_SPRITE_DATA = [
            { left: 38, width: 141, footX: 106, footY: 267 },
            { left: 201, width: 138, footX: 273, footY: 265 },
            { left: 361, width: 140, footX: 436, footY: 270 },
            { left: 534, width: 137, footX: 604, footY: 268 }
        ];
        // Ping-Pong Animation fÃ¼r Front (0-1-2-3-2-1)
        const FRONT_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        // Back (spriterueckenneu.png)
        const BACK_SPRITE_DATA = [
            { left: 16, width: 147, footX: 90, footY: 282 },
            { left: 177, width: 144, footX: 253, footY: 283 },
            { left: 336, width: 152, footX: 417, footY: 285 }
        ];
        // Ping-Pong Animation fÃ¼r Back (0-1-2-1)
        const BACK_ANIM_CYCLE = [0, 1, 2, 1];

        // NEU: Marker-Daten fÃ¼r seitlichneu.png (X, Y)
        const SIDE_SPRITE_DATA = [
            { left: 20, footX: 92, footY: 275 },
            { left: 200, footX: 268, footY: 281 },
            { left: 372, footX: 440, footY: 280 },
            { left: 528, footX: 595, footY: 284 }
        ];

        // Ping-Pong Animation fÃ¼r Seitlich (0-1-2-3-2-1)
        const SIDE_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        function checkAllSpritesLoaded() {
            if (spritesLoaded >= TOTAL_SPRITES) {
                spriteReady = true;
                console.log('Alle Sprites geladen!');
            }
        }

        // DEBUG HELPER
        window.logDebug = function (msg) {
            console.log("[DEBUG]", msg);
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML += msg + "<br>";
                const lines = d.innerHTML.split("<br>");
                if (lines.length > 6) d.innerHTML = lines.slice(lines.length - 6).join("<br>");
            }
        };

        window.addEventListener('load', () => {
            const pal = document.getElementById('pal-filter');
            const glitch = document.getElementById('glitch-filter');
            logDebug("Filters: PAL=" + (pal ? "OK" : "NO") + " GLITCH=" + (glitch ? "OK" : "NO"));

            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const style = window.getComputedStyle(canvas);
                const filter = style.getPropertyValue('filter');
                logDebug("Canvas Filter: " + ((filter && filter !== 'none') ? "ACTIVE" : "NONE"));
            }
        });

        loadAllSprites();

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // GLOBAL ERROR HANDLER (DEBUG)
        // ============================================
        window.onerror = function (msg, url, line, col, error) {
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.style.display = 'block';
                pi.style.color = '#ff5555';
                pi.style.background = 'rgba(0,0,0,0.9)';
                pi.innerText += "\nERROR: " + msg + "\nLine: " + line;
            }
            console.error(msg, error);
            return false;
        };

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        window.addEventListener('DOMContentLoaded', async () => {
            console.log("Electron Mode: Auto-Loading...");

            // 0. IMMEDIATE AUDIO PRELOAD (User Request: Buffer early)
            // WRAPPED IN TRY-CATCH TO PREVENT CRASHING THE LOADING SCREEN
            try {
                const mainAudioSrc = 'assets/kapitel1.mp3';
                window.mainAudioUrl = mainAudioSrc;
                if (typeof getSCUrl === 'function' && typeof audioPlayer !== 'undefined') {
                    const scUrl = getSCUrl(mainAudioSrc);
                    audioPlayer.src = scUrl;
                    if (audioPlayer.mode === 'html5' && audioPlayer.audioNode) {
                        audioPlayer.audioNode.preload = "auto";
                        // audioPlayer.audioNode.load(); // Reduced aggression to prevent hang
                        console.log("Audio Preloading Configured (Lazy)");
                    }
                } else {
                    console.warn("AudioPlayer or getSCUrl not ready yet.");
                }
            } catch (e) {
                console.warn("Audio Preload Failed (Non-Fatal):", e);
            }

            // RESTORE READING MODE STATE
            const savedMode = localStorage.getItem('gameboy_reading_mode');
            if (savedMode === 'true') {
                isReadingMode = true;
                const ui = document.getElementById('audioPlayerUI');
                if (ui) ui.classList.add('reading-mode');
            }

            // FALLBACK: Hide DropZone after 3 seconds if map fails
            // FALLBACK: Hide DropZone after 10 seconds if map fails (User Request: 10s Buffer limit)
            setTimeout(() => {
                const dz = document.getElementById('dropZone');
                const pi = document.getElementById('processingInfo');
                if (dz && !dz.classList.contains('hidden')) {
                    console.warn("Force hiding DropZone due to timeout (10s)!");
                    dz.classList.add('hidden');
                }
                if (pi) pi.style.display = 'none';

                // Force Hide Loading Screen
                const ls = document.getElementById('loading-screen');
                if (ls) ls.style.display = 'none';

                // Force Start Loop if not ready
                if (!gameReady) {
                    console.warn("Force starting game loop!");
                    gameReady = true;
                    // Ensure Canvas Size
                    const c = document.getElementById('gameCanvas');
                    if (c) {
                        c.width = window.innerWidth;
                        c.height = window.innerHeight;
                    }
                    if (typeof startGameLoop === 'function') startGameLoop();
                }
            }, 10000);

            // 1. Load Map (Default)
            const mapImg = new Image();
            mapImg.onload = () => {
                console.log("Map Loaded, processing...");
                try {
                    processMap(mapImg);
                } catch (e) {
                    console.error("Critical: processMap crashed!", e);
                }
            };
            mapImg.onerror = (e) => {
                console.error("Map Load Error", e);
                // Try alternate path for debugging
            };
            mapImg.src = 'assets/platz3.png';

            // 2. Load Audio & Text (Chapter 1) -> Audio already preloaded above!
            // const mainAudioSrc = 'assets/kapitel1.mp3'; // Removed redundant def

            // Keep initial state deterministic: do not auto-play chapter audio on startup.
            // The user starts playback explicitly via play button.
            const attemptAutoPlay = () => {
                syncPlayPauseIcon();
            };

            try {
                // debugLog('Fetching kapitel1.txt...');
                const response = await fetch('assets/kapitel1.txt');
                // debugLog('Fetch response: ' + response.status);
                const text = await response.text();
                // debugLog('Text length: ' + text.length);
                window.mainTextContent = text;
                parseSubtitles(text);
                // debugLog('subtitleTracks: ' + subtitleTracks.length);
                renderSubtitleLines(0);
                // debugLog('Chapter 1 Loaded OK');

                attemptAutoPlay();
            } catch (e) {
                debugLog('Chapter 1 Load ERROR: ' + e.message);
                window.mainTextContent = "";
                subtitleTracks = [];
            }

            // 2b. Preload Lore 1 Text
            try {
                const lRes = await fetch('assets/lore1.txt');
                loreData.text[1] = await lRes.text();
                console.log("Lore 1 Loaded");
            } catch (e) {
                console.error("Lore 1 Text Load Error:", e);
                loreData.text[1] = "";
            }

            // Always show UI
            if (typeof uiContainer !== 'undefined' && uiContainer) uiContainer.style.display = 'flex';

            // 3. Load Save Game
            // Handled by generic GameState.init() called at top of script
            // if (window.electronAPI) { ... }
        });

        // Helper for manual image loading (optional debugging)
        function loadImageFile(file) {
            processingInfo.style.display = 'block';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => setTimeout(() => processMap(img), 50);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // KEYBOARD
        // ============================================
        // Toggle State
        let usePAL = true;
        let useHalftone = true;

        function updateFilterStyle() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;

            let filters = [];
            if (usePAL) filters.push('url(#pal-filter)');
            // Halftone is usually a CSS class or overlay?
            // If it's the SVG glitch:
            if (useHalftone) filters.push('url(#glitch-filter)');
            // Note: Halftone dots is often a CSS overlay DIV, not SVG filter.
            // But user said "2" -> halftone dots.
            // I'll check if there is a .halftone class.
            // If not, I'll toggle the GLITCH filter (since "Glitch=NO" was the issue).

            canvas.style.filter = filters.join(' ');

            // Also update Debug
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML = `Filters: PAL=${usePAL ? 'ON' : 'OFF'} GLITCH=${useHalftone ? 'ON' : 'OFF'}<br>CANVAS: ${canvas.style.filter}`;
            }
        }

        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
                // CRITICAL FIX: Ensure Audio Player NEVER has focus, preventing "fast forward"
                // if (audioPlayer) audioPlayer.blur();
                document.body.focus();
            }
            // TOGGLES
            if (e.key === '1') { usePAL = !usePAL; updateFilterStyle(); }
            if (e.key === '2') { useHalftone = !useHalftone; updateFilterStyle(); }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            // Tastendruck bricht Click-to-Move ab
            moveTarget = null;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Click-to-Move fÃ¼r Mobile
        function handleClickMove(screenX, screenY) {
            if (!gameReady) return;

            // Berechne Welt-Koordinaten aus Screen-Koordinaten
            const rect = canvas.getBoundingClientRect();
            // CSS-Pixel zu Canvas-Pixel Umrechnung
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;

            // Welt-Position = Canvas-Position + Kamera-Offset
            const worldX = canvasX + camX;
            const worldY = canvasY + camY;

            // Setze Ziel (Spieler-Mitte soll dort hin)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            moveTarget = {
                x: worldX - spriteW / 2,
                y: worldY - spriteH / 2
            };
        }

        canvas.addEventListener('click', e => {
            // Guard: Ignore if clicking UI buttons (propagated events)
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            handleClickMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            // Guard: Ignore if touching UI
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            e.preventDefault();
            if (e.touches.length > 0) {
                handleClickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // ============================================
        // MAP PROCESSING
        // ============================================
        // ============================================
        // MAP PROCESSING (NUCLEAR FALLBACK VERSION)
        // ============================================
        // ============================================
        // MAP PROCESSING (ADVANCED RESTORED)
        // ============================================

        // --- AUTO-WALK PATH SORTER (Pure Nearest Neighbor) ---
        // Immer den ALLERNÃ„CHSTEN Pixel. Keine Bereiche, keine Schwellen.
        function sortAutoWalkPath(pixels, startPoint) {
            if (pixels.length === 0) return [];

            const path = [];
            let pool = [...pixels];

            // 1. Startpunkt: Der Pixel, der am nÃ¤chsten zum Spawn liegt.
            let minDistSq = Infinity;
            let startIndex = -1;

            for (let i = 0; i < pool.length; i++) {
                const dx = pool[i].x - startPoint.x;
                const dy = pool[i].y - startPoint.y;
                const dSq = dx * dx + dy * dy;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    startIndex = i;
                }
            }

            if (startIndex === -1) return [];

            let current = pool.splice(startIndex, 1)[0];
            path.push(current);

            // 2. Stur: Immer den ALLERNÃ„CHSTEN noch nicht besuchten Pixel wÃ¤hlen.
            while (pool.length > 0) {
                let bestIndex = -1;
                let bestDistSq = Infinity;

                for (let i = 0; i < pool.length; i++) {
                    const dx = pool[i].x - current.x;
                    const dy = pool[i].y - current.y;
                    const dSq = dx * dx + dy * dy;

                    if (dSq < bestDistSq) {
                        bestDistSq = dSq;
                        bestIndex = i;
                    }
                }

                // Immer nehmen, egal wie weit weg.
                if (bestIndex !== -1) {
                    current = pool.splice(bestIndex, 1)[0];
                    path.push(current);
                } else {
                    break;
                }
            }

            console.log(`Auto-Walk Path (Pure Nearest): ${path.length} nodes.`);
            return path;
        }

        function processMap(img) {
            console.log("Processing Map (Advanced):", img.width, "x", img.height);
            mapW = img.width;
            mapH = img.height;

            SCREEN_W = Math.min(mapW, window.innerWidth);
            SCREEN_H = Math.min(mapH, window.innerHeight);
            canvas.width = SCREEN_W;
            canvas.height = SCREEN_H;

            // VISUAL DEBUG
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.innerText = "PROCESSING PIXELS...";
                pi.style.display = 'block';
            }

            // ATTEMPT PIXEL PROCESSING
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapW;
                tempCanvas.height = mapH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imgData = tempCtx.getImageData(0, 0, mapW, mapH);
                const data = imgData.data;

                // 1. Initialisieren der Arrays
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                foregroundData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                flowData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));

                magentaPixels = [];
                cyanPixels = new Set();
                greenPixels = [];
                greenPixels = [];
                let orangePixels = []; // For Auto-Walk
                yellowLights = []; // Init global var
                let spawnPixel = null;

                // 2. Scan-Pass
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const i = (y * mapW + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Magenta = Kollision
                        if (r > 200 && g < 80 && b > 200) {
                            collisionData[y][x] = true;
                            magentaPixels.push({ x, y, i });
                        }
                        // Cyan = Vordergrund
                        else if (r < 80 && g > 200 && b > 200) {
                            cyanPixels.add(`${x},${y}`);
                        }
                        // GrÃ¼n = Flow (Lichter)
                        else if (r < 80 && g > 200 && b < 80) {
                            flowData[y][x] = true;
                            greenPixels.push({ x, y, i });
                        }
                        // GELB = Lore Trigger (#FFFF00)
                        else if (r > 250 && g > 250 && b < 10) {
                            const id = yellowLights.length + 1;
                            yellowLights.push(new YellowLight(x, y, id));
                        }
                        // BLAU = Spawn Punkt (#0000FF)
                        else if (r < 50 && g < 50 && b > 200) {
                            if (!spawnPixel) spawnPixel = { x, y, i };
                        }
                        // ORANGE = Auto-Walk Pfad (#FFA500 -> R>240, G~165, B<50)
                        else if (r > 240 && g > 130 && g < 200 && b < 50) {
                            orangePixels.push({ x, y, i });
                        }
                    }
                }

                // 3. Flood Fill Cyan
                if (cyanPixels.size > 0) findEnclosedAreas(cyanPixels, mapW, mapH);

                // 4. Pixel Hiding (Flow, Lore, Spawn)
                // Use pullNearbyPixel to hide the debug colors

                // 5. Magenta Cleanup & Wall Dilatation (Robust Collision)
                const extraWalls = [];
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (collisionData[y][x]) {
                            if (x > 0) extraWalls.push({ x: x - 1, y: y });
                            if (x < mapW - 1) extraWalls.push({ x: x + 1, y: y });
                            if (y > 0) extraWalls.push({ x: x, y: y - 1 });
                            if (y < mapH - 1) extraWalls.push({ x: x, y: y + 1 });
                        }
                    }
                }
                for (const w of extraWalls) {
                    collisionData[w.y][w.x] = true;
                }

                // Restore Magenta Pixels visually
                for (const mp of magentaPixels) {
                    const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                    data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;
                }
                for (const gp of greenPixels) {
                    const repl = pullNearbyPixel(data, gp.x, gp.y, mapW, mapH, cyanPixels);
                    data[gp.i] = repl.r; data[gp.i + 1] = repl.g; data[gp.i + 2] = repl.b;
                }
                for (const yl of yellowLights) {
                    const i = (yl.y * mapW + yl.x) * 4;
                    const repl = pullNearbyPixel(data, yl.x, yl.y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }
                if (spawnPixel) {
                    const repl = pullNearbyPixel(data, spawnPixel.x, spawnPixel.y, mapW, mapH, cyanPixels);
                    data[spawnPixel.i] = repl.r; data[spawnPixel.i + 1] = repl.g; data[spawnPixel.i + 2] = repl.b;
                }

                // 4b. Process Auto-Walk Path
                if (orangePixels.length > 0) {
                    // Sort path starting from spawn (or map center)
                    const startRef = spawnPixel || { x: mapW / 2, y: mapH / 2 };

                    // Direct Sort (Strict 1px)
                    autoWalkPath = sortAutoWalkPath(orangePixels, startRef);
                    autoWalkIndex = 0;

                    // Hide Orange Pixels
                    for (const op of orangePixels) {
                        const repl = pullNearbyPixel(data, op.x, op.y, mapW, mapH, cyanPixels);
                        data[op.i] = repl.r; data[op.i + 1] = repl.g; data[op.i + 2] = repl.b;
                    }
                }

                // 5. Magenta Cleanup
                // Multi-pass to fill large magenta areas from outside in
                let remainingMagenta = [...magentaPixels];
                const maxPasses = 10;
                for (let pass = 0; pass < maxPasses && remainingMagenta.length > 0; pass++) {
                    const stillRemaining = [];
                    for (const mp of remainingMagenta) {
                        const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                        // If result is the fallback gray (60,55,50), it means no neighbor found yet
                        // But wait, pullNearbyPixel returns fallback if nothing found. 
                        // We need a way to know if it found something good. 
                        // For now, let's just accept the replacement. The loop is fine.
                        data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;

                        // Heuristic: If we are deep inside magenta, we might get gray. 
                        // Ideally we want to wait for neighbors. But this is fast enough.
                    }
                    remainingMagenta = []; // Assume processed (simplification for speed)
                }

                // 6. Cyan Cleanup
                for (const cp of cyanPixels) {
                    const [x, y] = cp.split(',').map(Number);
                    const i = (y * mapW + x) * 4;
                    const repl = pullNearbyPixel(data, x, y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }

                // 7. Create Foreground/Background Layers
                const bgData = new Uint8ClampedArray(data);
                const fgData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < fgData.length; i += 4) fgData[i + 3] = 0; // Clear Alpha

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (foregroundData[y][x]) {
                            const i = (y * mapW + x) * 4;
                            fgData[i] = data[i];
                            fgData[i + 1] = data[i + 1];
                            fgData[i + 2] = data[i + 2];
                            fgData[i + 3] = 255;
                        }
                    }
                }

                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = mapW; bgCanvas.height = mapH;
                bgCanvas.getContext('2d').putImageData(new ImageData(bgData, mapW, mapH), 0, 0);

                const fgCanvas = document.createElement('canvas');
                fgCanvas.width = mapW; fgCanvas.height = mapH;
                fgCanvas.getContext('2d').putImageData(new ImageData(fgData, mapW, mapH), 0, 0);

                bgImage = new Image();
                foregroundImage = new Image();

                bgImage.onload = () => {
                    gameReady = true;
                    if (document.getElementById('processingInfo')) document.getElementById('processingInfo').style.display = 'none';
                    if (document.getElementById('dropZone')) document.getElementById('dropZone').classList.add('hidden');
                    // Hide Loading Screen
                    const ls = document.getElementById('loading-screen');
                    if (ls) ls.style.display = 'none';

                    if (spawnPixel) {
                        // FIX: Blue pixel marks FOOT position, not sprite top
                        // Robust: use the same spriteH logic as checkCollisionAt

                        // 1. Update scale for spawn depth (initial guess)
                        if (mapH > 0) {
                            const yNorm = Math.max(0, Math.min(1, spawnPixel.y / mapH));
                            const depthFactor = 0.5 + (0.8 * yNorm);
                            SPRITE.scale = SPRITE.baseScale * depthFactor;
                        }

                        const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                        const FOOT_OFFSET_Y = 15; // Must match checkCollisionAt

                        player.x = spawnPixel.x - 8; // Center horizontally
                        player.y = spawnPixel.y - spriteH - FOOT_OFFSET_Y; // Feet at spawnPixel.y

                        console.log(`Spawn: Blue(${spawnPixel.x},${spawnPixel.y}) -> Feet at Y=${spawnPixel.y}, SpriteH=${spriteH.toFixed(1)}, Player.y=${player.y.toFixed(1)}`);
                    } else {
                        player.x = mapW / 2;
                        player.y = mapH / 2;
                    }

                    // Center Camera
                    camX = targetCamX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                    camY = targetCamY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));

                    // Init Extras
                    initParticles();
                    initClouds();

                    // Start Audio
                    if (typeof ambientAudio !== 'undefined') ambientAudio.play().catch(() => { });

                    startGameLoop();
                    console.log("Map Processed & Ready.");
                };
                bgImage.onerror = (e) => {
                    console.error("Processed background image failed to load", e);
                };
                foregroundImage.onerror = (e) => {
                    console.error("Processed foreground image failed to load", e);
                };
                bgImage.src = bgCanvas.toDataURL();
                foregroundImage.src = fgCanvas.toDataURL();


            } catch (e) {
                console.error("Advanced Processing Crash", e);
                // Fallback to RAW if crash
                bgImage = img;
                foregroundImage = null;
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false)); // Safe init
                gameReady = true;
                startGameLoop();
            }
        }

        // Fallback: Audio starten bei erster Interaktion, falls Autoplay blockiert wurde
        document.addEventListener('click', () => {
            if (gameReady && ambientAudio.paused) {
                ambientAudio.play().catch(e => console.warn("Ambient play failed:", e));
            }
        }, { once: true }); // Nur einmal ausfÃ¼hren

        // ============================================
        // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
        // ============================================
        let wasAmbientPlaying = false;
        let wasPlayerPlaying = false;
        window.gamePaused = false; // Flag for Game Loop

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // APP BACKGROUNDED -> PAUSE ALL
                window.gamePaused = true; // Stop loop logic

                if (typeof ambientAudio !== 'undefined' && !ambientAudio.paused) {
                    wasAmbientPlaying = true;
                    ambientAudio.pause();
                } else {
                    wasAmbientPlaying = false;
                }

                if (typeof audioPlayer !== 'undefined' && !audioPlayer.paused) {
                    wasPlayerPlaying = true;
                    audioPlayer.pause();
                } else {
                    wasPlayerPlaying = false;
                }

                if (typeof footstepSound !== 'undefined') footstepSound.pause();

            } else {
                // APP FOREGROUND -> RESUME IF WAS PLAYING
                // Reset time to prevent delta spikes
                lastTime = 0;
                window.gamePaused = false;

                setTimeout(() => {
                    if (wasAmbientPlaying && typeof ambientAudio !== 'undefined') {
                        ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                    }
                    if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                        audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                    }
                }, 100);
            }
        });

        function findSafeStart() {
            // Suche ausgehend von der Mitte nach einer Position ohne Kollision
            const startX = Math.floor(mapW / 2);
            const startY = Math.floor(mapH / 2);

            for (let radius = 0; radius < 100; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < mapW - 16 && y >= 0 && y < mapH - 16) {
                            if (!checkCollisionAt(x, y)) {
                                player.x = x;
                                player.y = y;
                                return;
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // FLOOD FILL MIT DILATATION
        // ============================================
        function findEnclosedAreas(cyanPixels, w, h) {
            const visited = new Array(h).fill(null).map(() => new Array(w).fill(0));

            // Dilatation der Cyan-Grenzen
            const dilationRadius = 2;
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                    for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) <= dilationRadius) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                visited[ny][nx] = 2;
                            }
                        }
                    }
                }
            }

            // Flood Fill vom Rand
            const queue = [];
            for (let x = 0; x < w; x++) {
                if (visited[0][x] === 0) queue.push([x, 0]);
                if (visited[h - 1][x] === 0) queue.push([x, h - 1]);
            }
            for (let y = 0; y < h; y++) {
                if (visited[y][0] === 0) queue.push([0, y]);
                if (visited[y][w - 1] === 0) queue.push([w - 1, y]);
            }

            let idx = 0;
            while (idx < queue.length) {
                const [x, y] = queue[idx++];
                if (x < 0 || x >= w || y < 0 || y >= h || visited[y][x] !== 0) continue;
                visited[y][x] = 1;
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Innere Bereiche markieren
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (visited[y][x] === 0 || visited[y][x] === 2) {
                        foregroundData[y][x] = true;
                    }
                }
            }

            // Original Cyan-Pixel auch markieren
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                foregroundData[y][x] = true;
            }
        }

        // ============================================
        // PIXEL-PULLING (SpiralfÃ¶rmige Suche fÃ¼r alle Linienrichtungen)
        // ============================================
        function pullNearbyPixel(data, x, y, w, h, cyanPixels) {
            // SpiralfÃ¶rmige Suche: Sucht in expandierenden Kreisen
            // Funktioniert fÃ¼r horizontale, vertikale UND diagonale Linien
            const maxRadius = 15;  // Maximaler Suchradius

            for (let radius = 1; radius <= maxRadius; radius++) {
                // Alle Punkte auf dem aktuellen "Quadrat-Ring" durchsuchen
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        // Nur Randpunkte des Quadrats (nicht innere)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                        const ni = (ny * w + nx) * 4;
                        const r = data[ni], g = data[ni + 1], b = data[ni + 2];

                        // Skip Magenta (Kollision) und Cyan (Vordergrund)
                        if (r > 200 && g < 80 && b > 200) continue;
                        if (r < 80 && g > 200 && b > 200) continue;
                        if (cyanPixels.has(`${nx},${ny}`)) continue;

                        // GÃ¼ltiges Pixel gefunden!
                        return { r, g, b };
                    }
                }
            }

            // Fallback: Neutrales Grau-Braun (passt zu den meisten Umgebungen)
            return { r: 60, g: 55, b: 50 };
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function startGameLoop() {
            if (window.gameLoopRunning) return;
            window.gameLoopRunning = true;
            lastTime = 0;
            console.log("startGameLoop");
            requestAnimationFrame(gameLoop);
        }

        // Global vars for timing
        let lastTime = 0;

        function gameLoop(timestamp) {
            if (window.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Clamp DT to prevent speed spikes (e.g. after lag/pause)
            if (dt > 0.1) dt = 0.1;

            // Cap delta time (prevent spirals of death)
            if (dt > 0.1) dt = 0.1;

            // Update Game Logic
            update(dt);
            updateLoreSystem(); // Lore-Proximity prÃ¼fen

            // Draw
            draw();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // UPDATE - MIT ROBUSTER KOLLISION
        // ============================================
        function update(dt) {
            if (!dt) dt = 0.016;
            if (!gameReady) return;

            // --- DYNAMIC SCALING (Depth Effect) ---
            if (mapH > 0) {
                // Normalisierte Y-Position (0.0 oben bis 1.0 unten)
                const yNorm = Math.max(0, Math.min(1, player.y / mapH));

                // Skalierung: 50% (oben) bis 130% (unten)
                // Formel: 0.5 + (0.8 * yNorm) -> 
                // yNorm=0 -> 0.5 | yNorm=1 -> 1.3
                const depthFactor = 0.5 + (0.8 * yNorm);

                SPRITE.scale = SPRITE.baseScale * depthFactor;
            }

            let dx = 0, dy = 0;
            player.isMoving = false;

            // Input von Tastatur
            if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) { dy = -1; player.dir = 1; }
            if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) { dy = 1; player.dir = 0; }
            if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) { dx = -1; player.dir = 2; }
            if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) { dx = 1; player.dir = 3; }

            // Click-to-Move: Wenn kein Tastatur-Input und Ziel gesetzt
            // Fix: Movement allowed during Lore (unless Reading Mode active)
            if (dx === 0 && dy === 0 && moveTarget && !isReadingMode) {
                const tdx = moveTarget.x - player.x;
                const tdy = moveTarget.y - player.y;
                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Ziel erreicht? (innerhalb von 3px)
                if (tdist < 3) {
                    moveTarget = null;
                } else {
                    // Richtung zum Ziel
                    dx = tdx / tdist;
                    dy = tdy / tdist;

                    // Blickrichtung setzen
                    if (Math.abs(tdx) > Math.abs(tdy)) {
                        player.dir = tdx > 0 ? 3 : 2; // Rechts oder Links
                    } else {
                        player.dir = tdy > 0 ? 0 : 1; // Unten oder Oben
                    }
                }
            }

            // --- AUTO-WALK (READING MODE & COASTDOWN) ---
            if ((isReadingMode || (player.slowdownTimer > 0)) && autoWalkPath.length > 0) {
                // Initialize Slowdown Timer
                if (isReadingMode) {
                    player.slowdownTimer = 1.0; // 1 Second Coastdown buffer (float seconds now)
                } else {
                    player.slowdownTimer -= dt;
                }

                // Calculate Foot Position
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const footX = player.x + spriteW / 2;
                const footY = player.y + spriteH + 15;

                // Target logic
                let target = autoWalkPath[autoWalkIndex];
                const tdx = target.x - footX;
                const tdy = target.y - footY;
                const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Speed Calculation (Linked to player.speed)
                let walkSpeed = player.speed;
                if (!isReadingMode) {
                    // Coastdown Fade
                    walkSpeed *= Math.max(0, player.slowdownTimer);
                }
                const step = walkSpeed * dt;

                if (dist < 4) {
                    autoWalkIndex++;
                    if (autoWalkIndex >= autoWalkPath.length) {
                        autoWalkIndex = autoWalkPath.length - 1;
                        if (!isReadingMode) player.slowdownTimer = 0;
                    }
                }

                if (autoWalkIndex < autoWalkPath.length && player.slowdownTimer > 0) {
                    const nextTdx = target.x - footX;
                    const nextTdy = target.y - footY;
                    const nextDist = Math.sqrt(nextTdx * nextTdx + nextTdy * nextTdy);

                    if (nextDist > 1) {
                        const dx = (nextTdx / nextDist) * step;
                        const dy = (nextTdy / nextDist) * step;

                        player.x += dx;
                        player.y += dy;
                        player.isMoving = true;

                        // Direction
                        if (Math.abs(nextTdx) > Math.abs(nextTdy)) {
                            player.dir = nextTdx > 0 ? 3 : 2;
                        } else {
                            player.dir = nextTdy > 0 ? 0 : 1;
                        }

                        // Animation
                        player.animTimer += dt;

                        // 50% Slower Animation for Front (0) and Back (1) views

                        // 50% Slower Animation for Front/Back (0.30s vs 0.15s)
                        let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                        if (player.animTimer > animThreshold) {
                            player.animTimer = 0;
                            player.frame = (player.frame + 1) % 12;
                        }
                    }
                }
            }

            // --- MANUAL MOVEMENT ---
            if (dx !== 0 || dy !== 0) {
                player.isMoving = true;

                // Normalisieren (Diagonal Fix)
                if ((keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) && Math.abs(dx) === 1 && Math.abs(dy) === 1) {
                    const inv = 0.7071;
                    dx *= inv; dy *= inv;
                }

                // Apply Movement
                let moveSpeed = player.speed;
                if (isReadingMode) {
                    moveSpeed = player.speed * 0.175; // 50% of 35% = 17.5% (User Request: even slower)
                }

                // LOG SPEED for Debug (Throttle)
                if (player.isMoving && Math.random() < 0.01) {
                    console.log(`[DEBUG_SYS] Player Move Speed: Base=${player.speed}, Actual=${moveSpeed} (Mode=${isReadingMode ? 'READING' : 'GAME'})`);
                }

                const amount = moveSpeed * dt;

                // Collision Logic (restore if missing or use simplified slide)
                const vx = dx * amount;
                const vy = dy * amount;
                const targetX = player.x + vx;
                const targetY = player.y + vy;

                // Simple Slide or Full Collision
                // Assuming checkCollisionAt is available
                if (!checkCollisionAt(targetX, targetY)) {
                    player.x = targetX;
                    player.y = targetY;
                } else {
                    if (!checkCollisionAt(targetX, player.y)) player.x = targetX;
                    else if (!checkCollisionAt(player.x, targetY)) player.y = targetY;
                }

                // Animation
                player.animTimer += dt;
                // 50% Slower Animation for Front/Back
                let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                if (player.animTimer > animThreshold) {
                    player.animTimer = 0;
                    player.frame = (player.frame + 1) % 12;
                }
            }

            // Handle Animation & Sound for Movement
            if (player.isMoving) {
                // Initial Footstep
                if (audioUnlocked && !footstepPlaying) {
                    footstepSound.play().catch(() => { });
                    footstepPlaying = true;
                }

                // Dust Particles
                if (Math.random() > 0.9) { // Reduced freq for dt loop
                    const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                    const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                    const offsetY = Math.floor(spriteH * 0.22);
                    const shiftY = Math.floor(spriteH / 3) - 4;
                    const anchorY = player.y + spriteH + offsetY + shiftY;

                    dustParticles.push({
                        x: player.x + spriteW / 2 + (Math.random() - 0.5) * 6,
                        y: anchorY - 15 + (Math.random() - 0.5) * 2,
                        vx: (Math.random() - 0.5) * 10,  // px/sec (no dt at spawn)
                        vy: -Math.random() * 10,
                        life: 1.0,
                        size: 2 + Math.random() * 2
                    });
                }
            } else {
                // Stop Sound
                player.frame = 1; // Stand
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
            }

            // Update Dust
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const d = dustParticles[i];
                d.x += d.vx * dt;  // Frame-rate independent
                d.y += d.vy * dt;
                d.life -= 2.5 * dt;
                if (d.life <= 0) dustParticles.splice(i, 1);
            }

            // Map Bounds (with sprite size and foot offset)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const FOOT_OFFSET_Y = 15;
                player.x = Math.max(0, Math.min(player.x, mapW - spriteW));
                player.y = Math.max(0, Math.min(player.y, mapH - spriteH - FOOT_OFFSET_Y));
            }

            // Foreground Check
            player.isBehindForeground = checkForeground(player.x, player.y);

            // Smooth Camera (Time-based)
            targetCamX = player.x - SCREEN_W / 2 + 10;
            targetCamY = player.y - SCREEN_H * 0.30 + 10;
            targetCamX = Math.max(0, Math.min(targetCamX, Math.max(0, mapW - SCREEN_W)));
            targetCamY = Math.max(0, Math.min(targetCamY, Math.max(0, mapH - SCREEN_H)));

            camX += (targetCamX - camX) * 5.0 * dt;
            camY += (targetCamY - camY) * 5.0 * dt;

            // Update Particles
            nearbyLights = [];
            for (const p of particles) p.update(dt); // Ensure particle update accepts dt (or add it)
            for (const c of clouds) c.update(dt);
        }

        // ============================================
        // KOLLISIONSPRÃœFUNG - ROBUST (Ecken-Check)
        // ============================================
        function checkCollisionAt(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            // Definition der FuÃŸ-Kollisionsbox relative zum Sprite-Ursprung (px, py)
            // Sprite ist ca 16x20. FÃ¼ÃŸe sind unten.
            // Wir definieren eine schmale Box mittig unten.

            const boxWidth = 8; // Schmaler als Sprite (damit man nicht an Ecken hÃ¤ngen bleibt)
            const boxHeight = 6;

            const centerX = px + spriteW / 2;
            const bottomY = py + spriteH + 15; // +15 wie bisher (visueller Offset)

            // PrÃ¼fpunkte:
            // 1. Unten Links
            // 2. Unten Rechts
            // (Optional auch Oben, wenn man eine tiefe Box hat, aber fÃ¼r RPG reicht meist eine 'Grundlinie')

            const left = Math.floor(centerX - boxWidth / 2);
            const right = Math.floor(centerX + boxWidth / 2);
            const yFn = Math.floor(bottomY);

            // PrÃ¼fe beide Ecken
            if (isSolid(left, yFn)) return true;
            if (isSolid(right, yFn)) return true;

            return false;
        }

        function isSolid(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true; // Map-Rand ist Wand
            if (collisionData[y][x]) return true;
            return false;
        }

        function checkForeground(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const cx = Math.floor(px + spriteW / 2);
            const cy = Math.floor(py + spriteH / 2);

            if (foregroundData && foregroundData[cy] && cy >= 0 && cy < mapH && cx >= 0 && cx < mapW) {
                return foregroundData[cy][cx];
            }
            return false;
        }

        // ============================================
        // DRAWING
        // ============================================
        function draw() {
            // LCD Ghosting: Vorherigen Frame mit Transparenz beibehalten
            // Disable Ghosting
            // ctx.save(); ... ctx.restore();

            // Clear Canvas fully every frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameReady) return;

            ctx.save();
            // Screen-Shake anwenden
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            // SMOOTH CAMERA: Use sub-pixel values (remove Math.floor)
            ctx.translate(-camX + shakeX, -camY + shakeY);

            screenShake *= 0.8; // Schnell abklingen

            // Hintergrund
            if (bgImage) ctx.drawImage(bgImage, 0, 0);

            // Partikel (Additives Leuchten)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) p.draw(ctx, camX, camY);
            ctx.restore();

            // Gelbe Lore-Lichter zeichnen
            for (const light of yellowLights) {
                light.draw(ctx);

                // Beleuchtung hinzufÃ¼gen wenn aktiv!
                if (activeLightSourceId === light.id && isLoreMode) {
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = light.x - px;
                    const ddy = light.y - py;
                    const dist = Math.sqrt(ddx * ddx + ddy * ddy);
                    nearbyLights.push({
                        x: light.x,
                        y: light.y,
                        dist: dist,
                        life: 1.0,
                        isYellow: true
                    });
                }
            }

            // Spieler-Schatten (diffuse Ellipse unter den FÃ¼ÃŸen)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

                // Offsets identisch zu drawPlayer berechnen
                const offsetY = Math.floor(spriteH * 0.22);
                const shiftY = Math.floor(spriteH / 3) - 4;
                const totalYOffset = offsetY + shiftY;

                // Schatten-Position: exakt unter den FÃ¼ÃŸen des Sprites
                const shadowCenterX = player.x + spriteW / 2;
                const shadowCenterY = player.y + totalYOffset + spriteH - 15; // Korrigiert

                // Schatten-GrÃ¶ÃŸe: klein und diffus
                const shadowWidth = spriteW * 0.4;
                const shadowHeight = 3;

                // Schatten-Deckkraft
                let shadowAlpha = 0.35;

                if (nearbyLights.length > 0) {
                    const light = nearbyLights[0];
                    const distFactor = 1 - (light.dist / 35);
                    shadowAlpha = 0.25 + distFactor * 0.15;
                }

                // Diffuser Schatten mit radialem Gradient
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    shadowCenterX, shadowCenterY, 0,
                    shadowCenterX, shadowCenterY, shadowWidth
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
                gradient.addColorStop(0.5, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(shadowCenterX, shadowCenterY, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Spieler NORMAL zeichnen (keine Transparenz!)
            drawPlayer(ctx, player.x, player.y, player.dir, player.frame);

            // DEBUG: Fadenkreuz an FuÃŸ-Position (nur im Reading Mode)
            if (isReadingMode && player.debugFootX !== undefined) {
                const fx = player.debugFootX;
                const fy = player.debugFootY;
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1;
                // Horizontale Linie
                ctx.beginPath();
                ctx.moveTo(fx - 8, fy);
                ctx.lineTo(fx + 8, fy);
                ctx.stroke();
                // Vertikale Linie
                ctx.beginPath();
                ctx.moveTo(fx, fy - 8);
                ctx.lineTo(fx, fy + 8);
                ctx.stroke();
                // Kreis
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Beleuchtung: Direktional mit Gradient
            if (nearbyLights.length > 0) {
                nearbyLights.sort((a, b) => a.dist - b.dist);

                const maxRadius = 65; // ErhÃ¶ht (war 35) fÃ¼r weichere ÃœbergÃ¤nge
                let totalIntensity = 0;
                let avgDx = 0, avgDy = 0;
                let useYellow = false;

                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const spriteW = coords.w;
                const spriteH = coords.h;
                const playerCX = coords.x + spriteW / 2;
                const playerCY = coords.y + spriteH / 2;

                const numLights = Math.min(2, nearbyLights.length);
                for (let i = 0; i < numLights; i++) {
                    const light = nearbyLights[i];
                    if (light.isYellow) useYellow = true;

                    // Distanz-Modulation: 0% am Rand, 100% direkt am Spieler
                    const distFactor = (1 - (light.dist / maxRadius));
                    // Gelbes Licht etwas intensiver
                    const intensity = distFactor * light.life * (light.isYellow ? 1.5 : 1.0);
                    totalIntensity += intensity * 0.4; // Subtiler (war 0.6)

                    // Richtung vom Licht zum Spieler (normalisiert)
                    const dx = playerCX - light.x;
                    const dy = playerCY - light.y;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    avgDx += (dx / len) * intensity;
                    avgDy += (dy / len) * intensity;
                }

                // Max 50% Aufhellung (subtiler Effekt), Gelb darf etwas heller sein (70%)
                totalIntensity = Math.min(useYellow ? 0.7 : 0.5, totalIntensity);

                if (totalIntensity > 0.02) {
                    // Normalisiere Durchschnittsrichtung
                    const dirLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy) || 1;
                    const ndx = avgDx / dirLen;
                    const ndy = avgDy / dirLen;

                    // OffScreen-Canvas fÃ¼r Gradient-Beleuchtung
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = spriteW;
                    lightCanvas.height = spriteH;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Zeichne Sprite exakt so wie es auf dem Hauptcanvas erscheint, aber relativ zu (0,0)
                    lightCtx.save();
                    lightCtx.translate(-coords.x, -coords.y);
                    drawPlayer(lightCtx, player.x, player.y, player.dir, player.frame);
                    lightCtx.restore();

                    // GleichmÃ¤ÃŸigere Beleuchtung (statt harter Gradient)
                    // Wir fÃ¼llen das Sprite fast gleichmÃ¤ÃŸig auf (mit sehr weichem Rand-Ausfall)
                    const r = useYellow ? 255 : 255;
                    const g = useYellow ? 220 : 255;
                    const b = useYellow ? 50 : 255;

                    lightCtx.globalCompositeOperation = 'source-in';
                    // Fast gleichmÃ¤ÃŸige FÃ¼llung basierend auf IntensitÃ¤t
                    lightCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.8})`;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Ein ganz dezenter Gradient fÃ¼r DreidimensionalitÃ¤t
                    const rad = Math.max(spriteW, spriteH) * 2;
                    const gradient = lightCtx.createRadialGradient(
                        spriteW / 2 + ndx * (spriteW / 2),
                        spriteH / 2 + ndy * (spriteH / 2),
                        0,
                        spriteW / 2,
                        spriteH / 2,
                        rad
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    lightCtx.fillStyle = gradient;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Zeichne beleuchtetes Sprite an die berechnete Sprite-Position
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(lightCanvas, coords.x, coords.y);
                    ctx.restore();
                }
            }

            // Dust-Particles zeichnen
            ctx.save();
            for (const d of dustParticles) {
                ctx.globalAlpha = d.life * 0.4;
                ctx.fillStyle = '#a89070';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Vordergrund
            if (foregroundImage) ctx.drawImage(foregroundImage, 0, 0);

            // Graue Silhouette IMMER berechnen (Pixel-genaues Masking)
            if (foregroundImage && spriteReady) {
                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const px = coords.x;
                const py = coords.y;
                const dw = coords.w;
                const dh = coords.h;

                // OffScreen-Canvas fÃ¼r Masking
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = dw + 4;
                maskCanvas.height = dh + 4;
                const maskCtx = maskCanvas.getContext('2d');

                // 1. Zeichne den Foreground-Ausschnitt Ã¼ber dem Spieler
                maskCtx.drawImage(foregroundImage,
                    px - 2, py - 2, dw + 4, dh + 4,
                    0, 0, dw + 4, dh + 4);

                // 2. Source-In: Nur wo Foreground-Pixel existieren
                maskCtx.globalCompositeOperation = 'source-in';

                // 3. Zeichne graues Sprite
                const graySprite = createGraySpriteCanvas();
                if (graySprite) {
                    maskCtx.drawImage(graySprite, 2, 2);
                }

                // 4. Zeichne das Ergebnis
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(maskCanvas, px - 2, py - 2);
                ctx.restore();
            }

            // Wolken-Layer (Parallax, Ã¼ber allem)
            for (const c of clouds) c.draw(ctx, camX, camY);

            ctx.restore();
        }

        // NEU: Hilfsfunktion fÃ¼r konsistente Koordinatenberechnung
        // iOS Detection
        // const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent); // REMOVED DUPLICATE

        function getPlayerDrawCoords(x, y, dir, frame) {
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;
            const flipX = (dir === 3);

            let result = {};

            // FRONT (Marker-basiert, 6-Step)
            if (dir === 0) {
                const cycleIdx = frame % 6;
                const frameIdx = FRONT_ANIM_CYCLE[cycleIdx];
                const data = FRONT_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteFront.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteFront.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // BACK (NEU: Marker-basiert, 4-Step Cycle)
            else if (dir === 1) {
                const cycleIdx = frame % 4;
                const frameIdx = BACK_ANIM_CYCLE[cycleIdx];
                const data = BACK_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteBack.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteBack.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // SIDE (Marker-basiert, 6-Step Ping-Pong)
            else if (dir === 2 || dir === 3) {
                const cycleIdx = frame % 6;
                const frameIdx = SIDE_ANIM_CYCLE[cycleIdx];
                const data = SIDE_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = 175;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteSide.height * SPRITE.scale);

                let dx;
                if (flipX) {
                    // Gespiegelt: Ankerpunkt (x + refW/2) ist die Achse.
                    // Die linke Kante ist (Anker + verschobener_Anker) - Breite
                    dx = (x + refW / 2 + footRelX * SPRITE.scale) - dw;
                } else {
                    dx = x + refW / 2 - footRelX * SPRITE.scale;
                }
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: true, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteSide.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: flipX
                };
            } else {
                let sprite = (dir === 1) ? (spriteBack || spriteFront) : spriteFront;
                const sw = Math.floor(sprite.width / SPRITE.cols);
                const sh = sprite.height;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(sh * SPRITE.scale);
                const offsetY = Math.floor(dh * 0.22);

                const frameIdx = frame % 4;
                const sx = frameIdx * sw;

                const finalX = x;
                const finalY = y + offsetY + visualShiftY;
                result = {
                    x: finalX, y: finalY, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: sx, sw: sw, sh: sh,
                    flipX: false
                };
            }

            // iOS FIX: Force integer coordinates to prevent sub-pixel "wobble"
            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                result.x = Math.floor(result.x);
                result.y = Math.floor(result.y);
            }
            return result;
        }

        // ============================================
        // SPIELER SPRITE ZEICHNEN
        // ============================================
        function drawPlayer(ctx, x, y, dir, frame) {
            if (!spriteReady) return;

            const coords = getPlayerDrawCoords(x, y, dir, frame);
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;

            ctx.save();
            let sprite;
            if (dir === 0) sprite = spriteFront;
            else if (dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            // DEBUG-DOT an der FuÃŸ-Koordinate
            if (window.debugFoot) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + refW / 2, y + refH + visualShiftY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(x + refW / 2 - 2, y + refH + visualShiftY - 2, 4, 4);
                ctx.restore();
            }

            if (coords.isSide && coords.flipX) {
                // Spiegeln: Translate zur EXAKT berechneten linken Kante + Breite
                ctx.translate(coords.x + coords.w, coords.y);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            } else {
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, coords.x, coords.y, coords.w, coords.h);
            }

            ctx.restore();
        }

        window.debugFoot = false;

        // Erstellt ein einfarbig graues Sprite-Canvas
        function createGraySpriteCanvas() {
            if (!spriteReady) return null;

            const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
            const flipX = (player.dir === 3);

            let sprite;
            if (player.dir === 0) sprite = spriteFront;
            else if (player.dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            const c = document.createElement('canvas');
            c.width = coords.w;
            c.height = coords.h;
            const gc = c.getContext('2d');

            if (coords.isSide && flipX) {
                gc.translate(coords.w, 0);
                gc.scale(-1, 1);
            }
            gc.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);

            gc.globalCompositeOperation = 'source-in';
            gc.fillStyle = 'rgb(180, 180, 180)';
            gc.fillRect(0, 0, coords.w, coords.h);

            return c;
        }

        function drawPlayerOutline(ctx, x, y) {
            if (!spriteReady || !spriteFront) return;

            const dir = player.dir;
            let sprite;
            let flipX = false;

            switch (dir) {
                case 0: sprite = spriteFront; break;
                case 1: sprite = spriteBack || spriteFront; break;
                case 2: sprite = spriteSide || spriteFront; break;
                case 3: sprite = spriteSide || spriteFront; flipX = true; break;
                default: sprite = spriteFront;
            }

            const spriteW = Math.floor(sprite.width / SPRITE.cols);
            const spriteH = sprite.height;
            const drawW = Math.floor(spriteW * SPRITE.scale);
            const drawH = Math.floor(spriteH * SPRITE.scale);
            const frame = player.frame % SPRITE.cols;

            // Erstelle OffScreen-Canvas fÃ¼r einfarbige Silhouette
            const offCanvas = document.createElement('canvas');
            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');

            // Zeichne Sprite ins OffScreen-Canvas
            if (flipX) {
                offCtx.translate(drawW, 0);
                offCtx.scale(-1, 1);
            }
            offCtx.drawImage(sprite, frame * spriteW, 0, spriteW, spriteH, 0, 0, drawW, drawH);

            // Wandle alle sichtbaren Pixel in einheitliches Grau
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = 'rgb(200, 200, 200)'; // Helles Grau
            offCtx.fillRect(0, 0, drawW, drawH);

            // Zeichne die graue Silhouette halbtransparent
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(offCanvas, Math.floor(x), Math.floor(y));
            ctx.restore();
        }

        // AUDIO & SUBTITLE SYSTEM
        // ============================================

        // SoundCloud Audio Player via Widget API
        const audioPlayer = new SCAudioAdapter();
        console.log('[Audio] Created SCAudioAdapter for main audio');
        let subtitleTracks = []; // Array aus { time: sekunden, text: string }
        let currentSubtitleIndex = -1;
        let isReadingMode = false;

        const uiContainer = document.getElementById('audioPlayerUI');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const audioControlsEl = document.getElementById('audioControls');
        const playBtn = document.getElementById('audioToggleBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipForwardBtn = document.getElementById('skipForwardBtn');
        const readingModeBtn = document.getElementById('readingModeBtn');
        const gameModeBtn = document.getElementById('gameModeBtn');
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const iconFsEnter = document.getElementById('iconFsEnter');
        const iconFsExit = document.getElementById('iconFsExit');

        function syncPlayPauseIcon() {
            const isPaused = !audioPlayer || audioPlayer.paused;
            iconPlay.style.display = isPaused ? 'block' : 'none';
            iconPause.style.display = isPaused ? 'none' : 'block';
        }

        audioPlayer.addEventListener('play', syncPlayPauseIcon);
        audioPlayer.addEventListener('pause', syncPlayPauseIcon);
        audioPlayer.addEventListener('ended', syncPlayPauseIcon);
        audioPlayer.addEventListener('canplay', syncPlayPauseIcon);
        syncPlayPauseIcon();

        // FORCE REMOVE FOCUS FROM BUTTONS
        // This prevents the "Orange Box" from appearing when using arrow keys after clicking a button
        document.querySelectorAll('button').forEach(btn => {
            // Option 1: Blur on click
            btn.addEventListener('click', () => {
                btn.blur();
                window.focus();
            });
            // Option 2: Build wall against focus
            btn.addEventListener('focus', () => {
                btn.blur();
            });
            // Option 3: Prevent default on mousedown (stops focus, keeps click)
            btn.addEventListener('mousedown', (e) => {
                if (document.activeElement !== btn) {
                    e.preventDefault();
                }
            });
        });

        // Ambient und Schritte Audio via SC Adapter
        const ambientAudio = new SCAudioAdapter();
        ambientAudio.src = getSCUrl('assets/medieval_town.mp3');
        ambientAudio.volume = 0.02;

        const footstepsAudio = new SCAudioAdapter();
        footstepsAudio.src = getSCUrl('assets/footsteps.mp3');
        footstepsAudio.volume = 0.02;
        console.log('[Audio] Created SCAudioAdapters for ambient and footsteps');

        // Berechne die Anzahl sichtbarer Zeilen basierend auf BildschirmhÃ¶he
        function getMaxVisibleLines() {
            if (!isReadingMode) return 3;
            const lineHeight = 28; // UngefÃ¤hre ZeilenhÃ¶he in px
            const availableHeight = window.innerHeight * 0.6; // 60% der BildschirmhÃ¶he
            return Math.min(15, Math.max(5, Math.floor(availableHeight / lineHeight)));
        }

        // Custom Smooth Scroll with Variable Duration (1s-3s based on distance)
        // No jumping - always smooth glide
        let currentScrollAnimation = null;
        function smoothScrollToElement(container, targetEl) {
            if (!container || !targetEl) return;

            // Cancel any existing animation
            if (currentScrollAnimation) {
                cancelAnimationFrame(currentScrollAnimation);
                currentScrollAnimation = null;
            }

            const startY = container.scrollTop;

            // Calculate Target Y to center the element
            const relativeTop = targetEl.offsetTop;
            const targetY = relativeTop - (container.clientHeight / 2) + (targetEl.clientHeight / 2);

            const distance = Math.abs(targetY - startY);

            // Skip if already very close (within 5px)
            if (distance < 5) return;

            // Dynamic Duration: 1s (near) to 3s (far)
            // "Near" = within 200px, "Far" = 1000px+
            let duration = 1000; // Base 1s
            if (distance > 200) {
                // Scale from 1s to 3s between 200px and 1000px
                const extraDist = Math.min(800, distance - 200);
                duration = 1000 + (extraDist / 800) * 2000;
            }
            duration = Math.min(3000, duration); // Cap at 3s

            console.log(`[SmoothScroll] Dist=${distance.toFixed(0)}px -> Duration=${duration.toFixed(0)}ms`);

            const startTime = performance.now();

            // Easing function for smooth deceleration
            const easeOutQuad = (t) => t * (2 - t);

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                if (elapsed >= duration) {
                    container.scrollTop = targetY; // Snap to final
                    currentScrollAnimation = null;
                    return;
                }

                const progress = elapsed / duration;
                const eased = easeOutQuad(progress);

                container.scrollTop = startY + (targetY - startY) * eased;

                currentScrollAnimation = requestAnimationFrame(animate);
            };

            currentScrollAnimation = requestAnimationFrame(animate);
        }

        // Generiert die Untertitel-Zeilen dynamisch
        function renderSubtitleLines(centerIndex) {
            // A) Reading Mode: Rendere ALLE Zeilen (fÃ¼r Scrollbar)
            if (isReadingMode) {
                // Version Check: Ensure we are rendering the current set of subtitles
                const currentVersion = window.subtitleVersion || 0;
                const renderedVersion = parseInt(subtitleContainer.dataset.version || '-1');

                // Nur neu bauen, wenn Anzahl nicht stimmt ODER Version anders ist
                if (subtitleContainer.children.length !== subtitleTracks.length || renderedVersion !== currentVersion) {
                    subtitleContainer.innerHTML = '';
                    subtitleContainer.dataset.version = currentVersion;

                    subtitleTracks.forEach((track, i) => {
                        const div = document.createElement('div');
                        div.className = 'subtitle-line';
                        div.innerText = track.text;
                        div.dataset.index = i;

                        // Click to Seek
                        div.title = "Klicken zum Springen";
                        div.style.cursor = "pointer";
                        div.addEventListener('click', (e) => {
                            if (subtitleContainer.dataset.wasDragging === 'true') {
                                console.log("Click ignored due to drag");
                                return;
                            }
                            console.log(`Seek to ${track.time}s`);
                            audioPlayer.currentTime = track.time;
                            updateSubtitleDisplay(i);
                            // Smooth scroll to clicked element
                            smoothScrollToElement(subtitleContainer, div);
                        });

                        subtitleContainer.appendChild(div);
                    });
                }

                // Highlighting aktualisieren
                const oldActive = subtitleContainer.querySelector('.subtitle-current');
                if (oldActive) oldActive.classList.remove('subtitle-current');

                // Ensure centerIndex is valid
                const safeIndex = centerIndex < 0 ? 0 : centerIndex;

                if (subtitleContainer.children.length > safeIndex) {
                    const activeEl = subtitleContainer.children[safeIndex];
                    activeEl.classList.add('subtitle-current');

                    // Auto-Scroll only if user is NOT actively dragging AND audio is playing
                    // Uses custom smooth scroll with variable duration (1-3s)
                    const isPlaying = !audioPlayer.paused;
                    if (subtitleContainer.dataset.isDragging !== 'true' && isPlaying) {
                        smoothScrollToElement(subtitleContainer, activeEl);
                    }
                }
                return;
            }

            // B) Game Mode: Nur kleines Fenster rendern (3 Zeilen)
            subtitleContainer.innerHTML = '';

            if (subtitleTracks.length === 0) {
                const div = document.createElement('div');
                div.className = 'subtitle-line subtitle-current';
                div.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(div);
                return;
            }

            // Fixe 3 Zeilen im Spielmodus
            const startIdx = Math.max(0, centerIndex - 1);
            const endIdx = Math.min(subtitleTracks.length - 1, centerIndex + 1);

            for (let i = startIdx; i <= endIdx; i++) {
                const div = document.createElement('div');
                div.className = 'subtitle-line';

                const distance = Math.abs(i - centerIndex);

                if (i === centerIndex) {
                    div.classList.add('subtitle-current');
                } else {
                    // Verblassen
                    if (distance >= 5) div.classList.add('fade-far');
                    else if (distance >= 3) div.classList.add('fade-mid');
                }

                div.innerText = subtitleTracks[i].text;
                subtitleContainer.appendChild(div);
            }
        }



        // 2. Parser fÃ¼r Timestamps - CORRECTLY distinguishes between formats:
        // [hh:mm:ss] - Colon before third part means SECONDS (kapitel1.txt uses [00:mm:ss])
        // [mm:ss.xx] - Dot before third part means CENTISECONDS (lore format)
        function parseSubtitles(rawText) {
            subtitleTracks = [];
            currentSubtitleIndex = -1;
            const lines = rawText.split('\n');

            // Capture the separator character to distinguish formats:
            // Group 1: first number
            // Group 2: second number  
            // Group 3: separator (: or .) - captured separately!
            // Group 4: third number if exists
            // Group 5: text
            const timeReg = /^\[(\d{1,2}):(\d{2})([:.])(\d{1,2}(?:\.\d+)?)\]\s*(.*)|\[(\d{1,2}):(\d{2})\]\s*(.*)/;

            let matchCount = 0;
            lines.forEach((line, idx) => {
                const match = line.match(timeReg);
                if (match) {
                    matchCount++;
                    let totalSeconds;
                    let text;

                    if (match[1] !== undefined) {
                        // Three-part format: [xx:xx:xx] or [xx:xx.xx]
                        const first = parseFloat(match[1]);
                        const second = parseFloat(match[2]);
                        const separator = match[3]; // ':' or '.'
                        const third = parseFloat(match[4]);
                        text = match[5] ? match[5].trim() : '';

                        if (separator === ':') {
                            // [hh:mm:ss] format - third part is SECONDS
                            totalSeconds = first * 3600 + second * 60 + third;
                        } else {
                            // [mm:ss.xx] format - third part is CENTISECONDS
                            totalSeconds = first * 60 + second + (third / 100);
                        }
                    } else {
                        // Two-part format: [mm:ss]
                        const first = parseFloat(match[6]);
                        const second = parseFloat(match[7]);
                        text = match[8] ? match[8].trim() : '';
                        totalSeconds = first * 60 + second;
                    }

                    if (text && text.length > 0) {
                        subtitleTracks.push({
                            time: totalSeconds,
                            text: text
                        });
                    }
                }
            });

            console.log(`[DEBUG] parseSubtitles: ${matchCount} matches from ${lines.length} lines, ${subtitleTracks.length} tracks with text`);
            if (subtitleTracks.length > 0) {
                console.log(`[DEBUG] First subtitle at ${subtitleTracks[0].time}s: "${subtitleTracks[0].text.substring(0, 40)}..."`);
                if (subtitleTracks.length > 1) {
                    console.log(`[DEBUG] Second subtitle at ${subtitleTracks[1].time}s: "${subtitleTracks[1].text.substring(0, 30)}..."`);
                }
            }

            subtitleTracks.sort((a, b) => a.time - b.time);

            // Increment version to force re-render in Reading Mode
            window.subtitleVersion = (window.subtitleVersion || 0) + 1;
        }

        // 3. Update-Funktion fÃ¼r Anzeige
        function updateSubtitleDisplay(index) {
            if (index === currentSubtitleIndex) return;
            currentSubtitleIndex = index;
            renderSubtitleLines(Math.max(0, index));
        }

        // 4. Synchronisation (lÃ¤uft bei jedem Audio-Update)
        audioPlayer.addEventListener('timeupdate', () => {
            const t = audioPlayer.currentTime;

            let newIndex = -1;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (t >= subtitleTracks[i].time) {
                    newIndex = i;
                    break;
                }
            }

            updateSubtitleDisplay(newIndex);
        });

        // 4b. Chapter Transition Logic (Main Audio Ended)
        audioPlayer.addEventListener('ended', () => {
            // If Lore Mode, we let the OTHER listener (if exists) or restoreMainAudio handle it.
            // But since I couldn't find the other listener, I'll add a safe check here.
            // If we are in Lore Mode, we usually want to go back to Main Audio.
            // Converting to "Global" logic:
            if (isLoreMode) {
                // Determine if there is another handler. 
                // If restoreMainAudio exists, call it.
                if (window.restoreMainAudio) {
                    window.restoreMainAudio();
                }
            } else {
                // MAIN CHAPTER FINISHED
                console.log("Chapter 1 Finished. ReadingMode:", isReadingMode);

                // BUGFIX: Prevent transition if Text is not finished!
                // Only if we are in Reading Mode (where text matters).
                // Or generally? User said "Cut off bug".

                let textFinished = true;
                if (subtitleTracks.length > 0) {
                    // If we are significantly behind? use small buffer (e.g. within last 3 lines)
                    if (currentSubtitleIndex < subtitleTracks.length - 1) {
                        textFinished = false;
                    }
                }

                // Debug Decision
                console.log(`[DEBUG_SYS] Audio Ended. SubtitleIndex=${currentSubtitleIndex}/${subtitleTracks.length}. TextFinished=${textFinished}`);

                if (isReadingMode) {
                    if (textFinished) {
                        transitionToNextChapter();
                    } else {
                        console.log("[DEBUG_SYS] Audio ended but text incomplete. Pausing audio, keeping Reading Mode open.");
                        // Stop audio but do not transition. 
                        // User can read remaining text, then manual action needed? 
                        // Or maybe we don't need to do anything, just let it stop.
                        audioPlayer.pause();
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else {
                    // Game Mode: Show Button
                    const btn = document.getElementById('nextChapterBtn');
                    if (btn) btn.classList.add('visible');

                    // UI Polish: switch to Pause icon? No, audio ended means it stopped.
                    // Just ensure logic state.
                }
            }
        });

        // PINCH-TO-ZOOM REMOVED per user request (caused jitter issues)


        window.transitionToNextChapter = function () {
            const overlay = document.getElementById('transitionOverlay');
            if (overlay) overlay.classList.add('active');

            // Fade out any remaining audio
            fadeAudio(audioPlayer, 0, 1500);

            setTimeout(() => {
                window.location.href = 'liminal library.html';
            }, 2000); // 2s Fade Time
        };

        const nextChapterBtn = document.getElementById('nextChapterBtn');
        if (nextChapterBtn) {
            nextChapterBtn.addEventListener('click', () => {
                nextChapterBtn.classList.remove('visible');
                transitionToNextChapter();
            });
        }


        // 11. Custom Drag-to-Scroll Logic for Subtitle Container
        let isDown = false;
        let startY;
        let scrollTop;

        const handleDown = (e) => {
            isDown = true;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false'; // Reset for next click check
            const pageY = e.pageY || e.touches[0].pageY;
            startY = pageY - subtitleContainer.offsetTop;
            scrollTop = subtitleContainer.scrollTop;
            // Optional: Cursor style
            subtitleContainer.style.cursor = 'grabbing';
        };

        const handleMove = (e) => {
            if (!isDown) return;
            e.preventDefault(); // Prevent text selection
            const pageY = e.pageY || e.touches[0].pageY;
            const y = pageY - subtitleContainer.offsetTop;
            const walk = (y - startY) * 1.0; // Scroll speed

            // Threshold check
            if (Math.abs(walk) > 5) {
                subtitleContainer.dataset.isDragging = 'true';
                subtitleContainer.dataset.wasDragging = 'true';
                subtitleContainer.scrollTop = scrollTop - walk;
            }
        };

        const handleUp = () => {
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.style.cursor = 'auto';
        };

        subtitleContainer.addEventListener('mousedown', handleDown);
        subtitleContainer.addEventListener('touchstart', handleDown);

        subtitleContainer.addEventListener('mouseleave', handleUp);
        subtitleContainer.addEventListener('mouseup', handleUp);
        subtitleContainer.addEventListener('touchend', handleUp);

        subtitleContainer.addEventListener('mousemove', handleMove);
        subtitleContainer.addEventListener('touchmove', handleMove);

        // 10. Scrollbar Auto-Hide Logic
        let scrollTimeout;
        subtitleContainer.addEventListener('scroll', () => {
            subtitleContainer.classList.add('is-scrolling');
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                subtitleContainer.classList.remove('is-scrolling');
            }, 1000); // 1 Sekunde nach Scroll-Ende ausblenden
        });

        // 5. Play/Pause Steuerung
        playBtn.addEventListener('click', () => {
            console.log("Play Button Clicked. Current Src:", audioPlayer.src, "Paused:", audioPlayer.paused);
            if (audioPlayer.paused) {
                audioPlayer.play()
                    .then(() => syncPlayPauseIcon())
                    .catch(e => {
                        console.error("Play verification failed:", e);
                        syncPlayPauseIcon();
                    });
            } else {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        });

        // 6. Skip Buttons (Â±15 Sekunden)
        skipBackBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 15);
        });

        skipForwardBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.min(audioPlayer.duration || 0, audioPlayer.currentTime + 15);
        });

        // 7. Modus-Wechsel mit schneller Animation
        readingModeBtn.addEventListener('click', () => {
            uiContainer.classList.add('mode-switching');
            // Sofort umschalten, Buttons faden wÃ¤hrenddessen
            isReadingMode = true;
            localStorage.setItem('gameboy_reading_mode', 'true'); // STATE PERSISTENCE

            // CRITICAL: Synchronize Path Direction
            // Do not re-sort! Just find where we are on the existing Spawn->End path.
            syncAutoWalkToIndex();

            moveTarget = null; // Stoppe Bewegung
            uiContainer.classList.add('reading-mode');
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            // Nach kurzer Zeit Buttons wieder einblenden
            setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);
        });

        // HELPER: Sync AutoWalk Index to current Player Position
        function syncAutoWalkToIndex() {
            if (!autoWalkPath || autoWalkPath.length === 0) return;

            // Calculate Foot Position
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const footX = player.x + spriteW / 2;
            const footY = player.y + spriteH + 15;

            // Find closest index
            let closestIdx = 0;
            let minDistSq = Infinity;

            for (let i = 0; i < autoWalkPath.length; i++) {
                const node = autoWalkPath[i];
                const dx = node.x - footX;
                const dy = node.y - footY;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestIdx = i;
                }
            }

            // Set Index
            autoWalkIndex = closestIdx;
            console.log(`AutoWalk Synced to Index: ${closestIdx} / ${autoWalkPath.length}`);
        }

        gameModeBtn.addEventListener('click', () => {
            uiContainer.classList.add('mode-switching');
            isReadingMode = false;
            localStorage.setItem('gameboy_reading_mode', 'false'); // STATE PERSISTENCE

            // Fix: Ensure Lore Mode is also exited IF it was proximity triggered
            // If menu triggered, allow it to continue (as per user request)
            if (isLoreMode && !isMenuTriggeredLore) {
                endLoreMode();
            }

            // Do NOT force isLoreMode = false if we want it to continue playing!
            // isLoreMode = false; // REMOVED to allow playback

            // But if we kept it running, we must ensure moveTarget is clear?
            moveTarget = null;  // Clear any pending movement

            uiContainer.classList.remove('reading-mode');
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);
        });

        // 8. Wenn Audio zu Ende ist, Reset
        // 8. Wenn Audio zu Ende ist
        audioPlayer.addEventListener('ended', () => {
            // Auto-Resume Main Audio if in Lore Mode
            if (isLoreMode) {
                console.log("Lore ended. Returning to Main Audio...");
                restoreMainAudio();
                return;
            }

            iconPlay.style.display = 'block';
            renderSubtitleLines(subtitleTracks.length - 1);
        });

        // 9. Bei Fenster-Resize: Canvas anpassen & Zeilen neu berechnen
        window.addEventListener('resize', () => {
            // A) Canvas Resize Logic (Vollbild UnterstÃ¼tzung)
            if (mapW > 0 && mapH > 0 && gameReady) {
                SCREEN_W = Math.min(mapW, window.innerWidth);
                SCREEN_H = Math.min(mapH, window.innerHeight);
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;

                // Kamera neu zentrieren
                camX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                camY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));
            }

            // B) Untertitel Logic: Force Rebuild bei Resize
            if (isReadingMode && subtitleTracks.length > 0) {
                // Leere Container um Rebuild zu erzwingen (Fix fÃ¼r Scrollbar Resize Bug)
                subtitleContainer.innerHTML = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // 10. Fullscreen Logic
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                iconFsEnter.style.display = 'none';
                iconFsExit.style.display = 'block';
            } else {
                iconFsEnter.style.display = 'block';
                iconFsExit.style.display = 'none';
            }
        });

        // 11. Custom Fullscreen Button (siehe oben)
        let lastBrightness = 0;


        let lastBrightnessCheck = 0;
        function checkBackgroundBrightness(timestamp) {
            // Im Lesemodus immer dunkler Hintergrund
            if (isReadingMode) {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            if (!gameReady || uiContainer.style.display === 'none') {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            // Throttle: Nur alle 1000ms prÃ¼fen (Performance!)
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastBrightnessCheck < 1000) {
                requestAnimationFrame(checkBackgroundBrightness);
                return;
            }
            lastBrightnessCheck = timestamp;

            try {
                const uiRect = uiContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const sampleX = Math.max(0, (uiRect.left - canvasRect.left) * (canvas.width / canvasRect.width));
                const sampleY = Math.max(0, (uiRect.top - canvasRect.top) * (canvas.height / canvasRect.height));
                const sampleW = Math.min(canvas.width - sampleX, uiRect.width * (canvas.width / canvasRect.width));
                const sampleH = Math.min(canvas.height - sampleY, uiRect.height * (canvas.height / canvasRect.height));

                if (sampleW > 0 && sampleH > 0 && sampleX >= 0 && sampleY >= 0) {
                    const imageData = ctx.getImageData(
                        Math.floor(sampleX),
                        Math.floor(sampleY),
                        Math.floor(Math.min(sampleW, 100)),
                        Math.floor(Math.min(sampleH, 60))
                    );

                    let totalBrightness = 0;
                    const pixels = imageData.data;
                    const pixelCount = pixels.length / 4;

                    for (let i = 0; i < pixels.length; i += 16) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                    }

                    const avgBrightness = totalBrightness / (pixelCount / 4);
                    lastBrightness = lastBrightness * 0.85 + avgBrightness * 0.15;

                    // StÃ¤rkerer Kontrast: noch frÃ¼her einsetzen, hÃ¶here Basis
                    const threshold = 60;
                    const maxBrightness = 180;
                    const baseOpacity = 0.5;
                    const maxAdditionalOpacity = 0.8;

                    if (lastBrightness > threshold) {
                        const dynamicOpacity = ((lastBrightness - threshold) / (maxBrightness - threshold)) * maxAdditionalOpacity;
                        const opacity = Math.min(0.95, baseOpacity + dynamicOpacity);
                        const bgValue = `rgba(0, 0, 0, ${opacity.toFixed(2)})`;
                        subtitleContainer.style.background = bgValue;
                        audioControlsEl.style.background = bgValue;
                    } else {
                        subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                        audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                    }
                }
            } catch (e) {
                // Canvas-Zugriff kann bei bestimmten Bedingungen fehlschlagen
            }

            requestAnimationFrame(checkBackgroundBrightness);
        }

        // Starte die Hintergrund-PrÃ¼fung
        requestAnimationFrame(checkBackgroundBrightness);

        // Global Start Time for Grace Period
        const GAME_START_TIME = Date.now();

        // ============================================
        // LORE PROXIMITY SYSTEM
        // ============================================
        function updateLoreSystem() {
            // Grace Period: 3 Sekunden keine Trigger nach Start
            if (!gameReady || yellowLights.length === 0 || (Date.now() - GAME_START_TIME < 3000)) return;

            const refW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const refH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const offsetY = Math.floor(refH * 0.22);
            const hatOffset = Math.floor(refH * 0.15);

            // Bounding Box des Charakters (synchron mit der visuellen Anzeige)
            // Nur der "KÃ¶rper" (Hut bis FÃ¼ÃŸe) lÃ¶st den Trigger aus
            const pLeft = player.x;
            const pRight = player.x + refW;
            const pTop = player.y + offsetY + hatOffset;
            const pBottom = player.y + offsetY + refH;

            // Finde das nÃ¤chste Licht und die Distanz zur Bounding Box
            let nearestId = null;
            let minDist = Infinity;

            yellowLights.forEach(light => {
                // Finde den nÃ¤chsten Punkt auf der Bounding Box zum Licht
                const closestX = Math.max(pLeft, Math.min(light.x, pRight));
                const closestY = Math.max(pTop, Math.min(light.y, pBottom));

                const dx = light.x - closestX;
                const dy = light.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearestId = light.id;
                }
            });

            const TRIGGER_DIST = 6; // Reduced by ~70% (was 20)
            const EXIT_DIST = 25; // Adjusted Hysteresis

            // SHIMMER SOUND TRIGGER (UnabhÃ¤ngig vom Text)
            if (nearestId && minDist < TRIGGER_DIST) {
                // BUGFIX: Do not play shimmer if already collected!
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));

                if (!alreadyCollected) {
                    if (lastShimmerLightId !== nearestId) {
                        shimmerSound.currentTime = 0;
                        shimmerSound.play().catch(() => { });
                        lastShimmerLightId = nearestId;
                    }
                }
            } else if (!nearestId || minDist > EXIT_DIST) {
                // Reset, wenn man den Einflussbereich verlassen hat
                lastShimmerLightId = null;
            }

            // START LORE - Dynamic Sequential Unlock
            if (nearestId && minDist < TRIGGER_DIST && !isLoreMode) {
                // Safety Check: Ignore if Player or Light is at (0,0) (Spawn Glitch)
                const light = yellowLights.find(l => l.id === nearestId);
                if ((player.x === 0 && player.y === 0) || (light && light.x === 0 && light.y === 0)) {
                    return;
                }

                // Check if this specific light was already collected
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));
                if (alreadyCollected) {
                    return;
                }

                activeLightSourceId = nearestId;

                // Use GameState for unified persistence (syncs with YellowLight.draw check)
                if (window.GameState) {
                    window.GameState.collectLight(sc, nearestId).then(unlockedLoreId => {
                        if (unlockedLoreId) {
                            console.log("[GameState] Collected Light -> Unlocked Lore:", unlockedLoreId);
                            // Refresh archive menu so new lore appears immediately
                            if (typeof renderArchive === 'function') renderArchive();
                            // Start lore mode with the UNLOCKED lore ID (not the light ID!)
                            startLoreMode(unlockedLoreId);
                        } else {
                            console.log("[GameState] Light collected but all lore already unlocked.");
                        }
                    });
                } else {
                    // Fallback to local LoreSystem if GameState not available
                    if (!LoreSystem.state.collectedLights[sc]) LoreSystem.state.collectedLights[sc] = [];
                    LoreSystem.state.collectedLights[sc].push(nearestId);
                    LoreSystem.save();
                    const nextLore = LoreSystem.state.collectedLore.length + 1;
                    if (LoreSystem.unlock(nextLore)) {
                        console.log("[LoreSystem] Unlocked Lore:", nextLore);
                        startLoreMode(nextLore);
                    }
                }

            }
            // STOP LORE (Spieler lÃ¤uft weg) - NUR wenn NICHT vom MenÃ¼ gestartet!
            else if (isLoreMode && minDist > EXIT_DIST && !isMenuTriggeredLore) {
                endLoreMode();
            }
        } // End updateLoreSystem

        // NEW: Restore Main Audio Function (Replaces basic endLoreMode logic)
        function restoreMainAudio() {
            if (!isLoreMode) {
                console.log("[DEBUG] restoreMainAudio called but not in lore mode - skipping");
                return;
            }

            console.log("[DEBUG] restoreMainAudio: Starting audio restoration...");
            console.log("[DEBUG] mainAudioState:", JSON.stringify(mainAudioState));
            console.log("[DEBUG] mainAudioUrl:", window.mainAudioUrl);
            console.log("[DEBUG] mainTextContent available:", !!window.mainTextContent);

            isLoreMode = false;
            // isReadingMode intentionally left as is (User can switch manually)

            // Fade out Lore
            fadeAudio(audioPlayer, 0, 800, () => {
                audioPlayer.pause();
                console.log("[DEBUG] Lore audio paused. Loading main audio...");

                // Restore Main Track
                const mainUrl = getSCUrl(window.mainAudioUrl);
                console.log("[DEBUG] Restoring audio src to:", mainUrl);
                audioPlayer.src = mainUrl;

                // Restore Tracks
                // Fix: Explicitly reload Chapter 1 text to ensure correctness
                console.log("[DEBUG] Reloading Main Chapter Text (kapitel1.txt)...");
                fetch('assets/kapitel1.txt')
                    .then(r => {
                        if (!r.ok) throw new Error(`Fetch failed: ${r.status}`);
                        return r.text();
                    })
                    .then(text => {
                        console.log("[DEBUG] kapitel1.txt loaded, length:", text.length);
                        parseSubtitles(text);
                        console.log("[DEBUG] After parseSubtitles, tracks:", subtitleTracks.length);

                        // Use PlayerStateManager for proper sentence-based position restoration
                        let resumeTime = 0;
                        if (window.PlayerStateManager) {
                            const savedState = window.PlayerStateManager.getState('kapitel1');
                            if (savedState && savedState.sentenceTime !== undefined) {
                                resumeTime = savedState.sentenceTime;
                                console.log("[DEBUG] Restored from PlayerStateManager:", savedState);
                            } else {
                                resumeTime = Math.max(0, mainAudioState.time - 5);
                                console.log("[DEBUG] No saved state, using legacy:", mainAudioState.time);
                            }
                        } else {
                            resumeTime = Math.max(0, mainAudioState.time - 5);
                        }
                        console.log("[DEBUG] Setting currentTime to:", resumeTime);
                        audioPlayer.currentTime = resumeTime;
                        renderSubtitleLines(Math.max(0, currentSubtitleIndex));

                        // Resume playback NOW after text is loaded
                        if (mainAudioState.wasPlaying) {
                            console.log("[DEBUG] Resuming playback...");
                            audioPlayer.volume = 0;
                            audioPlayer.play().then(() => {
                                console.log("[DEBUG] Play successful!");
                                fadeAudio(audioPlayer, 1, 800);
                            }).catch(e => {
                                console.error("[DEBUG] Resume blocked:", e);
                            });
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        } else {
                            console.log("[DEBUG] Not resuming playback (was paused before lore)");
                            iconPlay.style.display = 'block';
                            iconPause.style.display = 'none';
                        }
                    })
                    .catch(e => {
                        console.error("[DEBUG] Failed to restore main text:", e);
                        // Fallback to cached state if fetch fails
                        if (mainAudioState.tracks && mainAudioState.tracks.length > 0) {
                            subtitleTracks = [...mainAudioState.tracks];
                            const resumeTime = Math.max(0, mainAudioState.time - 5);
                            audioPlayer.currentTime = resumeTime;
                            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
                        }
                    });

                // Reset Active Lore Flags
                activeLoreId = null;
                activeLightSourceId = null;
                isMenuTriggeredLore = false;

                uiContainer.classList.remove('mode-switching'); // Clean up class
            });
        }

        // endLoreMode() defined below (full implementation)

        function startLoreMode(id, fromMenu = false) {
            if (isLoreMode && activeLoreId === id) return; // Prevent restart of same

            console.log(`[DEBUG] startLoreMode called with id=${id}, fromMenu=${fromMenu}`);
            console.log(`[DEBUG] isLoreMode before:`, isLoreMode);
            console.log(`[DEBUG] audioPlayer.src:`, audioPlayer.src);
            console.log(`[DEBUG] audioPlayer.paused:`, audioPlayer.paused);
            console.log(`[DEBUG] audioPlayer.currentTime:`, audioPlayer.currentTime);

            // CRITICAL FIX: Save main audio state BEFORE setting isLoreMode = true
            // Check if current track is actually MAIN audio before saving
            const isMainAudio = audioPlayer.src.includes(window.mainAudioUrl) ||
                audioPlayer.src.includes('kapitel1') ||
                audioPlayer.src.includes('2250158609'); // Kapitel 1 track ID

            console.log(`[DEBUG] isMainAudio:`, isMainAudio, `mainAudioUrl:`, window.mainAudioUrl);

            if (isMainAudio && !isLoreMode) {
                // Save state via Manager (Sentence Based)
                if (window.PlayerStateManager) {
                    window.PlayerStateManager.saveState('kapitel1', subtitleTracks, audioPlayer);
                }

                // Fallback / legacy state object (keep for now as backup)
                mainAudioState.wasPlaying = !audioPlayer.paused;
                mainAudioState.time = audioPlayer.currentTime;
                console.log(`[DEBUG] Saved mainAudioState (Manager + Legacy):`, JSON.stringify(mainAudioState));
            }

            // NOW set loreMode flag
            isLoreMode = true;
            // isReadingMode = true; // REMOVED: Respect current mode!
            // uiContainer.classList.add('reading-mode'); // REMOVED: Respect current mode!

            // If we are ALREADY in reading mode, update UI class just in case
            if (isReadingMode) {
                uiContainer.classList.add('reading-mode');
            } else {
                uiContainer.classList.remove('reading-mode');
            }
            moveTarget = null; // Stoppe Bewegung
            activeLoreId = id;
            isMenuTriggeredLore = fromMenu; // Set flag

            if (loreResumeTimeout) clearTimeout(loreResumeTimeout);

            // Sanftes Ausblenden (Main Audio) - 2 Sekunden (oder sofort bei Switch?)
            fadeAudio(audioPlayer, 0, 1000, async () => {
                audioPlayer.pause();
                // ... rest of logic stays mostly same, just ensure flag is used
                // ...


                // UI Feedback
                uiContainer.classList.add('mode-switching');

                // Debugging Lore Text Loading
                console.log(`[DEBUG] startLoreMode ID: ${id}`);
                console.log(`[DEBUG] Text in loreData for ID ${id}:`, loreData.text[id] ? loreData.text[id].substring(0, 50) + "..." : "UNDEFINED/NULL");

                // RETRY LOADING TEXT IF MISSING
                // Hardcoded Backup because Fetch might fail on file:// protocol
                if (!loreData.text[id] || loreData.text[id].length < 10) {
                    // Try fetch first
                    try {
                        // Use path from GameState if available
                        const content = window.GameState?.getLore(id);
                        const textPath = content ? content.text : `assets/lore${id}.txt`;
                        console.log(`Loading text from ${textPath} (ID: ${id})...`);

                        const res = await fetch(textPath);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`Lore ${id} text recovered.`);
                        } else {
                            console.warn(`Fetch failed for ${textPath}: ${res.status}`);
                        }
                    } catch (e) {
                        console.warn("Lore retry failed:", e);
                    }
                }

                setTimeout(() => {
                    // Lore laden
                    audioPlayer.src = getSCUrl(loreData.audio[id]);

                    // Rewind 5s beim Wiederaufnehmen (User-Wunsch)
                    // 1. TEXT LOAD & PARSING
                    if (loreData.text[id] && loreData.text[id].length > 0) {
                        console.log(`[DEBUG] Parsing Subtitles for ID ${id}...`);
                        parseSubtitles(loreData.text[id]);
                        console.log(`[DEBUG] Subtitle Tracks Found: ${subtitleTracks.length}`);
                    } else {
                        console.warn(`[DEBUG] No text found for ID ${id}!`);
                        subtitleTracks = [];
                        subtitleContainer.innerHTML = '<div class="subtitle-line subtitle-current">â™ª Lore Audio (Warte auf Text...) â™ª</div>';
                    }

                    // 2. RESTORE PLAYER STATE (Sentence-Based)
                    let resumeTime = 0;
                    if (window.PlayerStateManager) {
                        const saved = window.PlayerStateManager.getState('lore' + id);
                        if (saved) {
                            resumeTime = saved.sentenceTime;
                            console.log(`[DEBUG] Restoring Lore ${id} to sentence start: ${resumeTime}s`);
                        } else {
                            const last = loreData.resumeTimes[id] || 0;
                            resumeTime = Math.max(0, last - 5);
                        }
                    } else {
                        const last = loreData.resumeTimes[id] || 0;
                        resumeTime = Math.max(0, last - 5);
                    }

                    audioPlayer.currentTime = resumeTime;

                    // 3. INITIAL RENDER
                    let startIndex = 0;
                    if (subtitleTracks.length > 0) {
                        for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                            if (resumeTime >= subtitleTracks[i].time) {
                                startIndex = i;
                                break;
                            }
                        }
                    }
                    currentSubtitleIndex = startIndex;
                    renderSubtitleLines(startIndex);
                    console.log(`[DEBUG] Starting lore audio playback...`);
                    console.log(`[DEBUG] audioPlayer.src before play:`, audioPlayer.src);

                    audioPlayer.volume = 0;
                    audioPlayer.play()
                        .then(() => {
                            console.log(`[DEBUG] Lore play() succeeded! Starting fade in...`);
                            fadeAudio(audioPlayer, 1.0, 1000); // Sanftes Einblenden
                        })
                        .catch(e => {
                            console.error("[DEBUG] Lore play error:", e);
                            // Try playing again after a short delay (widget might not be ready)
                            setTimeout(() => {
                                console.log(`[DEBUG] Retrying lore play after delay...`);
                                audioPlayer.play().catch(e2 => console.error("[DEBUG] Retry failed:", e2));
                                fadeAudio(audioPlayer, 1.0, 1000);
                            }, 500);
                        });

                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';

                    audioPlayer.onended = () => {
                        console.log(`[DEBUG] Lore audio ended naturally`);
                        loreData.resumeTimes[id] = 0; // Reset wenn fertig
                        endLoreMode();
                    };

                    uiContainer.classList.remove('mode-switching');
                    console.log(`Lore ${id} gestartet bei ${audioPlayer.currentTime.toFixed(1)}s`);
                }, 250);
            });
        }

        function endLoreMode() {
            console.log(`[DEBUG] endLoreMode called!`);
            console.log(`[DEBUG] isLoreMode: ${isLoreMode}, activeLoreId: ${activeLoreId}`);
            console.log(`[DEBUG] Stack trace:`, new Error().stack);

            if (!isLoreMode) {
                console.log(`[DEBUG] endLoreMode: Not in lore mode, skipping`);
                return;
            }
            isLoreMode = false;
            isMenuTriggeredLore = false; // Reset menu flag

            const id = activeLoreId;
            // Fortschritt speichern
            if (id) {
                loreData.resumeTimes[id] = audioPlayer.currentTime;
                if (window.PlayerStateManager) {
                    window.PlayerStateManager.saveState('lore' + id, subtitleTracks, audioPlayer);
                }
            }
            activeLoreId = null;
            activeLightSourceId = null; // Licht zurÃ¼cksetzen

            fadeAudio(audioPlayer, 0, 2000, () => {
                audioPlayer.pause();
                audioPlayer.onended = null;

                uiContainer.classList.add('mode-switching');
                subtitleContainer.innerHTML = '';

                // ... logic to resume main audio continues below ...

                // 1 Sekunde Pause vor Resume (wie vom User gewÃ¼nscht)
                loreResumeTimeout = setTimeout(() => {
                    if (window.mainAudioUrl) {
                        audioPlayer.src = getSCUrl(window.mainAudioUrl);

                        // CRITICAL: Force clear container to rebuild click handlers
                        subtitleContainer.innerHTML = '';

                        // Load main chapter text
                        if (window.mainTextContent) {
                            console.log('[DEBUG] endLoreMode: Parsing main text from window.mainTextContent');
                            parseSubtitles(window.mainTextContent);
                        } else {
                            console.log('[DEBUG] endLoreMode: Fetching kapitel1.txt...');
                            fetch('assets/kapitel1.txt')
                                .then(r => r.text())
                                .then(text => {
                                    window.mainTextContent = text;
                                    parseSubtitles(text);
                                    // Force rebuild after async load
                                    subtitleContainer.innerHTML = '';
                                    renderSubtitleLines(0);
                                })
                                .catch(e => console.error('[DEBUG] Fetch failed:', e));
                        }

                        // RESTORE MAIN AUDIO STATE (Sentence Based)
                        let resumeTime = 0;
                        if (window.PlayerStateManager) {
                            const saved = window.PlayerStateManager.getState('kapitel1');
                            if (saved) {
                                resumeTime = saved.sentenceTime;
                                console.log(`[DEBUG] Restoring Main Audio to sentence start: ${resumeTime}s`);
                            } else {
                                resumeTime = Math.max(0, mainAudioState.time - 5);
                            }
                        } else {
                            resumeTime = Math.max(0, mainAudioState.time - 5);
                        }

                        audioPlayer.currentTime = resumeTime;

                        // Find correct subtitle index for current time
                        let correctIndex = 0;
                        for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                            if (resumeTime >= subtitleTracks[i].time) {
                                correctIndex = i;
                                break;
                            }
                        }
                        currentSubtitleIndex = correctIndex;

                        console.log(`[DEBUG] endLoreMode: subtitleTracks.length=${subtitleTracks.length}, resumeTime=${resumeTime.toFixed(1)}s, correctIndex=${correctIndex}`);

                        // FORCE rebuild subtitle lines
                        renderSubtitleLines(correctIndex);

                        if (mainAudioState.wasPlaying) {
                            audioPlayer.volume = 0;
                            audioPlayer.play();
                            fadeAudio(audioPlayer, 1.0, 2000); // 2 Sekunden Einblenden
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        } else {
                            audioPlayer.volume = 1.0;
                            iconPlay.style.display = 'block';
                            iconPause.style.display = 'none';
                        }

                        audioPlayer.onended = () => {
                            iconPlay.style.display = 'block';
                            iconPause.style.display = 'none';
                            renderSubtitleLines(subtitleTracks.length - 1);
                        };

                        console.log(`Haupt-Audio fortgesetzt bei ${resumeTime.toFixed(1)}s`);
                    }
                    uiContainer.classList.remove('mode-switching');
                }, 1000); // 1 Sekunde Pause
            });
        }

        // Hilfsfunktion fÃ¼r Audio-Fading
        function fadeAudio(audio, targetVolume, duration, callback) {
            const startVolume = audio.volume;
            const diff = targetVolume - startVolume;
            const startTime = Date.now();

            function tick() {
                const now = Date.now();
                const progress = Math.min(1, (now - startTime) / duration);
                audio.volume = startVolume + diff * progress;

                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (callback) {
                    callback();
                }
            }
            tick();
        }


    </script>
</body>

</html>
