<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heidelberg RPG</title>
    <!-- SoundCloud Widget API & System -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="assets/js/SoundCloudURLs.js"></script>
    <script src="assets/js/shared-game-systems.js"></script>
    <script src="assets/js/PlayerStateManager.js"></script>
    <script src="assets/js/ChapterAutoplayIntent.js"></script>
    <script src="assets/js/AudioVisibilityManager.js"></script>
    <script src="assets/js/SCAudioAdapter.js"></script> <!-- Adapter AFTER Managers so it can register itself -->
    <script src="assets/js/GlobalVisualDimmer.js"></script>
    <!-- Main Stylesheet (extracted during refactoring) -->
    <link rel="stylesheet" href="assets/css/main.css">
    <!-- Critical inline CSS for loading screen (above-the-fold) -->
    <style>
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #444;
            font-family: 'Segoe UI', system-ui, sans-serif;
            transition: opacity 1s ease;
        }

        #loading-screen .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .subtitle-current {
            font-weight: 500 !important;
        }

        #subtitleRecenterBtn {
            position: fixed;
            top: -9999px;
            left: -9999px;
            display: none;
            pointer-events: auto;
            opacity: 0.92;
            z-index: 2600;
        }

        #subtitleRecenterBtn svg {
            width: 22px;
            height: 22px;
        }

        #subtitleRecenterMobileRadius {
            position: fixed;
            width: 500px;
            height: 500px;
            left: -9999px;
            top: -9999px;
            display: none;
            pointer-events: none;
            border: none;
            border-radius: 50%;
            background: transparent;
            box-shadow: none;
            z-index: 2598;
        }
    </style>
</head>

<body>



    <!-- LOADING SCREEN (über ALLEM) -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING...</p>
    </div>

    <!-- SVG Filter Definitionen -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1"
        xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- PAL Filter: Horizontal Blur + leichte Farbverschiebung -->
            <filter id="pal-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.6 0" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="
                    0.9 0.1 0.0 0 0
                    0.0 0.9 0.1 0 0
                    0.0 0.0 0.9 0 0
                    0   0   0   1 0" result="colored" />
            </filter>

            <!-- Glitch Filter: Turbulenz Displacement -->
            <!-- Glitch Filter: Turbulenz Displacement -->
            <filter id="glitch-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.002 0.005" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="baseFrequency" dur="60s" values="0.002 0.005;0.005 0.01;0.002 0.005"
                        repeatCount="indefinite" />
                    <animate attributeName="seed" dur="3s" values="0;100;0" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R"
                    yChannelSelector="G" />
            </filter>
        </defs>
    </svg>

    <!-- DropZone removed for Electron App -->

    <div id="processingInfo">
        <div class="spinner"></div>
        <div>Verarbeite Karte...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>

    <!-- MAIN GAME AREA -->
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="crtOverlay"></div>
    </div>

    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer" class="reader-layout-timestamps">
            <!-- Dynamisch generierte Zeilen -->
        </div>

        <!-- Next Chapter Button (Hidden by default) -->
        <button id="nextChapterBtn">Weiter</button>

        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn" tabindex="-1">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" tabindex="-1">
                    <!-- Resize Book Button by ~20% (scale 0.8 or smaller SVG) -->
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                </button>

                <button id="readingModeBtn" class="audio-btn" title="Lesemodus aktivieren" tabindex="-1"
                    aria-label="Lesemodus aktivieren">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="sceneDimmerToggleBtn" class="audio-btn" title="Hintergrund abdunkeln" tabindex="-1"
                    aria-label="Hintergrunddimmer aus">
                    <svg id="sceneDimmerIconFull" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="8"></circle>
                        <circle cx="12" cy="12" r="6" fill="white" stroke="none"></circle>
                    </svg>
                    <svg id="sceneDimmerIconHalf" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="8"></circle>
                        <path d="M12 4a8 8 0 0 0 0 16z" fill="white" stroke="none"></path>
                    </svg>
                    <svg id="sceneDimmerIconCrescent" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <path d="M16.5 4.5A8 8 0 1 0 16.5 19A6.8 6.8 0 1 1 16.5 4.5Z" fill="white" stroke="white">
                        </path>
                    </svg>
                    <svg id="sceneDimmerIconSun" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <circle cx="12" cy="12" r="4" fill="white" stroke="none"></circle>
                        <path d="M12 2v3"></path>
                        <path d="M12 19v3"></path>
                        <path d="M2 12h3"></path>
                        <path d="M19 12h3"></path>
                        <path d="M4.9 4.9l2.1 2.1"></path>
                        <path d="M17 17l2.1 2.1"></path>
                        <path d="M19.1 4.9L17 7"></path>
                        <path d="M7 17l-2.1 2.1"></path>
                    </svg>
                </button>
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild" tabindex="-1">
                    <!-- ENTER FULLSCREEN (Corners pointing OUT) -->
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square">
                        <path d="M7 10V7h3" />
                        <path d="M17 10V7h-3" />
                        <path d="M17 14v3h-3" />
                        <path d="M7 14v3h3" />
                    </svg>
                    <!-- EXIT FULLSCREEN (Corners pointing IN) -->
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square" style="display:none;">
                        <path d="M4 14h6v6" />
                        <path d="M20 14h-6v6" />
                        <path d="M20 10h-6V4" />
                        <path d="M4 10h6V4" />
                    </svg>
                </button>
                <button id="subtitleRecenterBtn" class="audio-btn" title="Text auf aktuelle Stelle zentrieren"
                    aria-label="Text auf aktuelle Stelle zentrieren" tabindex="-1" type="button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 7h10" />
                        <path d="M3 12h10" />
                        <path d="M3 17h10" />
                        <path d="M14 12h7" />
                        <path d="M18 9l3 3-3 3" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
    <div id="sceneDimmerOverlay" aria-hidden="true"></div>

    <!-- ARCHIVE MODAL (INHALT) -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title-wrap">
                    <button class="archive-primary-btn active" id="archivePrimaryInhaltBtn"
                        type="button">Inhalt</button>
                    <button class="archive-primary-btn archive-primary-gear" id="archivePrimarySettingsBtn"
                        type="button" aria-label="Einstellungen" title="Einstellungen">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.9"
                            stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <circle cx="12" cy="12" r="6.35"></circle>
                            <circle cx="12" cy="12" r="2.85"></circle>
                            <path d="M12 2.7v2.45M12 18.85v2.45M4.93 4.93l1.73 1.73M17.34 17.34l1.73 1.73"></path>
                            <path d="M2.7 12h2.45M18.85 12h2.45M4.93 19.07l1.73-1.73M17.34 6.66l1.73-1.73"></path>
                        </svg>
                    </button>
                </div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>

            <div class="archive-tabs">
                <button class="archive-tab active" data-tab="kapitel">Kapitel</button>
                <button class="archive-tab" data-tab="lore">Lore</button>
                <button class="archive-tab" data-tab="lesezeichen">Lesezeichen</button>
            </div>

            <div class="archive-tab-content active" data-tab="kapitel">
                <!-- KAPITEL -->
                <div class="col-left" id="chapterList" style="flex:1;">
                    <!-- Hardcoded Chapter 1 -->
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Der Marktplatz</div>
                    </div>

                    <!-- Chapter 1b -->
                    <div class="menu-item" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Liminal Library</div>
                    </div>

                    <!-- Chapter 1c -->
                    <div class="menu-item" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse</div>
                    </div>
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lore">
                <!-- LORE -->
                <div class="col-left" id="loreList" style="flex:1;">
                    <!-- Dynamisch gefüllt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="lesezeichen">
                <!-- LESEZEICHEN -->
                <div id="bookmarkList" style="width:100%;">
                    <!-- Dynamisch gefüllt -->
                </div>
            </div>

            <div class="archive-tab-content" data-tab="einstellungen">
                <div class="reader-settings-panel">
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Satztechnik</div>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="timestamps" checked>
                            <span>Timestamps </span>
                        </label>
                        <label class="reader-radio-option">
                            <input type="radio" name="readerSentenceLayout" value="flat">
                            <span>Flattersatz</span>
                        </label>
                    </div>
                    <div class="reader-settings-group">
                        <label class="reader-settings-title" for="readerFontSizeRange">Schriftgröße</label>
                        <div class="reader-size-row">
                            <input id="readerFontSizeRange" type="range" min="14" max="30" step="1" value="18">
                            <input id="readerFontSizeNumber" type="number" min="14" max="30" step="1" value="18">
                            <span class="reader-size-unit">px</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Lautst&auml;rke</div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerTextVolumeRange">Text</label>
                            <input id="readerTextVolumeRange" type="range" min="0" max="100" step="1" value="100">
                            <input id="readerTextVolumeNumber" type="number" min="0" max="100" step="1" value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                        <div class="reader-volume-row">
                            <label class="reader-volume-label" for="readerBackgroundVolumeRange">Hintergrund</label>
                            <input id="readerBackgroundVolumeRange" type="range" min="0" max="100" step="1"
                                value="100">
                            <input id="readerBackgroundVolumeNumber" type="number" min="0" max="100" step="1"
                                value="100">
                            <span class="reader-size-unit">%</span>
                        </div>
                    </div>
                    <div class="reader-settings-group">
                        <div class="reader-settings-title">Farben</div>
                        <div class="reader-color-field">
                            <button id="readerBgColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerBgColorPickerPopover">
                                <span class="reader-color-row-label">Hintergrund</span>
                                <span class="reader-color-preview" id="readerBgColorPreview"></span>
                            </button>
                            <div id="readerBgColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerBgColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerBgColorMarker" class="reader-wheel-marker" aria-hidden="true"></div>
                                </div>
                            </div>
                        </div>
                        <div class="reader-color-field">
                            <button id="readerTextColorToggleBtn" class="reader-color-row" type="button"
                                aria-expanded="false" aria-controls="readerTextColorPickerPopover">
                                <span class="reader-color-row-label">Schrift</span>
                                <span class="reader-color-preview" id="readerTextColorPreview"></span>
                            </button>
                            <div id="readerTextColorPickerPopover" class="reader-color-picker-popover" hidden>
                                <div class="reader-wheel-wrap">
                                    <canvas id="readerTextColorWheel" class="reader-color-wheel" width="168"
                                        height="168"></canvas>
                                    <div id="readerTextColorMarker" class="reader-wheel-marker" aria-hidden="true"></div>
                                </div>
                            </div>
                        </div>
                        <button id="readerColorResetBtn" class="reader-color-reset-btn" type="button">Farben zur&uuml;cksetzen</button>
                    </div>
                </div>
            </div>

            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; display: flex; gap: 20px; justify-content: center;">
                <button id="btnSaveData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">SAVE
                    (Export)</button>
                <button id="btnLoadData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">LOAD
                    (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <!-- Shared Game Systems (Particle, Cloud, YellowLight) for code sharing - LOADED IN HEAD -->

    <script>
        // ============================================
        // SETUP & FILTER LOGIK
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const controlsHint = document.getElementById('controlsHint');



        const processingInfo = document.getElementById('processingInfo');
        const gameWrapper = document.getElementById('gameWrapper');

        // PAL + CRT Effekte permanent aktiviert
        console.log("Applying Visual Fixes..."); // DEBUG
        gameWrapper.classList.add('effect-pal');
        gameWrapper.classList.add('effect-crt');
        const isIOSDevice = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const AUDIO_PROFILE = isIOSDevice
            ? { ambient: 0.012, footsteps: 0.014 }
            : { ambient: 0.02, footsteps: 0.024 };
        if (isIOSDevice) {
            // SVG PAL filter is expensive on iOS WebKit and causes visible stutter.
            gameWrapper.classList.remove('effect-pal');
        }

        // Turbulenz für Glitch laufend aktualisieren für "Randomness"
        // const turb = document.querySelector('#glitch-filter feTurbulence');
        // const disp = document.querySelector('#glitch-filter feDisplacementMap');

        // Glitch Loop: Manchmal stärker, manchmal schwächer
        // setInterval(() => {
        //     if (Math.random() > 0.95) {
        //         // Kurzer starker Glitch
        //         disp.setAttribute('scale', (Math.random() * 30 + 10).toString());
        //         turb.setAttribute('seed', Math.floor(Math.random() * 100).toString());
        //         setTimeout(() => {
        //             disp.setAttribute('scale', '4'); // Zurück zu subtil
        //         }, 100);
        //     }
        // }, 500);

        let gameReady = false;

        // ============================================
        // MULTI-LEVEL CONFIG (URL-Parameter: ?chapter=kapitel1c)
        // ============================================
        const _urlParams = new URLSearchParams(window.location.search);
        const _chapterParam = _urlParams.get('chapter');
        const LEVEL_CONFIGS = {
            kapitel1: {
                sceneName: 'marktplatz',
                contentKey: 'kapitel1',
                mapFile: 'assets/platz3.png',
                audioUrl: 'assets/kapitel1.mp3',
                subtitleFile: 'assets/kapitel1.txt',
                activeChapterBtn: 'chapter1Btn',
                nextChapterTarget: 'liminal library.html',
                page: 'index.html',
                chapterLabel: '1a',
                chapterTitle: 'Der Marktplatz',
            },
            kapitel1c: {
                sceneName: 'steingasse',
                contentKey: 'kapitel1c',
                mapFile: 'assets/kapitel1c.png',
                audioUrl: 'assets/kapitel1c.mp3',
                subtitleFile: 'assets/kapitel1c.txt',
                activeChapterBtn: 'chapter1cBtn',
                nextChapterTarget: null,
                page: 'index.html?chapter=kapitel1c',
                chapterLabel: '1c',
                chapterTitle: 'Steingasse',
            }
        };
        const LEVEL = LEVEL_CONFIGS[_chapterParam] ?? LEVEL_CONFIGS['kapitel1'];

        const SCENE_NAME = LEVEL.sceneName;
        let bgImage = null;
        let foregroundImage = null;
        let spriteReady = false;
        let collisionData = [];   // true = Wand
        let foregroundData = [];  // true = Vordergrund (verdeckt Spieler)
        let flowData = [];        // true = Magischer Fluss (Grün)
        let magentaPixels = [];
        let cyanPixels = new Set();
        let greenPixels = [];     // Zum Verstecken
        let yellowLights = [];    // Lore Lights (Global)
        let autoWalkPath = [];
        let autoWalkIndex = 0;
        // isReadingMode is defined later in AUDIO & SUBTITLE SYSTEM

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================
        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        let GameState = null; // Will be loaded dynamically

        let mainAudioState = { time: 0, wasPlaying: false, tracks: [] };
        let activeLoreId = null;
        let activeLightSourceId = null;
        let isLoreMode = false;
        let isMenuTriggeredLore = false;
        let loreResumeTimeout = null;
        const MAIN_CONTENT_KEY = LEVEL.contentKey;
        let contentSwitchInProgress = false;
        let contentSwitchToken = 0;
        const mainChapterAutoplayIntent = window.ChapterAutoplayIntent
            ? window.ChapterAutoplayIntent.consume(MAIN_CONTENT_KEY, { defaultPolicy: 'auto' })
            : { policy: 'auto', shouldAutoplay: true, source: 'fallback', reason: 'intent-missing' };

        function markChapterAutoplayIntent(targetPageKey, policy = 'auto', reason = '') {
            if (!window.ChapterAutoplayIntent || !targetPageKey) return;
            if (policy === 'manual') {
                window.ChapterAutoplayIntent.markManual(targetPageKey, MAIN_CONTENT_KEY, reason || 'chapter-menu');
                return;
            }
            window.ChapterAutoplayIntent.markAuto(targetPageKey, MAIN_CONTENT_KEY, reason || 'auto-transition');
        }

        const loreData = {
            audio: {},
            text: {},
            resumeTimes: {}
        };

        // ============================================
        // DEBUG (disabled in production UI)
        // ============================================
        const indexDebug = {
            lastSave: null
        };

        function indexDebugNote() { }
        function indexTrace() { }

        function writeStateHandoff(targetPageKey) {
            try {
                if (!window.PlayerStateManager || typeof window.PlayerStateManager.exportStates !== 'function') return;
                const states = window.PlayerStateManager.exportStates();
                const payload = {
                    from: MAIN_CONTENT_KEY,
                    to: targetPageKey,
                    at: Date.now(),
                    states
                };
                sessionStorage.setItem('gb_state_handoff', JSON.stringify(payload));
                sessionStorage.setItem('gb_handoff_expect', String(targetPageKey || ''));
                indexDebugNote('handoff-out', `to=${targetPageKey} states=${Object.keys(states).length}`);
            } catch (e) {
                indexDebugNote('handoff-out-error', e && e.message ? e.message : String(e));
            }
        }

        function mergeIncomingStateHandoff(expectedTargetKey) {
            try {
                const raw = sessionStorage.getItem('gb_state_handoff');
                const expected = sessionStorage.getItem('gb_handoff_expect');
                if (!raw || !window.PlayerStateManager) {
                    if (expected && expected === expectedTargetKey) {
                        indexDebugNote('handoff-in-missing', `expected=${expectedTargetKey}`);
                        sessionStorage.removeItem('gb_handoff_expect');
                    }
                    return;
                }

                const payload = JSON.parse(raw);
                if (!payload || payload.to !== expectedTargetKey || !payload.states || typeof payload.states !== 'object') {
                    return;
                }

                let merged = 0;
                for (const [key, incoming] of Object.entries(payload.states)) {
                    if (!incoming || typeof incoming !== 'object') continue;
                    const current = window.PlayerStateManager.getState(key);
                    const incomingStamp = Number(incoming.lastUpdate || 0);
                    const currentStamp = Number((current && current.lastUpdate) || 0);
                    if (current && currentStamp > incomingStamp) continue;

                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: Number.isFinite(incoming.sentenceIndex) ? incoming.sentenceIndex : 0,
                            sentenceTime: Number.isFinite(incoming.sentenceTime) ? incoming.sentenceTime : 0,
                            wasPlaying: !!incoming.wasPlaying
                        });
                        merged++;
                    }
                }

                sessionStorage.removeItem('gb_state_handoff');
                sessionStorage.removeItem('gb_handoff_expect');
                indexDebugNote('handoff-in', `from=${payload.from || '-'} merged=${merged}`);
            } catch (e) {
                indexDebugNote('handoff-in-error', e && e.message ? e.message : String(e));
            }
        }

        mergeIncomingStateHandoff(MAIN_CONTENT_KEY);

        // Initialize GameState
        (async function initGameState() {
            try {
                const module = await import('./assets/js/GameState.js');
                GameState = module.GameState;
                window.GameState = GameState; // Global Ref
                await GameState.init();
                console.log("[Index] GameState Loaded & Initialized");

                // Populate loreData for compatibility (audio + text)
                const db = GameState.getAllLore();
                for (const [id, content] of Object.entries(db)) {
                    loreData.audio[id] = content.audio;
                    // Pre-fetch text for reliability
                    try {
                        const res = await fetch(content.text);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`[Init] Pre-loaded text for lore ${id}`);
                        }
                    } catch (e) {
                        console.warn(`[Init] Could not pre-load text for lore ${id}:`, e);
                    }
                }
            } catch (e) {
                console.error("Failed to load GameState:", e);
            }
        })();

        // Haupt-Audio je nach aktivem Level
        window.mainAudioUrl = LEVEL.audioUrl;

        // Unlock Logic Wrapper
        async function unlockLoreItem(id) {
            if (!GameState) return;
            const newUnlock = await GameState.unlockLore(id);
            if (newUnlock) {
                const item = GameState.getLore(id);
                showNotification(`Eintrag freigeschaltet: ${item ? item.title : 'Unbekannt'}`);
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('controlsHint');
            if (el) {
                el.innerText = msg;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
        }

        function triggerUiHaptic(pattern = 8) {
            if (typeof navigator === 'undefined' || typeof navigator.vibrate !== 'function') return;
            navigator.vibrate(pattern);
        }

        // --- ARCHIVE TAB SWITCHING ---
        function initArchiveTabs() {
            const tabs = Array.from(document.querySelectorAll('.archive-tab'));
            const panels = Array.from(document.querySelectorAll('.archive-tab-content'));
            const tabsBar = document.querySelector('.archive-tabs');
            const primaryInhaltBtn = document.getElementById('archivePrimaryInhaltBtn');
            const primarySettingsBtn = document.getElementById('archivePrimarySettingsBtn');
            const settingsPanel = document.querySelector('.archive-tab-content[data-tab="einstellungen"]');
            let lastContentTab = 'kapitel';

            const setPrimaryMode = (mode) => {
                const normalized = mode === 'einstellungen' ? 'einstellungen' : 'inhalt';

                if (primaryInhaltBtn) primaryInhaltBtn.classList.toggle('active', normalized === 'inhalt');
                if (primarySettingsBtn) primarySettingsBtn.classList.toggle('active', normalized === 'einstellungen');
                if (tabsBar) tabsBar.style.display = normalized === 'inhalt' ? '' : 'none';
            };

            const showContentTab = (target, activeTab = null) => {
                tabs.forEach((t) => t.classList.remove('active'));
                panels.forEach((p) => p.classList.remove('active'));

                const matchedTab = activeTab || tabs.find((t) => t.getAttribute('data-tab') === target) || null;
                if (matchedTab) {
                    matchedTab.classList.add('active');
                    lastContentTab = matchedTab.getAttribute('data-tab') || lastContentTab;
                }

                const panel = document.querySelector(`.archive-tab-content[data-tab="${lastContentTab}"]`);
                if (panel) panel.classList.add('active');
                if (lastContentTab === 'lesezeichen') renderBookmarks();
            };

            const showSettingsPanel = () => {
                tabs.forEach((t) => t.classList.remove('active'));
                panels.forEach((p) => p.classList.remove('active'));
                if (settingsPanel) settingsPanel.classList.add('active');
                if (typeof syncReaderSettingsUi === 'function') syncReaderSettingsUi();
            };

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    tab.classList.remove('pressed');
                    // Force reflow so the press animation retriggers on repeated clicks.
                    void tab.offsetWidth;
                    tab.classList.add('pressed');
                    setTimeout(() => tab.classList.remove('pressed'), 170);
                    const target = tab.getAttribute('data-tab');
                    setPrimaryMode('inhalt');
                    showContentTab(target, tab);
                });
            });

            if (primaryInhaltBtn) {
                primaryInhaltBtn.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    setPrimaryMode('inhalt');
                    showContentTab(lastContentTab);
                });
            }

            if (primarySettingsBtn) {
                primarySettingsBtn.addEventListener('click', () => {
                    triggerUiHaptic(7);
                    setPrimaryMode('einstellungen');
                    showSettingsPanel();
                });
            }

            const initiallyActiveTab = tabs.find((tab) => tab.classList.contains('active'));
            if (initiallyActiveTab) {
                lastContentTab = initiallyActiveTab.getAttribute('data-tab') || 'kapitel';
            }
            setPrimaryMode('inhalt');
            showContentTab(lastContentTab, initiallyActiveTab || undefined);
        }
        initArchiveTabs();

        // --- BOOKMARK RENDERING ---
        const CURRENT_PAGE = LEVEL.page;
        const CURRENT_CHAPTER = LEVEL.chapterLabel;
        const CURRENT_CHAPTER_TITLE = LEVEL.chapterTitle;
        const BOOKMARK_PAGE_KEY_MAP = {
            'index.html': 'kapitel1',
            'liminal library.html': 'liminal_library',
            'index.html?chapter=kapitel1c': 'kapitel1c'
        };

        function resolveBookmarkPageKey(page) {
            return BOOKMARK_PAGE_KEY_MAP[page] || 'kapitel1';
        }

        function extractLoreIdFromBookmark(bm, fallbackKey = '') {
            const directLoreId = Number(bm && bm.loreId);
            if (Number.isFinite(directLoreId) && directLoreId > 0) return Math.trunc(directLoreId);

            const keyCandidate = (typeof fallbackKey === 'string' && fallbackKey)
                ? fallbackKey
                : (typeof (bm && bm.contentKey) === 'string' ? bm.contentKey : '');
            const keyMatch = keyCandidate.match(/^lore(\d+)$/i);
            if (keyMatch) return Number(keyMatch[1]);

            const chapterMatch = (typeof (bm && bm.chapter) === 'string' ? bm.chapter : '').match(/^lore(\d+)$/i);
            if (chapterMatch) return Number(chapterMatch[1]);

            const refs = [
                (typeof (bm && bm.audioRef) === 'string') ? bm.audioRef : '',
                (typeof (bm && bm.textRef) === 'string') ? bm.textRef : ''
            ];
            for (const ref of refs) {
                const m = ref.match(/lore(\d+)\.(?:mp3|txt)/i);
                if (m) return Number(m[1]);
            }
            return null;
        }

        function resolveBookmarkContentKey(bm) {
            if (bm && typeof bm.contentKey === 'string' && bm.contentKey.trim()) {
                return bm.contentKey.trim();
            }

            const loreId = extractLoreIdFromBookmark(bm);
            if (Number.isFinite(loreId) && loreId > 0) return `lore${loreId}`;

            if (bm && typeof bm.page === 'string' && BOOKMARK_PAGE_KEY_MAP[bm.page]) {
                return BOOKMARK_PAGE_KEY_MAP[bm.page];
            }
            return '';
        }

        async function ensureBookmarkContentForCurrentPage(bm, reason = 'bookmark') {
            await waitForContentSwitchIdle(`${reason}:pre`);

            const targetKey = resolveBookmarkContentKey(bm);
            if (!targetKey) return true; // Legacy bookmark without content metadata

            const currentKey = getActiveContentKey();
            if (targetKey === currentKey) return true;

            if (/^lore\d+$/i.test(targetKey)) {
                const loreId = extractLoreIdFromBookmark(bm, targetKey);
                if (!Number.isFinite(loreId) || loreId <= 0) {
                    console.warn('[Bookmark] Invalid lore target:', bm);
                    return false;
                }
                await startLoreMode(loreId, true);
                await waitForContentSwitchIdle(`${reason}:switch-lore`);
                return getActiveContentKey() === `lore${loreId}`;
            }

            if (targetKey === MAIN_CONTENT_KEY) {
                if (isLoreMode) {
                    await restoreMainAudio({ saveCurrent: true, forceResume: true });
                    await waitForContentSwitchIdle(`${reason}:switch-main`);
                }
                return getActiveContentKey() === MAIN_CONTENT_KEY;
            }

            return false;
        }

        function renderBookmarks() {
            const list = document.getElementById('bookmarkList');
            if (!list) return;
            list.innerHTML = '';

            if (!window.GameState) return;
            const bookmarks = window.GameState.getBookmarks();

            if (bookmarks.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bookmark-empty-msg';
                empty.innerText = 'Keine Lesezeichen gesetzt';
                list.appendChild(empty);
                return;
            }

            bookmarks.forEach(bm => {
                const item = document.createElement('div');
                item.className = 'menu-item bookmark-item';

                const mainText = document.createElement('div');
                mainText.className = 'item-main-text';
                const timeStr = window.GameState.formatBookmarkTime(bm.time);
                mainText.innerText = `${bm.chapterTitle} · ${timeStr}`;

                const subText = document.createElement('div');
                subText.className = 'item-sub-text';
                subText.innerText = bm.textPreview || '';

                const delBtn = document.createElement('button');
                delBtn.className = 'bookmark-delete-btn';
                delBtn.innerHTML = '&times;';
                delBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await window.GameState.removeBookmark(bm.id);
                    renderBookmarks();
                });

                item.appendChild(mainText);
                item.appendChild(subText);
                item.appendChild(delBtn);

                item.addEventListener('click', async () => {
                    document.getElementById('archiveModal').classList.remove('visible');
                    const targetPage = (typeof bm.page === 'string' && bm.page) ? bm.page : CURRENT_PAGE;
                    const targetContentKey = resolveBookmarkContentKey(bm);
                    const isLoreBookmark = /^lore\d+$/i.test(targetContentKey);

                    if (targetPage === CURRENT_PAGE || isLoreBookmark) {
                        const reason = isLoreBookmark
                            ? `bookmark:${bm.id}:lore-local`
                            : `bookmark:${bm.id}:same-page`;
                        const ready = await ensureBookmarkContentForCurrentPage(bm, reason);
                        if (!ready) {
                            console.warn('[Bookmark] Could not activate target content on current page.', bm);
                            return;
                        }
                        await seekAndSyncSubtitle(bm.time, `bookmark:${bm.id}`);
                        if (audioPlayer.paused) {
                            try { await audioPlayer.play(); } catch (_) { }
                        }
                    } else {
                        await waitForContentSwitchIdle('bookmark:cross-page');
                        await saveCurrentContentState({ reason: 'bookmark:navigate' });
                        sessionStorage.setItem('bookmark_seek_target', JSON.stringify(bm));
                        const key = resolveBookmarkPageKey(targetPage);
                        markChapterAutoplayIntent(key, 'manual', 'bookmark');
                        writeStateHandoff(key);
                        window.location.href = targetPage;
                    }
                });

                list.appendChild(item);
            });
        }

        // --- MENU LOGIC ---
        function renderArchive() {
            const list = document.getElementById('loreList');
            list.innerHTML = '';

            if (!window.GameState) return;

            const db = window.GameState.getAllLore();
            const collectedIds = window.GameState.state.collectedLore;

            if (collectedIds.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'bookmark-empty-msg';
                empty.innerText = 'Keine Lore gefunden';
                list.appendChild(empty);
            } else {
                collectedIds.sort((a, b) => a - b).forEach(id => {
                    const content = db[id];
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'menu-item';

                    if (isLoreMode && activeLoreId === id) {
                        item.classList.add('active');
                    }

                    const mainText = document.createElement('div');
                    mainText.className = 'item-main-text';
                    mainText.innerText = content.title;

                    const subText = document.createElement('div');
                    subText.className = 'item-sub-text';
                    subText.innerText = content.duration;

                    item.appendChild(mainText);
                    item.appendChild(subText);

                    item.addEventListener('click', async () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        await waitForContentSwitchIdle(`menu:lore:${id}`);
                        await startLoreMode(id, true);
                    });
                    list.appendChild(item);
                });
            }
            // (Chapter Logic continues inside renderArchive)

            // Aktiven Kapitel-Button markieren
            document.querySelectorAll('#chapterList .menu-item').forEach(btn => btn.classList.remove('active'));
            const _activeCh = document.getElementById(LEVEL.activeChapterBtn);
            if (_activeCh) _activeCh.classList.add('active');

            // Chapter Logic (Left Column)
            const ch1 = document.getElementById('chapter1Btn');
            if (ch1) {
                const newCh1 = ch1.cloneNode(true);
                ch1.parentNode.replaceChild(newCh1, ch1);

                newCh1.addEventListener('click', async () => {
                    console.log("Loading Chapter 1...");
                    if (LEVEL.contentKey !== 'kapitel1') {
                        // Wir sind auf einem anderen Level – navigiere zu Marktplatz
                        await waitForContentSwitchIdle('chapter-menu:to-1');
                        await saveCurrentContentState({ reason: 'chapter-menu:to-1' });
                        markChapterAutoplayIntent('kapitel1', 'manual', 'chapter-menu');
                        writeStateHandoff('kapitel1');
                        window.location.href = 'index.html';
                        return;
                    }
                    document.getElementById('archiveModal').classList.remove('visible');

                    // 1. RE-LOAD MAP (Only if needed)
                    // If we are already here, do not reload map!
                    // processMap(mapImg); // REMOVED to prevent reload

                    // 2. Audio Logic
                    if (isLoreMode) {
                        // If listening to Lore, switch back to Chapter
                        restoreMainAudio({ forceResume: true });
                    } else {
                        // If already in Chapter mode, maybe just unpause?
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        }
                    }
                });
            }

            // Chapter 1b Logic
            const ch1b = document.getElementById('chapter1bBtn');
            if (ch1b) {
                // Remove old listeners by cloning (if any exist spread from updates)
                const newCh1b = ch1b.cloneNode(true);
                ch1b.parentNode.replaceChild(newCh1b, ch1b);

                newCh1b.addEventListener('click', async () => {
                    console.log("Loading Chapter 1b...");
                    await waitForContentSwitchIdle('chapter-menu:to-1b');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1b' });
                    markChapterAutoplayIntent('liminal_library', 'manual', 'chapter-menu');
                    writeStateHandoff('liminal_library');
                    window.location.href = 'liminal library.html';
                });
            }

            // Chapter 1c Logic
            const ch1c = document.getElementById('chapter1cBtn');
            if (ch1c) {
                const newCh1c = ch1c.cloneNode(true);
                ch1c.parentNode.replaceChild(newCh1c, ch1c);

                newCh1c.addEventListener('click', async () => {
                    console.log("Loading Chapter 1c...");
                    if (LEVEL.contentKey === 'kapitel1c') {
                        // Bereits auf Steingasse – Audio fortsetzen
                        document.getElementById('archiveModal').classList.remove('visible');
                        if (isLoreMode) {
                            restoreMainAudio({ forceResume: true });
                        } else {
                            if (audioPlayer.paused) {
                                audioPlayer.play();
                                iconPlay.style.display = 'none';
                                iconPause.style.display = 'block';
                            }
                        }
                        return;
                    }
                    await waitForContentSwitchIdle('chapter-menu:to-1c');
                    await saveCurrentContentState({ reason: 'chapter-menu:to-1c' });
                    markChapterAutoplayIntent('kapitel1c', 'manual', 'chapter-menu');
                    writeStateHandoff('kapitel1c');
                    window.location.href = 'index.html?chapter=kapitel1c';
                });
            }
        }

        // LEGACY - DEACTIVATED
        // LEGACY REMOVED

        // EVENT LISTENERS FOR ARCHIVE
        document.getElementById('bookBtn').addEventListener('click', () => {
            renderArchive();
            document.getElementById('archiveModal').classList.add('visible');
        });

        document.getElementById('closeArchiveBtn').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('visible');
        });

        // SAVE / LOAD LOGIC
        const btnSave = document.getElementById('btnSaveData');
        const btnLoad = document.getElementById('btnLoadData');
        const fileInput = document.getElementById('fileInputSave');

        if (btnSave) {
            btnSave.addEventListener('click', () => {
                if (!window.GameState) return;
                const json = window.GameState.exportState();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'liminal_save_' + Date.now() + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        if (btnLoad) {
            btnLoad.addEventListener('click', () => {
                if (fileInput) fileInput.click();
            });
        }

        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (window.GameState) {
                        const success = await window.GameState.importState(ev.target.result);
                        if (success) {
                            alert("Save Data Imported Successfully! Reloading...");
                            window.location.reload();
                        } else {
                            alert("Invalid Save File.");
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        // YellowLight class - now loaded from assets/js/shared-game-systems.js

        // Click-to-Move für Mobile
        let moveTarget = null; // {x, y} oder null

        // ============================================
        // PARTIKEL SYSTEM
        // ============================================
        const particles = [];
        const NUM_PARTICLES = 300; // Reduziert um 50%
        let particleSprite = null;

        // Spotlight-System: Sammelt Lichtquellen mit Richtung und Intensität
        let nearbyLights = []; // {x, y, intensity}

        // Dust-Particles: Staubwolken beim Laufen
        const dustParticles = [];

        // Screen-Shake bei Kollision
        let screenShake = 0;

        // Wolken-System (Parallax, selten)
        const clouds = [];
        const MAX_CLOUDS = 3;
        let cloudSpawnTimer = 0;

        // Cloud class and initClouds() - now loaded from assets/js/shared-game-systems.js

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        const footstepSound = new SCAudioAdapter();
        footstepSound.src = getSCUrl('assets/footsteps.mp3');
        footstepSound.volume = AUDIO_PROFILE.footsteps;
        // Index uses its own lifecycle handler below; avoid double pause/resume races.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(footstepSound);
        }

        const shimmerSound = new SCAudioAdapter();
        shimmerSound.src = getSCUrl('assets/shimmer.mp3');
        shimmerSound.volume = 0.4;
        // One-shot SFX should not auto-resume after visibility changes.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(shimmerSound);
        }
        let lastShimmerLightId = null;
        let footstepPlaying = false;

        let audioUnlocked = false;

        // createGlowSprite(), Particle class, and initParticles()
        // now loaded from assets/js/shared-game-systems.js

        // ============================================
        // LORE PERSISTENCE - Uses GameState module
        // ============================================
        // NOTE: LoreSystem object was REMOVED (redundant with GameState.js)
        // All lore persistence is now handled by GameState:
        // - GameState.unlockLore(id) - unlock a lore entry
        // - GameState.isUnlocked(id) - check if unlocked
        // - GameState.collectLight(sceneName, lightId) - mark light as collected
        // - GameState.isLightCollected(sceneName, lightId) - check light status


        let mapW = 0, mapH = 0;

        // Dynamische Auflösung
        let SCREEN_W = 320;
        let SCREEN_H = 240;

        function updateDimensions() {
            // Robust Responsive Logic
            // Aim for maintaining pixel density while filling the screen.
            // Base resolution reference: 320x240 (4:3)

            const targetRatio = 320 / 240; // 1.333
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const winRatio = winW / winH;

            if (winRatio > targetRatio) {
                // Window is wider than 4:3 (Landscape / Wide)
                // Fix Height at 240, expand Width
                SCREEN_H = 240;
                SCREEN_W = Math.ceil(SCREEN_H * winRatio);
            } else {
                // Window is taller/narrower than 4:3 (Portrait / Square)
                // Fix Width at 320, expand Height
                SCREEN_W = 320;
                SCREEN_H = Math.ceil(SCREEN_W / winRatio);
            }

            // Canvas Größe aktualisieren
            if (canvas) {
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;
            }
            console.log(`Resolution updated: ${SCREEN_W}x${SCREEN_H} (Win: ${winW}x${winH}, Ratio: ${winRatio.toFixed(2)})`);
        }

        // Initial und bei Resize
        // Initial resize
        updateDimensions(); // Keep the original initial call
        window.addEventListener('resize', () => { // Keep the original resize listener
            updateDimensions();
            // Auch Subtitles neu rendern falls nötig
            if (isReadingMode && subtitleTracks.length > 0) {
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // --- VISUAL CALIBRATION TOOL ---
        let params = {
            brightness: 1.15,
            contrast: 1.10,
            saturate: 0.85
        };
        let activeParam = 'brightness';

        const dispBrit = document.getElementById('dispBrit');
        const dispCont = document.getElementById('dispCont');
        const dispSat = document.getElementById('dispSat');
        const dispSel = document.getElementById('dispSel');
        const debugCanvas = document.getElementById('gameCanvas');

        window.addEventListener('keydown', (e) => {
            // Select Parameter (only if debug elements exist)
            if (e.key === '1') { activeParam = 'brightness'; if (dispSel) dispSel.innerText = 'Brightness'; }
            if (e.key === '2') { activeParam = 'contrast'; if (dispSel) dispSel.innerText = 'Contrast'; }
            if (e.key === '3') { activeParam = 'saturate'; if (dispSel) dispSel.innerText = 'Saturation'; }

            // Adjust
            if (e.key === '+' || e.key === 'Add' || e.key === '=') {
                params[activeParam] = Math.round((params[activeParam] + 0.05) * 100) / 100;
                updateVisuals();
            } else if (e.key === '-' || e.key === 'Subtract' || e.key === '_') {
                params[activeParam] = Math.round((params[activeParam] - 0.05) * 100) / 100;
                updateVisuals();
            }
        });

        function updateVisuals() {
            // Apply override to canvas
            // Standard PAL structure
            if (debugCanvas) debugCanvas.style.filter = `url(#pal-filter) contrast(${params.contrast}) brightness(${params.brightness}) saturate(${params.saturate})`;

            if (dispBrit) dispBrit.innerText = params.brightness.toFixed(2);
            if (dispCont) dispCont.innerText = params.contrast.toFixed(2);
            if (dispSat) dispSat.innerText = params.saturate.toFixed(2);

            console.log(`Params: B=${params.brightness}, C=${params.contrast}, S=${params.saturate}`);
        }
        // Initialize with default values once to ensure UI matches
        // updateVisuals();
        // End of VISUAL CALIBRATION TOOL

        let camX = 0, camY = 0;
        let targetCamX = 0, targetCamY = 0;

        // Sprite Sheet Konfiguration
        const SPRITE = {
            frameWidth: 0,   // Wird berechnet
            frameHeight: 0,  // Wird berechnet
            cols: 4,         // 4 Frames pro Reihe
            baseScale: 0.15, // Original Skalierung
            scale: 0.15      // Dynamische Skalierung
        };

        // Spieler
        const player = {
            x: 50, y: 50,
            w: 14, h: 8,      // Kollisionsbox (Füße)
            speed: 35,        // Pixels per second (was 0.54 per frame)
            dir: 0,           // 0=down, 1=up, 2=left, 3=right
            frame: 0,         // 0-3 für Animation
            animTimer: 0,
            isMoving: false,
            isBehindForeground: false
        };

        const keys = {};

        // ============================================
        // SPRITES LADEN (alle 4 Richtungen)
        // ============================================
        let spriteFront = null;   // Frontalansicht (down)
        let spriteBack = null;    // Rückenansicht (up)
        let spriteSide = null;    // Seitenansicht (right, links wird gespiegelt)
        let spritesLoaded = 0;
        const TOTAL_SPRITES = 3;

        function loadAllSprites() {
            // Frontal (nach unten schauend, NEU: spriteneu.png)
            spriteFront = new Image();
            spriteFront.onload = function () {
                // WICHTIG: Math.floor() für ganzzahlige Frame-Breite!
                SPRITE.frameWidth = Math.floor(this.width / SPRITE.cols); // Fallback-Wert, wird für DrawCoords überschrieben
                SPRITE.frameHeight = this.height;
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log(`Sprite Front (New) geladen: ${this.width}x${this.height}`);
            };
            spriteFront.src = 'assets/spriteneu.png';
            spriteFront.onerror = () => console.warn('assets/spriteneu.png nicht gefunden');

            // Rücken (nach oben schauend, NEU: spriterueckenneu.png)
            spriteBack = new Image();
            spriteBack.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Back (New) geladen');
            };
            spriteBack.src = 'assets/spriterueckenneu.png';
            spriteBack.onerror = () => console.warn('assets/spriterueckenneu.png nicht gefunden');

            // Seitlich (für rechts, links wird gespiegelt)
            spriteSide = new Image();
            spriteSide.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Side (New) geladen');
            };
            spriteSide.src = 'assets/seitlichneu.png';
            spriteSide.onerror = () => console.warn('assets/seitlichneu.png nicht gefunden');
        }

        // Front (spriteneu.png)
        const FRONT_SPRITE_DATA = [
            { left: 38, width: 141, footX: 106, footY: 267 },
            { left: 201, width: 138, footX: 273, footY: 265 },
            { left: 361, width: 140, footX: 436, footY: 270 },
            { left: 534, width: 137, footX: 604, footY: 268 }
        ];
        // Ping-Pong Animation für Front (0-1-2-3-2-1)
        const FRONT_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        // Back (spriterueckenneu.png)
        const BACK_SPRITE_DATA = [
            { left: 16, width: 147, footX: 90, footY: 282 },
            { left: 177, width: 144, footX: 253, footY: 283 },
            { left: 336, width: 152, footX: 417, footY: 285 }
        ];
        // Ping-Pong Animation für Back (0-1-2-1)
        const BACK_ANIM_CYCLE = [0, 1, 2, 1];

        // NEU: Marker-Daten für seitlichneu.png (X, Y)
        const SIDE_SPRITE_DATA = [
            { left: 20, footX: 92, footY: 275 },
            { left: 200, footX: 268, footY: 281 },
            { left: 372, footX: 440, footY: 280 },
            { left: 528, footX: 595, footY: 284 }
        ];

        // Ping-Pong Animation für Seitlich (0-1-2-3-2-1)
        const SIDE_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        function checkAllSpritesLoaded() {
            if (spritesLoaded >= TOTAL_SPRITES) {
                spriteReady = true;
                console.log('Alle Sprites geladen!');
            }
        }

        // DEBUG HELPER
        window.logDebug = function (msg) {
            console.log("[DEBUG]", msg);
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML += msg + "<br>";
                const lines = d.innerHTML.split("<br>");
                if (lines.length > 6) d.innerHTML = lines.slice(lines.length - 6).join("<br>");
            }
        };

        window.addEventListener('load', () => {
            const pal = document.getElementById('pal-filter');
            const glitch = document.getElementById('glitch-filter');
            logDebug("Filters: PAL=" + (pal ? "OK" : "NO") + " GLITCH=" + (glitch ? "OK" : "NO"));

            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const style = window.getComputedStyle(canvas);
                const filter = style.getPropertyValue('filter');
                logDebug("Canvas Filter: " + ((filter && filter !== 'none') ? "ACTIVE" : "NONE"));
            }
        });

        loadAllSprites();

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // GLOBAL ERROR HANDLER (DEBUG)
        // ============================================
        window.onerror = function (msg, url, line, col, error) {
            const rawMessage = String(msg || (error && error.message) || '');
            const lowered = rawMessage.toLowerCase();
            const isFullscreenNoise =
                lowered.includes('fullscreen') ||
                lowered.includes('requestfullscreen') ||
                lowered.includes('webkitfullscreen');

            if (isFullscreenNoise) {
                console.warn('[NonFatal][Fullscreen]', rawMessage, error || '');
                return true;
            }

            const pi = document.getElementById('processingInfo');
            if (pi && !gameReady) {
                pi.style.display = 'block';
                pi.style.color = '#ff5555';
                pi.style.background = 'rgba(0,0,0,0.9)';
                pi.innerText = 'Ein Fehler ist beim Laden aufgetreten.';
                if (line) {
                    pi.innerText += "\nLine: " + line;
                }
            }
            console.error(rawMessage, error);
            return false;
        };

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        window.addEventListener('DOMContentLoaded', async () => {
            console.log("Electron Mode: Auto-Loading...");

            // 0. IMMEDIATE AUDIO PRELOAD (User Request: Buffer early)
            // WRAPPED IN TRY-CATCH TO PREVENT CRASHING THE LOADING SCREEN
            try {
                const mainAudioSrc = window.mainAudioUrl || LEVEL.audioUrl;
                window.mainAudioUrl = mainAudioSrc;
                if (typeof getSCUrl === 'function' && typeof audioPlayer !== 'undefined') {
                    const scUrl = getSCUrl(mainAudioSrc);
                    audioPlayer.src = scUrl;
                    if (audioPlayer.mode === 'html5' && audioPlayer.audioNode) {
                        audioPlayer.audioNode.preload = "auto";
                        // audioPlayer.audioNode.load(); // Reduced aggression to prevent hang
                        console.log("Audio Preloading Configured (Lazy)");
                    }
                } else {
                    console.warn("AudioPlayer or getSCUrl not ready yet.");
                }
            } catch (e) {
                console.warn("Audio Preload Failed (Non-Fatal):", e);
            }

            // RESTORE READING MODE STATE
            const savedMode = localStorage.getItem('gameboy_reading_mode');
            if (savedMode === 'true') {
                isReadingMode = true;
                const ui = document.getElementById('audioPlayerUI');
                if (ui) ui.classList.add('reading-mode');
            }
            // Load watchdog: never start the game loop without a loaded map.
            const loadingScreen = document.getElementById('loading-screen');
            const processingInfo = document.getElementById('processingInfo');
            const dropZone = document.getElementById('dropZone');

            setTimeout(() => {
                if (gameReady) return;

                console.warn("Map still not ready after 10s. Waiting for map load instead of force-start.");
                if (dropZone && !dropZone.classList.contains('hidden')) dropZone.classList.add('hidden');

                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ffd54a';
                    processingInfo.style.background = 'rgba(0,0,0,0.75)';
                    processingInfo.innerText = 'Map is still loading... please wait.';
                }

                if (loadingScreen) loadingScreen.style.display = 'flex';
            }, 10000);

            // 1. Load Map (Default)
            const mapImg = new Image();
            mapImg.onload = () => {
                console.log("Map Loaded, processing...");
                try {
                    processMap(mapImg);
                } catch (e) {
                    console.error("Critical: processMap crashed!", e);
                }
            };
            mapImg.onerror = (e) => {
                console.error("Map Load Error", e);
                if (processingInfo) {
                    processingInfo.style.display = 'block';
                    processingInfo.style.color = '#ff5555';
                    processingInfo.style.background = 'rgba(0,0,0,0.85)';
                    processingInfo.innerText = 'Map failed to load. Please reload the page.';
                }
                if (loadingScreen) loadingScreen.style.display = 'flex';
            };
            mapImg.src = LEVEL.mapFile;

            // 2. Load Audio & Text (Chapter 1) -> Audio already preloaded above!
            // const mainAudioSrc = 'assets/kapitel1.mp3'; // Removed redundant def

            const attemptAutoPlay = async () => {
                if (!mainChapterAutoplayIntent.shouldAutoplay) {
                    indexDebugNote('autoplay', `suppressed policy=${mainChapterAutoplayIntent.policy} reason=${mainChapterAutoplayIntent.reason}`);
                    syncPlayPauseIcon();
                    return false;
                }
                const started = await verifyPlaybackStarted(3, 320);
                indexDebugNote('autoplay', `boot started=${started} source=${mainChapterAutoplayIntent.source} reason=${mainChapterAutoplayIntent.reason}`);
                syncPlayPauseIcon();
                return started;
            };

            try {
                // debugLog('Fetching subtitle file...');
                const response = await fetch(LEVEL.subtitleFile);
                // debugLog('Fetch response: ' + response.status);
                const text = await response.text();
                // debugLog('Text length: ' + text.length);
                window.mainTextContent = text;
                parseSubtitles(text);
                // debugLog('subtitleTracks: ' + subtitleTracks.length);
                renderSubtitleLines(0);
                // debugLog('Chapter 1 Loaded OK');

                await attemptAutoPlay();

                // --- BOOKMARK SEEK ON LOAD ---
                const bmTarget = sessionStorage.getItem('bookmark_seek_target');
                if (bmTarget) {
                    sessionStorage.removeItem('bookmark_seek_target');
                    try {
                        const target = JSON.parse(bmTarget);
                        const time = Number(target && target.time);
                        if (Number.isFinite(time) && time >= 0) {
                            console.log(`[Bookmark] Seeking to bookmarked time: ${time}s`);
                            setTimeout(async () => {
                                try {
                                    const targetPage = (target && typeof target.page === 'string' && target.page) ? target.page : CURRENT_PAGE;
                                    const targetContentKey = resolveBookmarkContentKey(target);
                                    const isLoreTarget = /^lore\d+$/i.test(targetContentKey);
                                    if (targetPage !== CURRENT_PAGE && !isLoreTarget) {
                                        console.warn('[Bookmark] Ignored stale on-load bookmark target for other page.', targetPage);
                                        return;
                                    }

                                    const ready = await ensureBookmarkContentForCurrentPage(target, 'bookmark:on-load');
                                    if (!ready) {
                                        console.warn('[Bookmark] Could not activate bookmark target content on load.', target);
                                        return;
                                    }

                                    await seekAndSyncSubtitle(time, 'bookmark:on-load');
                                    if (audioPlayer.paused) {
                                        try { await audioPlayer.play(); } catch (_) { }
                                    }
                                    syncPlayPauseIcon();
                                } catch (e) {
                                    console.warn('[Bookmark] Failed to apply on-load bookmark target:', e);
                                }
                            }, 800);
                        }
                    } catch (e) {
                        console.warn('[Bookmark] Failed to parse seek target:', e);
                    }
                }
            } catch (e) {
                debugLog('Chapter 1 Load ERROR: ' + e.message);
                window.mainTextContent = "";
                subtitleTracks = [];
            }

            // 2b. Preload Lore 1 Text
            try {
                const lRes = await fetch('assets/lore1.txt');
                loreData.text[1] = await lRes.text();
                console.log("Lore 1 Loaded");
            } catch (e) {
                console.error("Lore 1 Text Load Error:", e);
                loreData.text[1] = "";
            }

            // Always show UI
            if (typeof uiContainer !== 'undefined' && uiContainer) uiContainer.style.display = 'flex';

            // 3. Load Save Game
            // Handled by generic GameState.init() called at top of script
            // if (window.electronAPI) { ... }
        });

        // Helper for manual image loading (optional debugging)
        function loadImageFile(file) {
            processingInfo.style.display = 'block';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => setTimeout(() => processMap(img), 50);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // KEYBOARD
        // ============================================
        // Toggle State
        let usePAL = true;
        let useHalftone = true;

        function updateFilterStyle() {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;

            let filters = [];
            if (usePAL) filters.push('url(#pal-filter)');
            // Halftone is usually a CSS class or overlay?
            // If it's the SVG glitch:
            if (useHalftone) filters.push('url(#glitch-filter)');
            // Note: Halftone dots is often a CSS overlay DIV, not SVG filter.
            // But user said "2" -> halftone dots.
            // I'll check if there is a .halftone class.
            // If not, I'll toggle the GLITCH filter (since "Glitch=NO" was the issue).

            canvas.style.filter = filters.join(' ');

            // Also update Debug
            const d = document.getElementById('debugLog');
            if (d) {
                d.innerHTML = `Filters: PAL=${usePAL ? 'ON' : 'OFF'} GLITCH=${useHalftone ? 'ON' : 'OFF'}<br>CANVAS: ${canvas.style.filter}`;
            }
        }

        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
                // CRITICAL FIX: Ensure Audio Player NEVER has focus, preventing "fast forward"
                // if (audioPlayer) audioPlayer.blur();
                document.body.focus();
            }
            // TOGGLES
            if (e.key === '1') { usePAL = !usePAL; updateFilterStyle(); }
            if (e.key === '2') { useHalftone = !useHalftone; updateFilterStyle(); }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            // Tastendruck bricht Click-to-Move ab
            moveTarget = null;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Click-to-Move für Mobile
        function handleClickMove(screenX, screenY) {
            if (!gameReady) return;

            // Berechne Welt-Koordinaten aus Screen-Koordinaten
            const rect = canvas.getBoundingClientRect();
            // CSS-Pixel zu Canvas-Pixel Umrechnung
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;

            // Welt-Position = Canvas-Position + Kamera-Offset
            const worldX = canvasX + camX;
            const worldY = canvasY + camY;

            // Setze Ziel (Spieler-Mitte soll dort hin)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            moveTarget = {
                x: worldX - spriteW / 2,
                y: worldY - spriteH / 2
            };
        }

        canvas.addEventListener('click', e => {
            // Guard: Ignore if clicking UI buttons (propagated events)
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            handleClickMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            // Guard: Ignore if touching UI
            if (e.target !== canvas && e.target.tagName !== 'CANVAS') return;
            e.preventDefault();
            if (e.touches.length > 0) {
                handleClickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // ============================================
        // MAP PROCESSING
        // ============================================
        // ============================================
        // MAP PROCESSING (NUCLEAR FALLBACK VERSION)
        // ============================================
        // ============================================
        // MAP PROCESSING (ADVANCED RESTORED)
        // ============================================

        // --- AUTO-WALK PATH SORTER (Pure Nearest Neighbor) ---
        // Immer den ALLERNÄCHSTEN Pixel. Keine Bereiche, keine Schwellen.
        function sortAutoWalkPath(pixels, startPoint) {
            if (pixels.length === 0) return [];

            const path = [];
            let pool = [...pixels];

            // 1. Startpunkt: Der Pixel, der am nächsten zum Spawn liegt.
            let minDistSq = Infinity;
            let startIndex = -1;

            for (let i = 0; i < pool.length; i++) {
                const dx = pool[i].x - startPoint.x;
                const dy = pool[i].y - startPoint.y;
                const dSq = dx * dx + dy * dy;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    startIndex = i;
                }
            }

            if (startIndex === -1) return [];

            let current = pool.splice(startIndex, 1)[0];
            path.push(current);

            // 2. Stur: Immer den ALLERNÄCHSTEN noch nicht besuchten Pixel wählen.
            while (pool.length > 0) {
                let bestIndex = -1;
                let bestDistSq = Infinity;

                for (let i = 0; i < pool.length; i++) {
                    const dx = pool[i].x - current.x;
                    const dy = pool[i].y - current.y;
                    const dSq = dx * dx + dy * dy;

                    if (dSq < bestDistSq) {
                        bestDistSq = dSq;
                        bestIndex = i;
                    }
                }

                // Immer nehmen, egal wie weit weg.
                if (bestIndex !== -1) {
                    current = pool.splice(bestIndex, 1)[0];
                    path.push(current);
                } else {
                    break;
                }
            }

            console.log(`Auto-Walk Path (Pure Nearest): ${path.length} nodes.`);
            return path;
        }

        function processMap(img) {
            console.log("Processing Map (Advanced):", img.width, "x", img.height);
            mapW = img.width;
            mapH = img.height;

            SCREEN_W = Math.min(mapW, window.innerWidth);
            SCREEN_H = Math.min(mapH, window.innerHeight);
            canvas.width = SCREEN_W;
            canvas.height = SCREEN_H;

            // VISUAL DEBUG
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.innerText = "PROCESSING PIXELS...";
                pi.style.display = 'block';
            }

            // ATTEMPT PIXEL PROCESSING
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapW;
                tempCanvas.height = mapH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imgData = tempCtx.getImageData(0, 0, mapW, mapH);
                const data = imgData.data;

                // 1. Initialisieren der Arrays
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                foregroundData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                flowData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));

                magentaPixels = [];
                cyanPixels = new Set();
                greenPixels = [];
                greenPixels = [];
                let orangePixels = []; // For Auto-Walk
                yellowLights = []; // Init global var
                let spawnPixel = null;

                // 2. Scan-Pass
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const i = (y * mapW + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Magenta = Kollision
                        if (r > 200 && g < 80 && b > 200) {
                            collisionData[y][x] = true;
                            magentaPixels.push({ x, y, i });
                        }
                        // Cyan = Vordergrund
                        else if (r < 80 && g > 200 && b > 200) {
                            cyanPixels.add(`${x},${y}`);
                        }
                        // Grün = Flow (Lichter)
                        else if (r < 80 && g > 200 && b < 80) {
                            flowData[y][x] = true;
                            greenPixels.push({ x, y, i });
                        }
                        // GELB = Lore Trigger (#FFFF00)
                        else if (r > 250 && g > 250 && b < 10) {
                            const id = yellowLights.length + 1;
                            yellowLights.push(new YellowLight(x, y, id));
                        }
                        // BLAU = Spawn Punkt (#0000FF)
                        else if (r < 50 && g < 50 && b > 200) {
                            if (!spawnPixel) spawnPixel = { x, y, i };
                        }
                        // ORANGE = Auto-Walk Pfad (#FFA500 -> R>240, G~165, B<50)
                        else if (r > 240 && g > 130 && g < 200 && b < 50) {
                            orangePixels.push({ x, y, i });
                        }
                    }
                }

                // 3. Flood Fill Cyan
                if (cyanPixels.size > 0) findEnclosedAreas(cyanPixels, mapW, mapH);

                // 4. Pixel Hiding (Flow, Lore, Spawn)
                // Use pullNearbyPixel to hide the debug colors

                // 5. Magenta Cleanup & Wall Dilatation (Robust Collision)
                const extraWalls = [];
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (collisionData[y][x]) {
                            if (x > 0) extraWalls.push({ x: x - 1, y: y });
                            if (x < mapW - 1) extraWalls.push({ x: x + 1, y: y });
                            if (y > 0) extraWalls.push({ x: x, y: y - 1 });
                            if (y < mapH - 1) extraWalls.push({ x: x, y: y + 1 });
                        }
                    }
                }
                for (const w of extraWalls) {
                    collisionData[w.y][w.x] = true;
                }

                // Restore Magenta Pixels visually
                for (const mp of magentaPixels) {
                    const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                    data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;
                }
                for (const gp of greenPixels) {
                    const repl = pullNearbyPixel(data, gp.x, gp.y, mapW, mapH, cyanPixels);
                    data[gp.i] = repl.r; data[gp.i + 1] = repl.g; data[gp.i + 2] = repl.b;
                }
                for (const yl of yellowLights) {
                    const i = (yl.y * mapW + yl.x) * 4;
                    const repl = pullNearbyPixel(data, yl.x, yl.y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }
                if (spawnPixel) {
                    const repl = pullNearbyPixel(data, spawnPixel.x, spawnPixel.y, mapW, mapH, cyanPixels);
                    data[spawnPixel.i] = repl.r; data[spawnPixel.i + 1] = repl.g; data[spawnPixel.i + 2] = repl.b;
                }

                // 4b. Process Auto-Walk Path
                if (orangePixels.length > 0) {
                    // Sort path starting from spawn (or map center)
                    const startRef = spawnPixel || { x: mapW / 2, y: mapH / 2 };

                    // Direct Sort (Strict 1px)
                    autoWalkPath = sortAutoWalkPath(orangePixels, startRef);
                    autoWalkIndex = 0;

                    // Hide Orange Pixels
                    for (const op of orangePixels) {
                        const repl = pullNearbyPixel(data, op.x, op.y, mapW, mapH, cyanPixels);
                        data[op.i] = repl.r; data[op.i + 1] = repl.g; data[op.i + 2] = repl.b;
                    }
                }

                // 5. Magenta Cleanup
                // Multi-pass to fill large magenta areas from outside in
                let remainingMagenta = [...magentaPixels];
                const maxPasses = 10;
                for (let pass = 0; pass < maxPasses && remainingMagenta.length > 0; pass++) {
                    const stillRemaining = [];
                    for (const mp of remainingMagenta) {
                        const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                        // If result is the fallback gray (60,55,50), it means no neighbor found yet
                        // But wait, pullNearbyPixel returns fallback if nothing found. 
                        // We need a way to know if it found something good. 
                        // For now, let's just accept the replacement. The loop is fine.
                        data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;

                        // Heuristic: If we are deep inside magenta, we might get gray. 
                        // Ideally we want to wait for neighbors. But this is fast enough.
                    }
                    remainingMagenta = []; // Assume processed (simplification for speed)
                }

                // 6. Cyan Cleanup
                for (const cp of cyanPixels) {
                    const [x, y] = cp.split(',').map(Number);
                    const i = (y * mapW + x) * 4;
                    const repl = pullNearbyPixel(data, x, y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }

                // 7. Create Foreground/Background Layers
                const bgData = new Uint8ClampedArray(data);
                const fgData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < fgData.length; i += 4) fgData[i + 3] = 0; // Clear Alpha

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (foregroundData[y][x]) {
                            const i = (y * mapW + x) * 4;
                            fgData[i] = data[i];
                            fgData[i + 1] = data[i + 1];
                            fgData[i + 2] = data[i + 2];
                            fgData[i + 3] = 255;
                        }
                    }
                }

                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = mapW; bgCanvas.height = mapH;
                bgCanvas.getContext('2d').putImageData(new ImageData(bgData, mapW, mapH), 0, 0);

                const fgCanvas = document.createElement('canvas');
                fgCanvas.width = mapW; fgCanvas.height = mapH;
                fgCanvas.getContext('2d').putImageData(new ImageData(fgData, mapW, mapH), 0, 0);

                bgImage = new Image();
                foregroundImage = new Image();

                bgImage.onload = () => {
                    gameReady = true;
                    if (document.getElementById('processingInfo')) document.getElementById('processingInfo').style.display = 'none';
                    if (document.getElementById('dropZone')) document.getElementById('dropZone').classList.add('hidden');
                    // Hide Loading Screen
                    const ls = document.getElementById('loading-screen');
                    if (ls) ls.style.display = 'none';

                    if (spawnPixel) {
                        // FIX: Blue pixel marks FOOT position, not sprite top
                        // Robust: use the same spriteH logic as checkCollisionAt

                        // 1. Update scale for spawn depth (initial guess)
                        if (mapH > 0) {
                            const yNorm = Math.max(0, Math.min(1, spawnPixel.y / mapH));
                            const depthFactor = 0.5 + (0.8 * yNorm);
                            SPRITE.scale = SPRITE.baseScale * depthFactor;
                        }

                        const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                        const FOOT_OFFSET_Y = 15; // Must match checkCollisionAt

                        player.x = spawnPixel.x - 8; // Center horizontally
                        player.y = spawnPixel.y - spriteH - FOOT_OFFSET_Y; // Feet at spawnPixel.y

                        console.log(`Spawn: Blue(${spawnPixel.x},${spawnPixel.y}) -> Feet at Y=${spawnPixel.y}, SpriteH=${spriteH.toFixed(1)}, Player.y=${player.y.toFixed(1)}`);
                    } else {
                        player.x = mapW / 2;
                        player.y = mapH / 2;
                    }

                    // Center Camera
                    camX = targetCamX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                    camY = targetCamY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));

                    // Init Extras
                    initParticles();
                    initClouds();

                    // Start Audio (aux tracks are gated to avoid SC widget pause races)
                    if (typeof ambientAudio !== 'undefined') {
                        syncAuxScPlayback('game-ready');
                    }

                    startGameLoop();
                    console.log("Map Processed & Ready.");
                };
                bgImage.onerror = (e) => {
                    console.error("Processed background image failed to load", e);
                };
                foregroundImage.onerror = (e) => {
                    console.error("Processed foreground image failed to load", e);
                };
                bgImage.src = bgCanvas.toDataURL();
                foregroundImage.src = fgCanvas.toDataURL();


            } catch (e) {
                console.error("Advanced Processing Crash", e);
                // Fallback to RAW if crash
                bgImage = img;
                foregroundImage = null;
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false)); // Safe init
                gameReady = true;
                startGameLoop();
            }
        }

        // Fallback: Audio starten bei erster Interaktion, falls Autoplay blockiert wurde
        document.addEventListener('click', () => {
            if (gameReady && ambientAudio.paused && allowAuxScPlayback()) {
                ambientAudio.play().catch(e => console.warn("Ambient play failed:", e));
            }
        }, { once: true }); // Nur einmal ausführen

        // ============================================
        // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
        // ============================================
        let wasAmbientPlaying = false;
        let wasPlayerPlaying = false;
        let visibilityResumeToken = 0;
        window.gamePaused = false; // Flag for Game Loop
        window.visualFreezeActive = !!window.visualFreezeActive;

        document.addEventListener('visibilitychange', () => {
            const token = ++visibilityResumeToken;
            if (document.hidden) {
                // APP BACKGROUNDED -> PAUSE ALL
                window.gamePaused = true; // Stop loop logic
                saveCurrentContentState({ preferCachedTime: true, reason: 'visibility:hidden' });
                indexDebugNote('visibility', 'hidden');

                if (typeof ambientAudio !== 'undefined') {
                    wasAmbientPlaying = (typeof ambientAudio.isProbablyPlaying === 'function')
                        ? ambientAudio.isProbablyPlaying()
                        : !ambientAudio.paused;
                    ambientAudio.pause();
                    indexDebugNote('ambient', `pause hidden (wasPlaying=${wasAmbientPlaying})`);
                } else {
                    wasAmbientPlaying = false;
                }

                if (typeof audioPlayer !== 'undefined') {
                    wasPlayerPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                        ? audioPlayer.isProbablyPlaying()
                        : !audioPlayer.paused;
                    audioPlayer.pause();
                    indexDebugNote('player', `pause hidden (wasPlaying=${wasPlayerPlaying})`);
                } else {
                    wasPlayerPlaying = false;
                }

                if (typeof footstepSound !== 'undefined') footstepSound.pause();

            } else {
                // APP FOREGROUND -> RESUME IF WAS PLAYING
                // Reset time to prevent delta spikes
                lastTime = 0;
                window.gamePaused = false;
                if (!window.visualFreezeActive) {
                    startGameLoop();
                }
                indexDebugNote('visibility', 'visible');

                setTimeout(() => {
                    if (token !== visibilityResumeToken || document.hidden) return;
                    if (contentSwitchInProgress) {
                        indexDebugNote('visibility', 'resume skipped (content switch active)');
                        return;
                    }
                    applySceneAudioMix('visibility:resume');
                    if (wasAmbientPlaying && typeof ambientAudio !== 'undefined' && allowAuxScPlayback()) {
                        ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                        wasAmbientPlaying = false;
                        indexDebugNote('ambient', 'resume on visible');
                    }
                    if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                        audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                        wasPlayerPlaying = false;
                        indexDebugNote('player', 'resume on visible');
                    }
                }, 100);
            }
        });

        window.addEventListener('pagehide', () => {
            visibilityResumeToken += 1;
            saveCurrentContentState({ preferCachedTime: true, reason: 'pagehide' });
            if (typeof ambientAudio !== 'undefined') ambientAudio.pause();
            if (typeof audioPlayer !== 'undefined') audioPlayer.pause();
            indexDebugNote('lifecycle', 'pagehide');
        });

        function findSafeStart() {
            // Suche ausgehend von der Mitte nach einer Position ohne Kollision
            const startX = Math.floor(mapW / 2);
            const startY = Math.floor(mapH / 2);

            for (let radius = 0; radius < 100; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < mapW - 16 && y >= 0 && y < mapH - 16) {
                            if (!checkCollisionAt(x, y)) {
                                player.x = x;
                                player.y = y;
                                return;
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // FLOOD FILL MIT DILATATION
        // ============================================
        function findEnclosedAreas(cyanPixels, w, h) {
            const visited = new Array(h).fill(null).map(() => new Array(w).fill(0));

            // Dilatation der Cyan-Grenzen
            const dilationRadius = 2;
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                    for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) <= dilationRadius) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                visited[ny][nx] = 2;
                            }
                        }
                    }
                }
            }

            // Flood Fill vom Rand
            const queue = [];
            for (let x = 0; x < w; x++) {
                if (visited[0][x] === 0) queue.push([x, 0]);
                if (visited[h - 1][x] === 0) queue.push([x, h - 1]);
            }
            for (let y = 0; y < h; y++) {
                if (visited[y][0] === 0) queue.push([0, y]);
                if (visited[y][w - 1] === 0) queue.push([w - 1, y]);
            }

            let idx = 0;
            while (idx < queue.length) {
                const [x, y] = queue[idx++];
                if (x < 0 || x >= w || y < 0 || y >= h || visited[y][x] !== 0) continue;
                visited[y][x] = 1;
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Innere Bereiche markieren
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (visited[y][x] === 0 || visited[y][x] === 2) {
                        foregroundData[y][x] = true;
                    }
                }
            }

            // Original Cyan-Pixel auch markieren
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                foregroundData[y][x] = true;
            }
        }

        // ============================================
        // PIXEL-PULLING (Spiralförmige Suche für alle Linienrichtungen)
        // ============================================
        function pullNearbyPixel(data, x, y, w, h, cyanPixels) {
            // Spiralförmige Suche: Sucht in expandierenden Kreisen
            // Funktioniert für horizontale, vertikale UND diagonale Linien
            const maxRadius = 15;  // Maximaler Suchradius

            for (let radius = 1; radius <= maxRadius; radius++) {
                // Alle Punkte auf dem aktuellen "Quadrat-Ring" durchsuchen
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        // Nur Randpunkte des Quadrats (nicht innere)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                        const ni = (ny * w + nx) * 4;
                        const r = data[ni], g = data[ni + 1], b = data[ni + 2];

                        // Skip Magenta (Kollision) und Cyan (Vordergrund)
                        if (r > 200 && g < 80 && b > 200) continue;
                        if (r < 80 && g > 200 && b > 200) continue;
                        if (cyanPixels.has(`${nx},${ny}`)) continue;

                        // Gültiges Pixel gefunden!
                        return { r, g, b };
                    }
                }
            }

            // Fallback: Neutrales Grau-Braun (passt zu den meisten Umgebungen)
            return { r: 60, g: 55, b: 50 };
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function startGameLoop() {
            if (window.gameLoopRunning) return;
            if (window.visualFreezeActive) return;
            window.gameLoopRunning = true;
            lastTime = 0;
            console.log("startGameLoop");
            requestAnimationFrame(gameLoop);
        }

        // Global vars for timing
        let lastTime = 0;
        let autoWalkFacingLockTimer = 0;

        function chooseAutoWalkDirection(dx, dy, fallbackDir) {
            const ax = Math.abs(dx);
            const ay = Math.abs(dy);
            if (ax < 0.001 && ay < 0.001) return fallbackDir;

            // Keep current facing near diagonals to avoid rapid direction flicker.
            const dominance = Math.abs(ax - ay);
            if (dominance < 0.35) return fallbackDir;

            if (ax > ay) return dx > 0 ? 3 : 2;
            return dy > 0 ? 0 : 1;
        }

        function gameLoop(timestamp) {
            if (window.visualFreezeActive) {
                window.gameLoopRunning = false;
                return;
            }

            if (window.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Clamp DT to prevent speed spikes (e.g. after lag/pause)
            if (dt > 0.1) dt = 0.1;

            // Cap delta time (prevent spirals of death)
            if (dt > 0.1) dt = 0.1;

            // Update Game Logic
            update(dt);
            updateLoreSystem(); // Lore-Proximity prüfen

            // Draw
            draw();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // UPDATE - MIT ROBUSTER KOLLISION
        // ============================================
        function update(dt) {
            if (!dt) dt = 0.016;
            if (!gameReady) return;
            if (autoWalkFacingLockTimer > 0) {
                autoWalkFacingLockTimer = Math.max(0, autoWalkFacingLockTimer - dt);
            }

            // --- DYNAMIC SCALING (Depth Effect) ---
            if (mapH > 0) {
                // Normalisierte Y-Position (0.0 oben bis 1.0 unten)
                const yNorm = Math.max(0, Math.min(1, player.y / mapH));

                // Skalierung: 50% (oben) bis 130% (unten)
                // Formel: 0.5 + (0.8 * yNorm) -> 
                // yNorm=0 -> 0.5 | yNorm=1 -> 1.3
                const depthFactor = 0.5 + (0.8 * yNorm);

                SPRITE.scale = SPRITE.baseScale * depthFactor;
            }

            let dx = 0, dy = 0;
            player.isMoving = false;

            // Input von Tastatur
            if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) { dy = -1; player.dir = 1; }
            if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) { dy = 1; player.dir = 0; }
            if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) { dx = -1; player.dir = 2; }
            if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) { dx = 1; player.dir = 3; }

            // Click-to-Move: Wenn kein Tastatur-Input und Ziel gesetzt
            // Fix: Movement allowed during Lore (unless Reading Mode active)
            if (dx === 0 && dy === 0 && moveTarget && !isReadingMode) {
                const tdx = moveTarget.x - player.x;
                const tdy = moveTarget.y - player.y;
                const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Ziel erreicht? (innerhalb von 3px)
                if (tdist < 3) {
                    moveTarget = null;
                } else {
                    // Richtung zum Ziel
                    dx = tdx / tdist;
                    dy = tdy / tdist;

                    // Blickrichtung setzen
                    if (Math.abs(tdx) > Math.abs(tdy)) {
                        player.dir = tdx > 0 ? 3 : 2; // Rechts oder Links
                    } else {
                        player.dir = tdy > 0 ? 0 : 1; // Unten oder Oben
                    }
                }
            }

            // --- AUTO-WALK (READING MODE & COASTDOWN) ---
            if ((isReadingMode || (player.slowdownTimer > 0)) && autoWalkPath.length > 0) {
                // Initialize Slowdown Timer
                if (isReadingMode) {
                    player.slowdownTimer = 1.0; // 1 Second Coastdown buffer (float seconds now)
                } else {
                    player.slowdownTimer -= dt;
                }

                // Calculate Foot Position
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const footX = player.x + spriteW / 2;
                const footY = player.y + spriteH + 15;

                // Target logic
                let target = autoWalkPath[autoWalkIndex];
                const tdx = target.x - footX;
                const tdy = target.y - footY;
                const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                // Speed Calculation (Linked to player.speed)
                let walkSpeed = player.speed;
                if (!isReadingMode) {
                    // Coastdown Fade
                    walkSpeed *= Math.max(0, player.slowdownTimer);
                }
                const step = walkSpeed * dt;

                if (dist < 4) {
                    autoWalkIndex++;
                    if (autoWalkIndex >= autoWalkPath.length) {
                        autoWalkIndex = autoWalkPath.length - 1;
                        if (!isReadingMode) player.slowdownTimer = 0;
                    }
                }

                if (autoWalkIndex < autoWalkPath.length && player.slowdownTimer > 0) {
                    const nextTdx = target.x - footX;
                    const nextTdy = target.y - footY;
                    const nextDist = Math.sqrt(nextTdx * nextTdx + nextTdy * nextTdy);

                    if (nextDist > 1) {
                        const dx = (nextTdx / nextDist) * step;
                        const dy = (nextTdy / nextDist) * step;

                        player.x += dx;
                        player.y += dy;
                        player.isMoving = true;

                        // Direction: use a short look-ahead + hysteresis to avoid point-to-point flicker.
                        const lookAheadIndex = Math.min(autoWalkPath.length - 1, autoWalkIndex + 8);
                        const lookAheadTarget = autoWalkPath[lookAheadIndex];
                        const lookAheadDx = lookAheadTarget.x - footX;
                        const lookAheadDy = lookAheadTarget.y - footY;
                        const blendedDx = nextTdx * 0.35 + lookAheadDx * 0.65;
                        const blendedDy = nextTdy * 0.35 + lookAheadDy * 0.65;
                        const nextDir = chooseAutoWalkDirection(blendedDx, blendedDy, player.dir);
                        if (nextDir !== player.dir && autoWalkFacingLockTimer <= 0) {
                            player.dir = nextDir;
                            autoWalkFacingLockTimer = 0.14;
                        }

                        // Animation
                        player.animTimer += dt;

                        // 50% Slower Animation for Front (0) and Back (1) views

                        // 50% Slower Animation for Front/Back (0.30s vs 0.15s)
                        let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                        if (player.animTimer > animThreshold) {
                            player.animTimer = 0;
                            player.frame = (player.frame + 1) % 12;
                        }
                    }
                }
            }

            // --- MANUAL MOVEMENT ---
            if (dx !== 0 || dy !== 0) {
                player.isMoving = true;

                // Normalisieren (Diagonal Fix)
                if ((keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) && Math.abs(dx) === 1 && Math.abs(dy) === 1) {
                    const inv = 0.7071;
                    dx *= inv; dy *= inv;
                }

                // Apply Movement
                let moveSpeed = player.speed;
                if (isReadingMode) {
                    moveSpeed = player.speed * 0.175; // 50% of 35% = 17.5% (User Request: even slower)
                }

                // LOG SPEED for Debug (Throttle)
                if (player.isMoving && Math.random() < 0.01) {
                    console.log(`[DEBUG_SYS] Player Move Speed: Base=${player.speed}, Actual=${moveSpeed} (Mode=${isReadingMode ? 'READING' : 'GAME'})`);
                }

                const amount = moveSpeed * dt;

                // Collision Logic (restore if missing or use simplified slide)
                const vx = dx * amount;
                const vy = dy * amount;
                const targetX = player.x + vx;
                const targetY = player.y + vy;

                // Simple Slide or Full Collision
                // Assuming checkCollisionAt is available
                if (!checkCollisionAt(targetX, targetY)) {
                    player.x = targetX;
                    player.y = targetY;
                } else {
                    if (!checkCollisionAt(targetX, player.y)) player.x = targetX;
                    else if (!checkCollisionAt(player.x, targetY)) player.y = targetY;
                }

                // Animation
                player.animTimer += dt;
                // 50% Slower Animation for Front/Back
                let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                if (player.animTimer > animThreshold) {
                    player.animTimer = 0;
                    player.frame = (player.frame + 1) % 12;
                }
            }

            // Handle Animation & Sound for Movement
            if (player.isMoving) {
                // Initial Footstep
                if (audioUnlocked && !footstepPlaying && allowAuxScPlayback()) {
                    footstepSound.play().catch(() => { });
                    footstepPlaying = true;
                }
                if (!allowAuxScPlayback() && footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }

                // Dust Particles
                if (Math.random() > 0.9) { // Reduced freq for dt loop
                    const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                    const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                    const offsetY = Math.floor(spriteH * 0.22);
                    const shiftY = Math.floor(spriteH / 3) - 4;
                    const anchorY = player.y + spriteH + offsetY + shiftY;

                    dustParticles.push({
                        x: player.x + spriteW / 2 + (Math.random() - 0.5) * 6,
                        y: anchorY - 15 + (Math.random() - 0.5) * 2,
                        vx: (Math.random() - 0.5) * 10,  // px/sec (no dt at spawn)
                        vy: -Math.random() * 10,
                        life: 1.0,
                        size: 2 + Math.random() * 2
                    });
                }
            } else {
                // Stop Sound
                player.frame = 1; // Stand
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
            }

            // Update Dust
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const d = dustParticles[i];
                d.x += d.vx * dt;  // Frame-rate independent
                d.y += d.vy * dt;
                d.life -= 2.5 * dt;
                if (d.life <= 0) dustParticles.splice(i, 1);
            }

            // Map Bounds (with sprite size and foot offset)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const FOOT_OFFSET_Y = 15;
                player.x = Math.max(0, Math.min(player.x, mapW - spriteW));
                player.y = Math.max(0, Math.min(player.y, mapH - spriteH - FOOT_OFFSET_Y));
            }

            // Foreground Check
            player.isBehindForeground = checkForeground(player.x, player.y);

            // Smooth Camera (Time-based)
            targetCamX = player.x - SCREEN_W / 2 + 10;
            targetCamY = player.y - SCREEN_H * 0.30 + 10;
            targetCamX = Math.max(0, Math.min(targetCamX, Math.max(0, mapW - SCREEN_W)));
            targetCamY = Math.max(0, Math.min(targetCamY, Math.max(0, mapH - SCREEN_H)));

            camX += (targetCamX - camX) * 5.0 * dt;
            camY += (targetCamY - camY) * 5.0 * dt;

            // Update Particles
            nearbyLights = [];
            for (const p of particles) p.update(dt); // Ensure particle update accepts dt (or add it)
            for (const c of clouds) c.update(dt);

            // Screen-Shake Decay (frame-rate independent)
            if (screenShake > 0.01) {
                screenShake *= Math.pow(0.8, dt * 60);
            } else {
                screenShake = 0;
            }
        }

        // ============================================
        // KOLLISIONSPRÜFUNG - ROBUST (Ecken-Check)
        // ============================================
        function checkCollisionAt(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            // Definition der Fuß-Kollisionsbox relative zum Sprite-Ursprung (px, py)
            // Sprite ist ca 16x20. Füße sind unten.
            // Wir definieren eine schmale Box mittig unten.

            const boxWidth = 8; // Schmaler als Sprite (damit man nicht an Ecken hängen bleibt)
            const boxHeight = 6;

            const centerX = px + spriteW / 2;
            const bottomY = py + spriteH + 15; // +15 wie bisher (visueller Offset)

            // Prüfpunkte:
            // 1. Unten Links
            // 2. Unten Rechts
            // (Optional auch Oben, wenn man eine tiefe Box hat, aber für RPG reicht meist eine 'Grundlinie')

            const left = Math.floor(centerX - boxWidth / 2);
            const right = Math.floor(centerX + boxWidth / 2);
            const yFn = Math.floor(bottomY);

            // Prüfe beide Ecken
            if (isSolid(left, yFn)) return true;
            if (isSolid(right, yFn)) return true;

            return false;
        }

        function isSolid(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true; // Map-Rand ist Wand
            if (collisionData[y][x]) return true;
            return false;
        }

        function checkForeground(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const cx = Math.floor(px + spriteW / 2);
            const cy = Math.floor(py + spriteH / 2);

            if (foregroundData && foregroundData[cy] && cy >= 0 && cy < mapH && cx >= 0 && cx < mapW) {
                return foregroundData[cy][cx];
            }
            return false;
        }

        // ============================================
        // DRAWING
        // ============================================
        let playerLightCanvas = null;
        let playerLightCtx = null;
        let playerMaskCanvas = null;
        let playerMaskCtx = null;
        let graySpriteCacheCanvas = null;
        let graySpriteCacheCtx = null;
        let graySpriteCacheKey = '';

        function draw() {
            // LCD Ghosting: Vorherigen Frame mit Transparenz beibehalten
            // Disable Ghosting
            // ctx.save(); ... ctx.restore();

            // Clear Canvas fully every frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameReady) return;

            ctx.save();
            // Screen-Shake anwenden
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            // SMOOTH CAMERA: Use sub-pixel values (remove Math.floor)
            ctx.translate(-camX + shakeX, -camY + shakeY);

            // screenShake decay moved to update(dt) for frame-rate independence

            // Hintergrund
            if (bgImage) ctx.drawImage(bgImage, 0, 0);

            // Partikel (Additives Leuchten)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) p.draw(ctx, camX, camY);
            ctx.restore();

            // Gelbe Lore-Lichter zeichnen
            for (const light of yellowLights) {
                light.draw(ctx);

                // Beleuchtung hinzufügen wenn aktiv!
                if (activeLightSourceId === light.id && isLoreMode) {
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = light.x - px;
                    const ddy = light.y - py;
                    const dist = Math.sqrt(ddx * ddx + ddy * ddy);
                    nearbyLights.push({
                        x: light.x,
                        y: light.y,
                        dist: dist,
                        life: 1.0,
                        isYellow: true
                    });
                }
            }

            // Spieler-Schatten (diffuse Ellipse unter den Füßen)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

                // Offsets identisch zu drawPlayer berechnen
                const offsetY = Math.floor(spriteH * 0.22);
                const shiftY = Math.floor(spriteH / 3) - 4;
                const totalYOffset = offsetY + shiftY;

                // Schatten-Position: exakt unter den Füßen des Sprites
                const shadowCenterX = player.x + spriteW / 2;
                const shadowCenterY = player.y + totalYOffset + spriteH - 15; // Korrigiert

                // Schatten-Größe: klein und diffus
                const shadowWidth = spriteW * 0.4;
                const shadowHeight = 3;

                // Schatten-Deckkraft
                let shadowAlpha = 0.35;

                if (nearbyLights.length > 0) {
                    const light = nearbyLights[0];
                    const distFactor = 1 - (light.dist / 35);
                    shadowAlpha = 0.25 + distFactor * 0.15;
                }

                // Diffuser Schatten mit radialem Gradient
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    shadowCenterX, shadowCenterY, 0,
                    shadowCenterX, shadowCenterY, shadowWidth
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
                gradient.addColorStop(0.5, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(shadowCenterX, shadowCenterY, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Spieler NORMAL zeichnen (keine Transparenz!)
            drawPlayer(ctx, player.x, player.y, player.dir, player.frame);

            // DEBUG: Fadenkreuz an Fuß-Position (nur im Reading Mode)
            if (isReadingMode && player.debugFootX !== undefined) {
                const fx = player.debugFootX;
                const fy = player.debugFootY;
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1;
                // Horizontale Linie
                ctx.beginPath();
                ctx.moveTo(fx - 8, fy);
                ctx.lineTo(fx + 8, fy);
                ctx.stroke();
                // Vertikale Linie
                ctx.beginPath();
                ctx.moveTo(fx, fy - 8);
                ctx.lineTo(fx, fy + 8);
                ctx.stroke();
                // Kreis
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Beleuchtung: Direktional mit Gradient
            if (nearbyLights.length > 0) {
                nearbyLights.sort((a, b) => a.dist - b.dist);

                const maxRadius = 65; // Erhöht (war 35) für weichere Übergänge
                let totalIntensity = 0;
                let avgDx = 0, avgDy = 0;
                let useYellow = false;

                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const spriteW = coords.w;
                const spriteH = coords.h;
                const playerCX = coords.x + spriteW / 2;
                const playerCY = coords.y + spriteH / 2;

                const numLights = Math.min(2, nearbyLights.length);
                for (let i = 0; i < numLights; i++) {
                    const light = nearbyLights[i];
                    if (light.isYellow) useYellow = true;

                    // Distanz-Modulation: 0% am Rand, 100% direkt am Spieler
                    const distFactor = (1 - (light.dist / maxRadius));
                    // Gelbes Licht etwas intensiver
                    const intensity = distFactor * light.life * (light.isYellow ? 1.5 : 1.0);
                    totalIntensity += intensity * 0.4; // Subtiler (war 0.6)

                    // Richtung vom Licht zum Spieler (normalisiert)
                    const dx = playerCX - light.x;
                    const dy = playerCY - light.y;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    avgDx += (dx / len) * intensity;
                    avgDy += (dy / len) * intensity;
                }

                // Max 50% Aufhellung (subtiler Effekt), Gelb darf etwas heller sein (70%)
                totalIntensity = Math.min(useYellow ? 0.7 : 0.5, totalIntensity);

                if (totalIntensity > 0.02) {
                    // Normalisiere Durchschnittsrichtung
                    const dirLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy) || 1;
                    const ndx = avgDx / dirLen;
                    const ndy = avgDy / dirLen;

                    // OffScreen-Canvas für Gradient-Beleuchtung
                    if (!playerLightCanvas) {
                        playerLightCanvas = document.createElement('canvas');
                        playerLightCtx = playerLightCanvas.getContext('2d');
                    }
                    if (playerLightCanvas.width !== spriteW || playerLightCanvas.height !== spriteH) {
                        playerLightCanvas.width = spriteW;
                        playerLightCanvas.height = spriteH;
                    }
                    const lightCanvas = playerLightCanvas;
                    const lightCtx = playerLightCtx;
                    lightCtx.globalCompositeOperation = 'source-over';
                    lightCtx.clearRect(0, 0, spriteW, spriteH);

                    // Zeichne Sprite exakt so wie es auf dem Hauptcanvas erscheint, aber relativ zu (0,0)
                    lightCtx.save();
                    lightCtx.translate(-coords.x, -coords.y);
                    drawPlayer(lightCtx, player.x, player.y, player.dir, player.frame);
                    lightCtx.restore();

                    // Gleichmäßigere Beleuchtung (statt harter Gradient)
                    // Wir füllen das Sprite fast gleichmäßig auf (mit sehr weichem Rand-Ausfall)
                    const r = useYellow ? 255 : 255;
                    const g = useYellow ? 220 : 255;
                    const b = useYellow ? 50 : 255;

                    lightCtx.globalCompositeOperation = 'source-in';
                    // Fast gleichmäßige Füllung basierend auf Intensität
                    lightCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.8})`;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Ein ganz dezenter Gradient für Dreidimensionalität
                    const rad = Math.max(spriteW, spriteH) * 2;
                    const gradient = lightCtx.createRadialGradient(
                        spriteW / 2 + ndx * (spriteW / 2),
                        spriteH / 2 + ndy * (spriteH / 2),
                        0,
                        spriteW / 2,
                        spriteH / 2,
                        rad
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    lightCtx.fillStyle = gradient;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Zeichne beleuchtetes Sprite an die berechnete Sprite-Position
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(lightCanvas, coords.x, coords.y);
                    ctx.restore();
                }
            }

            // Dust-Particles zeichnen
            ctx.save();
            for (const d of dustParticles) {
                ctx.globalAlpha = d.life * 0.4;
                ctx.fillStyle = '#a89070';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Vordergrund
            if (foregroundImage) ctx.drawImage(foregroundImage, 0, 0);

            // Graue Silhouette IMMER berechnen (Pixel-genaues Masking)
            if (foregroundImage && spriteReady) {
                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const px = coords.x;
                const py = coords.y;
                const dw = coords.w;
                const dh = coords.h;

                // OffScreen-Canvas für Masking
                const maskW = dw + 4;
                const maskH = dh + 4;
                if (!playerMaskCanvas) {
                    playerMaskCanvas = document.createElement('canvas');
                    playerMaskCtx = playerMaskCanvas.getContext('2d');
                }
                if (playerMaskCanvas.width !== maskW || playerMaskCanvas.height !== maskH) {
                    playerMaskCanvas.width = maskW;
                    playerMaskCanvas.height = maskH;
                }
                const maskCanvas = playerMaskCanvas;
                const maskCtx = playerMaskCtx;
                maskCtx.globalCompositeOperation = 'source-over';
                maskCtx.clearRect(0, 0, maskW, maskH);

                // 1. Zeichne den Foreground-Ausschnitt über dem Spieler
                maskCtx.drawImage(foregroundImage,
                    px - 2, py - 2, dw + 4, dh + 4,
                    0, 0, dw + 4, dh + 4);

                // 2. Source-In: Nur wo Foreground-Pixel existieren
                maskCtx.globalCompositeOperation = 'source-in';

                // 3. Zeichne graues Sprite
                const graySprite = createGraySpriteCanvas();
                if (graySprite) {
                    maskCtx.drawImage(graySprite, 2, 2);
                }

                // 4. Zeichne das Ergebnis
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(maskCanvas, px - 2, py - 2);
                ctx.restore();
            }

            // Wolken-Layer (Parallax, über allem)
            for (const c of clouds) c.draw(ctx, camX, camY);

            ctx.restore();
        }

        // NEU: Hilfsfunktion für konsistente Koordinatenberechnung
        // iOS Detection
        // const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent); // REMOVED DUPLICATE

        function getPlayerDrawCoords(x, y, dir, frame) {
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;
            const flipX = (dir === 3);

            let result = {};

            // FRONT (Marker-basiert, 6-Step)
            if (dir === 0) {
                const cycleIdx = frame % 6;
                const frameIdx = FRONT_ANIM_CYCLE[cycleIdx];
                const data = FRONT_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteFront.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteFront.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // BACK (NEU: Marker-basiert, 4-Step Cycle)
            else if (dir === 1) {
                const cycleIdx = frame % 4;
                const frameIdx = BACK_ANIM_CYCLE[cycleIdx];
                const data = BACK_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteBack.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteBack.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // SIDE (Marker-basiert, 6-Step Ping-Pong)
            else if (dir === 2 || dir === 3) {
                const cycleIdx = frame % 6;
                const frameIdx = SIDE_ANIM_CYCLE[cycleIdx];
                const data = SIDE_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = 175;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteSide.height * SPRITE.scale);

                let dx;
                if (flipX) {
                    // Gespiegelt: Ankerpunkt (x + refW/2) ist die Achse.
                    // Die linke Kante ist (Anker + verschobener_Anker) - Breite
                    dx = (x + refW / 2 + footRelX * SPRITE.scale) - dw;
                } else {
                    dx = x + refW / 2 - footRelX * SPRITE.scale;
                }
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                result = {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: true, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteSide.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: flipX
                };
            } else {
                let sprite = (dir === 1) ? (spriteBack || spriteFront) : spriteFront;
                const sw = Math.floor(sprite.width / SPRITE.cols);
                const sh = sprite.height;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(sh * SPRITE.scale);
                const offsetY = Math.floor(dh * 0.22);

                const frameIdx = frame % 4;
                const sx = frameIdx * sw;

                const finalX = x;
                const finalY = y + offsetY + visualShiftY;
                result = {
                    x: finalX, y: finalY, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: sx, sw: sw, sh: sh,
                    flipX: false
                };
            }

            // iOS FIX: Force integer coordinates to prevent sub-pixel "wobble"
            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                result.x = Math.floor(result.x);
                result.y = Math.floor(result.y);
            }
            return result;
        }

        // ============================================
        // SPIELER SPRITE ZEICHNEN
        // ============================================
        function drawPlayer(ctx, x, y, dir, frame) {
            if (!spriteReady) return;

            const coords = getPlayerDrawCoords(x, y, dir, frame);
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;

            ctx.save();
            let sprite;
            if (dir === 0) sprite = spriteFront;
            else if (dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            // DEBUG-DOT an der Fuß-Koordinate
            if (window.debugFoot) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + refW / 2, y + refH + visualShiftY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(x + refW / 2 - 2, y + refH + visualShiftY - 2, 4, 4);
                ctx.restore();
            }

            if (coords.isSide && coords.flipX) {
                // Spiegeln: Translate zur EXAKT berechneten linken Kante + Breite
                ctx.translate(coords.x + coords.w, coords.y);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            } else {
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, coords.x, coords.y, coords.w, coords.h);
            }

            ctx.restore();
        }

        window.debugFoot = false;

        // Erstellt ein einfarbig graues Sprite-Canvas
        function createGraySpriteCanvas() {
            if (!spriteReady) return null;

            const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
            const flipX = (player.dir === 3);

            let sprite;
            if (player.dir === 0) sprite = spriteFront;
            else if (player.dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            const cacheKey = [
                player.dir,
                player.frame,
                coords.w,
                coords.h,
                coords.sx,
                coords.sw,
                coords.sh,
                coords.flipX ? 1 : 0
            ].join(':');
            if (graySpriteCacheCanvas && graySpriteCacheKey === cacheKey) {
                return graySpriteCacheCanvas;
            }

            if (!graySpriteCacheCanvas) {
                graySpriteCacheCanvas = document.createElement('canvas');
                graySpriteCacheCtx = graySpriteCacheCanvas.getContext('2d');
            }
            if (graySpriteCacheCanvas.width !== coords.w || graySpriteCacheCanvas.height !== coords.h) {
                graySpriteCacheCanvas.width = coords.w;
                graySpriteCacheCanvas.height = coords.h;
            }
            const c = graySpriteCacheCanvas;
            const gc = graySpriteCacheCtx;
            gc.clearRect(0, 0, c.width, c.height);

            if (coords.isSide && flipX) {
                gc.translate(coords.w, 0);
                gc.scale(-1, 1);
            }
            gc.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            if (coords.isSide && flipX) {
                gc.setTransform(1, 0, 0, 1, 0, 0);
            }

            gc.globalCompositeOperation = 'source-in';
            gc.fillStyle = 'rgb(180, 180, 180)';
            gc.fillRect(0, 0, coords.w, coords.h);
            gc.globalCompositeOperation = 'source-over';
            graySpriteCacheKey = cacheKey;

            return c;
        }

        function drawPlayerOutline(ctx, x, y) {
            if (!spriteReady || !spriteFront) return;

            const dir = player.dir;
            let sprite;
            let flipX = false;

            switch (dir) {
                case 0: sprite = spriteFront; break;
                case 1: sprite = spriteBack || spriteFront; break;
                case 2: sprite = spriteSide || spriteFront; break;
                case 3: sprite = spriteSide || spriteFront; flipX = true; break;
                default: sprite = spriteFront;
            }

            const spriteW = Math.floor(sprite.width / SPRITE.cols);
            const spriteH = sprite.height;
            const drawW = Math.floor(spriteW * SPRITE.scale);
            const drawH = Math.floor(spriteH * SPRITE.scale);
            const frame = player.frame % SPRITE.cols;

            // Erstelle OffScreen-Canvas für einfarbige Silhouette
            const offCanvas = document.createElement('canvas');
            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');

            // Zeichne Sprite ins OffScreen-Canvas
            if (flipX) {
                offCtx.translate(drawW, 0);
                offCtx.scale(-1, 1);
            }
            offCtx.drawImage(sprite, frame * spriteW, 0, spriteW, spriteH, 0, 0, drawW, drawH);

            // Wandle alle sichtbaren Pixel in einheitliches Grau
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = 'rgb(200, 200, 200)'; // Helles Grau
            offCtx.fillRect(0, 0, drawW, drawH);

            // Zeichne die graue Silhouette halbtransparent
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(offCanvas, Math.floor(x), Math.floor(y));
            ctx.restore();
        }

        // AUDIO & SUBTITLE SYSTEM
        // ============================================

        // SoundCloud Audio Player via Widget API
        const audioPlayer = new SCAudioAdapter();
        // Index uses a dedicated visibility handler; avoid duplicate manager decisions.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(audioPlayer);
        }
        console.log('[Audio] Created SCAudioAdapter for main audio');
        let subtitleTracks = []; // Array aus { time: sekunden, text: string }
        let currentSubtitleIndex = -1;
        let isReadingMode = false;
        const READER_LAYOUT_STORAGE_KEY = 'gameboy_reader_sentence_layout';
        const READER_FONT_SIZE_STORAGE_KEY = 'gameboy_reader_font_size_px';
        const READER_BG_COLOR_STORAGE_KEY = 'gameboy_reader_bg_color';
        const READER_TEXT_COLOR_STORAGE_KEY = 'gameboy_reader_text_color';
        const READER_TEXT_VOLUME_STORAGE_KEY = 'gameboy_reader_text_volume';
        const READER_BACKGROUND_VOLUME_STORAGE_KEY = 'gameboy_reader_background_volume';
        const READER_LAYOUT_TIMESTAMPS = 'timestamps';
        const READER_LAYOUT_FLAT = 'flat';
        const READER_FONT_SIZE_MIN = 14;
        const READER_FONT_SIZE_MAX = 30;
        const READER_FONT_SIZE_DEFAULT = 18;
        const READER_VOLUME_DEFAULT = 1;
        let readerSentenceLayout = normalizeReaderSentenceLayout(localStorage.getItem(READER_LAYOUT_STORAGE_KEY));
        let readerFontSizePx = normalizeReaderFontSize(localStorage.getItem(READER_FONT_SIZE_STORAGE_KEY));
        let readerBgColor = normalizeReaderHexColor(localStorage.getItem(READER_BG_COLOR_STORAGE_KEY), null);
        let readerTextColor = normalizeReaderHexColor(localStorage.getItem(READER_TEXT_COLOR_STORAGE_KEY), null);
        let readerTextVolume = normalizeReaderVolume(localStorage.getItem(READER_TEXT_VOLUME_STORAGE_KEY));
        let readerBackgroundVolume = normalizeReaderVolume(localStorage.getItem(READER_BACKGROUND_VOLUME_STORAGE_KEY));
        const readerColorWheelSync = { bg: null, text: null };
        const readerColorPopoverState = { activeKey: null };
        let subtitleFollowLocked = false;
        let suppressFollowLockUntil = 0;

        audioPlayer.volume = readerTextVolume;

        const uiContainer = document.getElementById('audioPlayerUI');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const audioControlsEl = document.getElementById('audioControls');
        const playBtn = document.getElementById('audioToggleBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipForwardBtn = document.getElementById('skipForwardBtn');
        const modeToggleBtn = document.getElementById('readingModeBtn');
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const iconFsEnter = document.getElementById('iconFsEnter');
        const iconFsExit = document.getElementById('iconFsExit');
        const subtitleRecenterBtn = document.getElementById('subtitleRecenterBtn');
        const RECENTER_MOBILE_RADIUS_PX = 75;
        let subtitleRecenterMobileRadius = document.getElementById('subtitleRecenterMobileRadius');
        if (!subtitleRecenterMobileRadius) {
            subtitleRecenterMobileRadius = document.createElement('div');
            subtitleRecenterMobileRadius.id = 'subtitleRecenterMobileRadius';
            subtitleRecenterMobileRadius.setAttribute('aria-hidden', 'true');
            document.body.appendChild(subtitleRecenterMobileRadius);
        }

        function normalizeReaderSentenceLayout(value) {
            return value === READER_LAYOUT_FLAT ? READER_LAYOUT_FLAT : READER_LAYOUT_TIMESTAMPS;
        }

        function normalizeReaderFontSize(value) {
            const parsed = Number(value);
            if (!Number.isFinite(parsed)) return READER_FONT_SIZE_DEFAULT;
            const rounded = Math.round(parsed);
            return Math.max(READER_FONT_SIZE_MIN, Math.min(READER_FONT_SIZE_MAX, rounded));
        }

        function normalizeReaderVolume(value) {
            const parsed = Number(value);
            if (!Number.isFinite(parsed)) return READER_VOLUME_DEFAULT;
            const normalized = parsed > 1 ? (parsed / 100) : parsed;
            return Math.max(0, Math.min(1, normalized));
        }

        function normalizeReaderHexColor(value, fallback = null) {
            if (typeof value !== 'string') return fallback;
            const cleaned = value.trim().toLowerCase();
            if (!cleaned) return fallback;
            const match = cleaned.match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
            if (!match) return fallback;
            let hex = match[1];
            if (hex.length === 3) hex = hex.split('').map((ch) => `${ch}${ch}`).join('');
            return `#${hex.toLowerCase()}`;
        }

        function getReaderFallbackBgColor() {
            return document.body.classList.contains('scene-dimmer-light-mode') ? '#ede6d6' : '#11161d';
        }

        function getReaderFallbackTextColor() {
            return document.body.classList.contains('scene-dimmer-light-mode') ? '#1f1d18' : '#f2ecdc';
        }

        function mixHexColors(baseHex, tintHex, alpha = 0.5) {
            const base = hexToRgb(baseHex);
            const tint = hexToRgb(tintHex);
            if (!base || !tint) return baseHex;
            const a = Math.max(0, Math.min(1, Number(alpha) || 0));
            return rgbToHex(
                (base.r * (1 - a)) + (tint.r * a),
                (base.g * (1 - a)) + (tint.g * a),
                (base.b * (1 - a)) + (tint.b * a)
            );
        }

        function applyReaderDimmerTint() {
            const overlay = document.getElementById('sceneDimmerOverlay');
            if (!overlay) return;

            const isFreezeMode = manualBackgroundDimLevel >= 100;
            if (!isFreezeMode || !readerBgColor) {
                overlay.style.removeProperty('background-color');
                return;
            }

            const base = document.body.classList.contains('scene-dimmer-light-mode') ? '#ffffff' : '#000000';
            const mixed = mixHexColors(base, readerBgColor, 0.5);
            overlay.style.backgroundColor = mixed;
        }

        let flatCompMeasureCanvas = null;
        let flatCompMeasureCtx = null;
        const flatCompMeasureCache = new Map();
        function getFlatLeadingCompensationPx(text, sampleEl) {
            if (readerSentenceLayout !== READER_LAYOUT_FLAT) return 0;
            if (!sampleEl || !text) return 0;
            if (!flatCompMeasureCanvas) {
                flatCompMeasureCanvas = document.createElement('canvas');
                flatCompMeasureCtx = flatCompMeasureCanvas.getContext('2d');
            }
            if (!flatCompMeasureCtx) return 0;

            const styles = window.getComputedStyle(sampleEl);
            const fontFamily = styles.fontFamily || 'serif';
            const fontSize = styles.fontSize || `${READER_FONT_SIZE_DEFAULT}px`;
            const fontStyle = styles.fontStyle || 'normal';
            const fontVariant = styles.fontVariant || 'normal';
            const cacheKey = `${fontStyle}|${fontVariant}|${fontSize}|${fontFamily}|${text}`;
            if (flatCompMeasureCache.has(cacheKey)) {
                return flatCompMeasureCache.get(cacheKey);
            }

            flatCompMeasureCtx.font = `${fontStyle} ${fontVariant} 400 ${fontSize} ${fontFamily}`;
            const normalWidth = flatCompMeasureCtx.measureText(text).width;
            flatCompMeasureCtx.font = `${fontStyle} ${fontVariant} 500 ${fontSize} ${fontFamily}`;
            const boldWidth = flatCompMeasureCtx.measureText(text).width;
            const compensationPx = Math.max(0, Math.ceil((boldWidth - normalWidth) * 100) / 100);
            flatCompMeasureCache.set(cacheKey, compensationPx);
            return compensationPx;
        }

        function applyFlatLeadingCompensation(lineEl, text) {
            if (!lineEl) return;
            if (readerSentenceLayout !== READER_LAYOUT_FLAT) {
                lineEl.style.removeProperty('--flat-leading-comp');
                return;
            }
            const compensationPx = getFlatLeadingCompensationPx(text, lineEl);
            lineEl.style.setProperty('--flat-leading-comp', `${compensationPx}px`);
        }

        function applyReaderColorSettings() {
            const hasCustomText = typeof readerTextColor === 'string' && !!readerTextColor;
            subtitleContainer.classList.toggle('reader-custom-text', hasCustomText);

            if (hasCustomText) subtitleContainer.style.setProperty('--reader-custom-text', readerTextColor);
            else subtitleContainer.style.removeProperty('--reader-custom-text');
            applyReaderDimmerTint();
        }

        function applyReaderTextSettings(options = {}) {
            if (!subtitleContainer) return;
            const rerender = options.rerender !== false;
            const isFlatLayout = readerSentenceLayout === READER_LAYOUT_FLAT;

            subtitleContainer.classList.toggle('reader-layout-flat', isFlatLayout);
            subtitleContainer.classList.toggle('reader-layout-timestamps', !isFlatLayout);
            subtitleContainer.style.setProperty('--reader-font-size', `${readerFontSizePx}px`);
            applyReaderColorSettings();

            // Open bookmark buttons may overlap after layout/font changes.
            subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((btn) => {
                btn.classList.remove('visible');
            });

            if (rerender && typeof renderSubtitleLines === 'function') {
                subtitleContainer.dataset.version = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        }

        function syncReaderSettingsUi() {
            const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
            layoutInputs.forEach((input) => {
                input.checked = input.value === readerSentenceLayout;
            });

            const rangeInput = document.getElementById('readerFontSizeRange');
            const numberInput = document.getElementById('readerFontSizeNumber');
            const valueAsText = String(readerFontSizePx);
            if (rangeInput) rangeInput.value = valueAsText;
            if (numberInput) numberInput.value = valueAsText;

            const textVolumeRange = document.getElementById('readerTextVolumeRange');
            const textVolumeNumber = document.getElementById('readerTextVolumeNumber');
            const bgVolumeRange = document.getElementById('readerBackgroundVolumeRange');
            const bgVolumeNumber = document.getElementById('readerBackgroundVolumeNumber');
            const textVolumeValue = String(Math.round(readerTextVolume * 100));
            const bgVolumeValue = String(Math.round(readerBackgroundVolume * 100));
            if (textVolumeRange) textVolumeRange.value = textVolumeValue;
            if (textVolumeNumber) textVolumeNumber.value = textVolumeValue;
            if (bgVolumeRange) bgVolumeRange.value = bgVolumeValue;
            if (bgVolumeNumber) bgVolumeNumber.value = bgVolumeValue;

            const effectiveBg = readerBgColor || getReaderFallbackBgColor();
            const effectiveText = readerTextColor || getReaderFallbackTextColor();
            const bgPreview = document.getElementById('readerBgColorPreview');
            const textPreview = document.getElementById('readerTextColorPreview');
            if (bgPreview) bgPreview.style.background = effectiveBg;
            if (textPreview) textPreview.style.background = effectiveText;
            if (typeof readerColorWheelSync.bg === 'function') readerColorWheelSync.bg(effectiveBg);
            if (typeof readerColorWheelSync.text === 'function') readerColorWheelSync.text(effectiveText);
        }

        function setReaderSentenceLayout(nextLayout, options = {}) {
            const normalized = normalizeReaderSentenceLayout(nextLayout);
            if (!options.force && normalized === readerSentenceLayout) return;
            readerSentenceLayout = normalized;
            localStorage.setItem(READER_LAYOUT_STORAGE_KEY, readerSentenceLayout);
            applyReaderTextSettings({ rerender: true });
            syncReaderSettingsUi();
        }

        function setReaderFontSize(nextSize, options = {}) {
            const normalized = normalizeReaderFontSize(nextSize);
            if (!options.force && normalized === readerFontSizePx) return;
            readerFontSizePx = normalized;
            localStorage.setItem(READER_FONT_SIZE_STORAGE_KEY, String(readerFontSizePx));
            applyReaderTextSettings({ rerender: readerSentenceLayout === READER_LAYOUT_FLAT });
            syncReaderSettingsUi();
        }

        function setReaderTextVolume(nextVolume, options = {}) {
            const normalized = normalizeReaderVolume(nextVolume);
            if (!options.force && normalized === readerTextVolume) return;
            readerTextVolume = normalized;
            localStorage.setItem(READER_TEXT_VOLUME_STORAGE_KEY, String(readerTextVolume));
            if (audioPlayer && typeof audioPlayer.volume === 'number' && audioPlayer.volume > 0) {
                audioPlayer.volume = readerTextVolume;
            }
            syncReaderSettingsUi();
        }

        function setReaderBackgroundVolume(nextVolume, options = {}) {
            const normalized = normalizeReaderVolume(nextVolume);
            if (!options.force && normalized === readerBackgroundVolume) return;
            readerBackgroundVolume = normalized;
            localStorage.setItem(READER_BACKGROUND_VOLUME_STORAGE_KEY, String(readerBackgroundVolume));
            if (typeof applySceneAudioMix === 'function') applySceneAudioMix('reader-background-volume');
            if (typeof applyBackgroundSfxVolume === 'function') applyBackgroundSfxVolume('reader-background-volume');
            syncReaderSettingsUi();
        }

        function setReaderBgColor(nextColor, options = {}) {
            const normalized = normalizeReaderHexColor(nextColor, null);
            if (!options.force && normalized === readerBgColor) return;
            readerBgColor = normalized;
            if (readerBgColor) localStorage.setItem(READER_BG_COLOR_STORAGE_KEY, readerBgColor);
            else localStorage.removeItem(READER_BG_COLOR_STORAGE_KEY);
            applyReaderTextSettings({ rerender: false });
            syncReaderSettingsUi();
        }

        function setReaderTextColor(nextColor, options = {}) {
            const normalized = normalizeReaderHexColor(nextColor, null);
            if (!options.force && normalized === readerTextColor) return;
            readerTextColor = normalized;
            if (readerTextColor) localStorage.setItem(READER_TEXT_COLOR_STORAGE_KEY, readerTextColor);
            else localStorage.removeItem(READER_TEXT_COLOR_STORAGE_KEY);
            applyReaderTextSettings({ rerender: false });
            syncReaderSettingsUi();
        }

        function clamp01(value) {
            if (!Number.isFinite(value)) return 0;
            if (value <= 0) return 0;
            if (value >= 1) return 1;
            return value;
        }

        function hexToRgb(hex) {
            const normalized = normalizeReaderHexColor(hex, null);
            if (!normalized) return null;
            const raw = normalized.slice(1);
            return {
                r: parseInt(raw.slice(0, 2), 16),
                g: parseInt(raw.slice(2, 4), 16),
                b: parseInt(raw.slice(4, 6), 16)
            };
        }

        function rgbToHex(r, g, b) {
            const toHex = (value) => {
                const clamped = Math.max(0, Math.min(255, Math.round(value)));
                return clamped.toString(16).padStart(2, '0');
            };
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function rgbToHsl(r, g, b) {
            const rr = r / 255;
            const gg = g / 255;
            const bb = b / 255;
            const max = Math.max(rr, gg, bb);
            const min = Math.min(rr, gg, bb);
            const delta = max - min;
            let h = 0;
            const l = (max + min) / 2;
            let s = 0;

            if (delta !== 0) {
                s = delta / (1 - Math.abs((2 * l) - 1));
                if (max === rr) h = 60 * (((gg - bb) / delta) % 6);
                else if (max === gg) h = 60 * (((bb - rr) / delta) + 2);
                else h = 60 * (((rr - gg) / delta) + 4);
            }

            if (!Number.isFinite(h)) h = 0;
            if (h < 0) h += 360;
            return { h, s: clamp01(s), l: clamp01(l) };
        }

        function hslToRgb(h, s, l) {
            const hue = ((Number(h) % 360) + 360) % 360;
            const sat = clamp01(s);
            const lig = clamp01(l);
            const c = (1 - Math.abs((2 * lig) - 1)) * sat;
            const hh = hue / 60;
            const x = c * (1 - Math.abs((hh % 2) - 1));
            let r1 = 0;
            let g1 = 0;
            let b1 = 0;

            if (hh >= 0 && hh < 1) { r1 = c; g1 = x; }
            else if (hh < 2) { r1 = x; g1 = c; }
            else if (hh < 3) { g1 = c; b1 = x; }
            else if (hh < 4) { g1 = x; b1 = c; }
            else if (hh < 5) { r1 = x; b1 = c; }
            else { r1 = c; b1 = x; }

            const m = lig - (c / 2);
            return {
                r: Math.round((r1 + m) * 255),
                g: Math.round((g1 + m) * 255),
                b: Math.round((b1 + m) * 255)
            };
        }

        function getWheelColorAtOffset(offsetX, offsetY, radius) {
            const safeRadius = Math.max(1, radius);
            const distance = Math.min(1, Math.hypot(offsetX, offsetY) / safeRadius);
            const hue = ((Math.atan2(offsetY, offsetX) * (180 / Math.PI)) + 360) % 360;
            const saturation = 0.18 + (distance * 0.82);
            const lightness = 0.64 - (distance * 0.24);
            const rgb = hslToRgb(hue, saturation, lightness);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }

        function setReaderWheelMarkerFromHex(markerEl, wheelEl, hexColor) {
            if (!markerEl || !wheelEl) return;
            const rgb = hexToRgb(hexColor);
            if (!rgb) return;
            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            const size = Math.min(wheelEl.clientWidth || wheelEl.width || 0, wheelEl.clientHeight || wheelEl.height || 0);
            if (!size) return;
            const radius = size / 2;
            const sat = clamp01((hsl.s - 0.18) / 0.82);
            const angle = (hsl.h * Math.PI) / 180;
            const markerRadius = sat * radius;
            const x = radius + (Math.cos(angle) * markerRadius);
            const y = radius + (Math.sin(angle) * markerRadius);
            markerEl.style.left = `${x}px`;
            markerEl.style.top = `${y}px`;
        }

        function drawReaderGoetheColorWheel(canvasEl) {
            if (!canvasEl) return;
            const width = Number(canvasEl.width) || 168;
            const height = Number(canvasEl.height) || 168;
            const ctx = canvasEl.getContext('2d');
            if (!ctx) return;

            const cx = width / 2;
            const cy = height / 2;
            const radius = Math.min(width, height) / 2;
            const image = ctx.createImageData(width, height);
            const data = image.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = x + 0.5 - cx;
                    const dy = y + 0.5 - cy;
                    const dist = Math.hypot(dx, dy);
                    const index = (y * width + x) * 4;
                    if (dist > radius) {
                        data[index + 3] = 0;
                        continue;
                    }
                    const distNorm = dist / radius;
                    const hue = ((Math.atan2(dy, dx) * (180 / Math.PI)) + 360) % 360;
                    const saturation = 0.18 + (distNorm * 0.82);
                    const lightness = 0.64 - (distNorm * 0.24);
                    const rgb = hslToRgb(hue, saturation, lightness);
                    data[index] = rgb.r;
                    data[index + 1] = rgb.g;
                    data[index + 2] = rgb.b;
                    data[index + 3] = 255;
                }
            }

            ctx.clearRect(0, 0, width, height);
            ctx.putImageData(image, 0, 0);
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, radius - 0.5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.36, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }

        function initReaderColorWheelControl(config) {
            const canvasEl = document.getElementById(config.canvasId);
            const markerEl = document.getElementById(config.markerId);
            const previewEl = document.getElementById(config.previewId);
            if (!canvasEl || !markerEl || !previewEl || typeof config.onPick !== 'function') {
                return null;
            }

            drawReaderGoetheColorWheel(canvasEl);

            const updatePreviewAndMarker = (hexColor) => {
                const normalized = normalizeReaderHexColor(hexColor, null);
                if (!normalized) return;
                previewEl.style.background = normalized;
                setReaderWheelMarkerFromHex(markerEl, canvasEl, normalized);
            };

            const pickFromClientPoint = (clientX, clientY) => {
                const rect = canvasEl.getBoundingClientRect();
                if (!rect.width || !rect.height) return;
                const radius = Math.min(rect.width, rect.height) / 2;
                const localX = clientX - (rect.left + (rect.width / 2));
                const localY = clientY - (rect.top + (rect.height / 2));
                const hex = getWheelColorAtOffset(localX, localY, radius);
                config.onPick(hex);
            };

            let pointerActive = false;
            const onPointerMove = (event) => {
                if (!pointerActive) return;
                pickFromClientPoint(event.clientX, event.clientY);
            };
            const onPointerUp = () => {
                pointerActive = false;
            };
            canvasEl.addEventListener('pointerdown', (event) => {
                event.preventDefault();
                pointerActive = true;
                pickFromClientPoint(event.clientX, event.clientY);
            });
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('pointercancel', onPointerUp);

            canvasEl.addEventListener('touchstart', (event) => {
                if (!event.touches || !event.touches.length) return;
                const t = event.touches[0];
                pickFromClientPoint(t.clientX, t.clientY);
            }, { passive: true });
            canvasEl.addEventListener('touchmove', (event) => {
                if (!event.touches || !event.touches.length) return;
                const t = event.touches[0];
                pickFromClientPoint(t.clientX, t.clientY);
            }, { passive: true });

            return updatePreviewAndMarker;
        }

        function initReaderSettingsControls() {
            const layoutInputs = document.querySelectorAll('input[name="readerSentenceLayout"]');
            layoutInputs.forEach((input) => {
                input.addEventListener('change', () => {
                    if (!input.checked) return;
                    setReaderSentenceLayout(input.value);
                });
            });

            const rangeInput = document.getElementById('readerFontSizeRange');
            const numberInput = document.getElementById('readerFontSizeNumber');
            if (rangeInput) {
                rangeInput.addEventListener('input', (event) => {
                    setReaderFontSize(event.target.value);
                });
            }
            if (numberInput) {
                numberInput.addEventListener('input', (event) => {
                    setReaderFontSize(event.target.value);
                });
                numberInput.addEventListener('change', (event) => {
                    setReaderFontSize(event.target.value, { force: true });
                });
            }

            readerColorWheelSync.bg = initReaderColorWheelControl({
                canvasId: 'readerBgColorWheel',
                markerId: 'readerBgColorMarker',
                previewId: 'readerBgColorPreview',
                onPick: (hexColor) => setReaderBgColor(hexColor)
            });

            readerColorWheelSync.text = initReaderColorWheelControl({
                canvasId: 'readerTextColorWheel',
                markerId: 'readerTextColorMarker',
                previewId: 'readerTextColorPreview',
                onPick: (hexColor) => setReaderTextColor(hexColor)
            });

            const resetColorsBtn = document.getElementById('readerColorResetBtn');
            if (resetColorsBtn) {
                resetColorsBtn.addEventListener('click', () => {
                    setReaderBgColor(null, { force: true });
                    setReaderTextColor(null, { force: true });
                });
            }

            syncReaderSettingsUi();
            applyReaderTextSettings({ rerender: false });
        }

        initReaderSettingsControls();

        const globalVisualDimmer = window.GlobalVisualDimmer
            ? window.GlobalVisualDimmer.init({
                overlayId: 'sceneDimmerOverlay',
                toggleButtonId: 'sceneDimmerToggleBtn',
                iconFullId: 'sceneDimmerIconFull',
                iconHalfId: 'sceneDimmerIconHalf',
                iconCrescentId: 'sceneDimmerIconCrescent',
                iconSunId: 'sceneDimmerIconSun'
            })
            : null;
        let manualBackgroundDimLevel = globalVisualDimmer ? globalVisualDimmer.getLevel() : 0;
        let pendingForceReadingFromFreeze = false;
        let shouldResumePlaybackAfterDimmerUnfreeze = false;
        let dimmerResumeToken = 0;
        let modeSwitchInitialized = false;
        if (globalVisualDimmer) {
            globalVisualDimmer.onChange(({ level, frozen }) => {
                manualBackgroundDimLevel = level;
                window.visualFreezeActive = frozen;
                dimmerResumeToken += 1;
                const changeToken = dimmerResumeToken;

                const currentlyPlaying = (typeof audioPlayer?.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !!audioPlayer && !audioPlayer.paused;

                if (frozen) {
                    shouldResumePlaybackAfterDimmerUnfreeze = shouldResumePlaybackAfterDimmerUnfreeze || currentlyPlaying;
                    pendingForceReadingFromFreeze = true;
                    if (modeSwitchInitialized) {
                        setReadingMode(true, 'dimmer-freeze');
                        pendingForceReadingFromFreeze = false;
                    }
                } else {
                    pendingForceReadingFromFreeze = false;
                    if (shouldResumePlaybackAfterDimmerUnfreeze && !contentSwitchInProgress && !document.hidden) {
                        setTimeout(async () => {
                            try {
                                if (changeToken !== dimmerResumeToken) return;
                                if (document.hidden || contentSwitchInProgress) return;

                                const likelyPlaying = (typeof audioPlayer?.isProbablyPlaying === 'function')
                                    ? audioPlayer.isProbablyPlaying()
                                    : !!audioPlayer && !audioPlayer.paused;

                                if (!likelyPlaying || audioPlayer.paused) {
                                    const started = await verifyPlaybackStarted(3, 260);
                                    indexDebugNote('dimmer-resume', `started=${started} lore=${isLoreMode}`);
                                }
                                syncPlayPauseIcon();
                            } catch (e) {
                                indexDebugNote('dimmer-resume-error', e && e.message ? e.message : String(e));
                            }
                        }, 80);
                    }
                    shouldResumePlaybackAfterDimmerUnfreeze = false;
                }
                if (!frozen && gameReady && !document.hidden) {
                    lastTime = 0;
                    startGameLoop();
                }
            });
            window.visualFreezeActive = globalVisualDimmer.isFrozen();
            pendingForceReadingFromFreeze = window.visualFreezeActive;

        }

        function isAudioTransportPaused() {
            if (!audioPlayer) return true;
            if (typeof audioPlayer.isTransportPaused === 'function') {
                return audioPlayer.isTransportPaused();
            }
            return !!audioPlayer.paused;
        }

        function syncPlayPauseIcon() {
            const isPaused = isAudioTransportPaused();
            iconPlay.style.display = isPaused ? 'block' : 'none';
            iconPause.style.display = isPaused ? 'none' : 'block';
            indexTrace('icon:sync', {
                paused: isPaused,
                iconPlay: iconPlay.style.display,
                iconPause: iconPause.style.display,
                currentTime: Number(((audioPlayer && audioPlayer.currentTime) || 0).toFixed(3))
            });
        }

        audioPlayer.addEventListener('play', syncPlayPauseIcon);
        audioPlayer.addEventListener('pause', syncPlayPauseIcon);
        audioPlayer.addEventListener('ended', syncPlayPauseIcon);
        audioPlayer.addEventListener('canplay', syncPlayPauseIcon);
        syncPlayPauseIcon();

        // FORCE REMOVE FOCUS FROM BUTTONS
        // This prevents the "Orange Box" from appearing when using arrow keys after clicking a button
        document.querySelectorAll('button').forEach(btn => {
            // Option 1: Blur on click
            btn.addEventListener('click', () => {
                btn.blur();
                window.focus();
            });
            // Option 2: Build wall against focus
            btn.addEventListener('focus', () => {
                btn.blur();
            });
            // Option 3: Prevent default on mousedown (stops focus, keeps click)
            btn.addEventListener('mousedown', (e) => {
                if (document.activeElement !== btn) {
                    e.preventDefault();
                }
            });
        });

        // Ambient und Schritte Audio via SC Adapter
        const ambientAudio = new SCAudioAdapter();
        ambientAudio.src = getSCUrl('assets/medieval_town.mp3');
        ambientAudio.volume = AUDIO_PROFILE.ambient;
        // Index uses a dedicated visibility handler; avoid duplicate manager decisions.
        if (window.AudioVisibilityManager && typeof window.AudioVisibilityManager.unregister === 'function') {
            window.AudioVisibilityManager.unregister(ambientAudio);
        }

        function isPrimaryNarrationPlaying() {
            if (!audioPlayer) return false;
            return (typeof audioPlayer.isProbablyPlaying === 'function')
                ? audioPlayer.isProbablyPlaying()
                : !audioPlayer.paused;
        }

        function allowAuxScPlayback() {
            return !isPrimaryNarrationPlaying() && !contentSwitchInProgress && !document.hidden;
        }

        function syncAuxScPlayback(reason = 'unspecified') {
            if (!allowAuxScPlayback()) {
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
                if (!ambientAudio.paused) {
                    ambientAudio.pause();
                }
                indexDebugNote('aux-audio', `${reason} blocked`);
                return;
            }

            if (audioUnlocked && gameReady && ambientAudio.paused) {
                ambientAudio.play().catch(() => { });
            }
            indexDebugNote('aux-audio', `${reason} allowed`);
        }

        function applySceneAudioMix(reason = 'unspecified') {
            let ambientTarget = AUDIO_PROFILE.ambient;
            let footstepTarget = AUDIO_PROFILE.footsteps;

            if (isLoreMode) ambientTarget *= 0.68;
            if (isReadingMode) footstepTarget *= 0.65;
            if (isLoreMode) footstepTarget *= 0.45;

            ambientAudio.volume = Math.max(0, Math.min(1, ambientTarget));
            footstepSound.volume = Math.max(0, Math.min(1, footstepTarget));
            syncAuxScPlayback(`mix:${reason}`);
            indexDebugNote('audio-mix', `${reason} ambient=${ambientAudio.volume.toFixed(3)} foot=${footstepSound.volume.toFixed(3)} ios=${isIOSDevice}`);
        }
        applySceneAudioMix('init');

        // Audio unlock on first interaction (required for mobile autoplay policies)
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            syncAuxScPlayback('unlock');
        }
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        audioPlayer.addEventListener('play', () => syncAuxScPlayback('main-play'));
        audioPlayer.addEventListener('pause', () => syncAuxScPlayback('main-pause'));
        audioPlayer.addEventListener('ended', () => syncAuxScPlayback('main-ended'));

        console.log('[Audio] Created SCAudioAdapters for main/ambient/footsteps');

        // Berechne die Anzahl sichtbarer Zeilen basierend auf Bildschirmhöhe
        function getMaxVisibleLines() {
            if (!isReadingMode) return 3;
            const lineHeight = 28; // Ungefähre Zeilenhöhe in px
            const availableHeight = window.innerHeight * 0.6; // 60% der Bildschirmhöhe
            return Math.min(15, Math.max(5, Math.floor(availableHeight / lineHeight)));
        }

        // Custom Smooth Scroll with Variable Duration (1s-3s based on distance)
        // No jumping - always smooth glide
        let currentScrollAnimation = null;
        function smoothScrollToElement(container, targetEl) {
            if (!container || !targetEl) return;

            // Cancel any existing animation
            if (currentScrollAnimation) {
                cancelAnimationFrame(currentScrollAnimation);
                currentScrollAnimation = null;
            }

            const startY = container.scrollTop;

            // Calculate target position from live rects so inline reading-mode timestamps center correctly.
            const containerRect = container.getBoundingClientRect();
            const clientRects = targetEl.getClientRects();
            const anchorRect = clientRects.length > 0 ? clientRects[0] : targetEl.getBoundingClientRect();
            const relativeTop = (anchorRect.top - containerRect.top) + container.scrollTop;
            const targetHeight = Math.max(anchorRect.height || 0, targetEl.clientHeight || 0, 1);
            const targetY = relativeTop - (container.clientHeight / 2) + (targetHeight / 2);

            const distance = Math.abs(targetY - startY);

            // Skip if already very close (within 5px)
            if (distance < 5) return;

            // Dynamic Duration: 1s (near) to 3s (far)
            // "Near" = within 200px, "Far" = 1000px+
            let duration = 1000; // Base 1s
            if (distance > 200) {
                // Scale from 1s to 3s between 200px and 1000px
                const extraDist = Math.min(800, distance - 200);
                duration = 1000 + (extraDist / 800) * 2000;
            }
            duration = Math.min(3000, duration); // Cap at 3s

            console.log(`[SmoothScroll] Dist=${distance.toFixed(0)}px -> Duration=${duration.toFixed(0)}ms`);

            const startTime = performance.now();

            // Easing function for smooth deceleration
            const easeOutQuad = (t) => t * (2 - t);

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                if (elapsed >= duration) {
                    container.scrollTop = targetY; // Snap to final
                    currentScrollAnimation = null;
                    return;
                }

                const progress = elapsed / duration;
                const eased = easeOutQuad(progress);

                container.scrollTop = startY + (targetY - startY) * eased;

                currentScrollAnimation = requestAnimationFrame(animate);
            };

            currentScrollAnimation = requestAnimationFrame(animate);
        }

        function updateRecenterButtonVisibility(reason = 'unspecified') {
            if (!subtitleRecenterBtn) return;
            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            syncRecenterButtonMount(isMobileLayout);

            const show = isReadingMode && subtitleFollowLocked;
            if (!show) {
                subtitleRecenterBtn.style.setProperty('display', 'none', 'important');
                subtitleRecenterBtn.setAttribute('aria-hidden', 'true');
                if (subtitleRecenterMobileRadius) {
                    subtitleRecenterMobileRadius.style.display = 'none';
                }
                return;
            }

            subtitleRecenterBtn.style.setProperty('display', 'inline-flex', 'important');
            subtitleRecenterBtn.setAttribute('aria-hidden', 'false');
            requestAnimationFrame(() => positionRecenterButton(`visibility-show:${reason}`));
        }

        function setSubtitleFollowLocked(nextLocked, reason = 'unspecified') {
            const normalized = !!nextLocked;
            subtitleFollowLocked = normalized;
            updateRecenterButtonVisibility(reason);
        }

        function syncRecenterButtonMount(isMobileLayout = window.matchMedia('(max-width: 768px)').matches) {
            if (!subtitleRecenterBtn) return;

            if (isMobileLayout) {
                if (subtitleRecenterBtn.parentElement !== document.body) {
                    // Mobile uses a viewport-fixed overlay placement.
                    document.body.appendChild(subtitleRecenterBtn);
                }
                subtitleRecenterBtn.style.position = 'fixed';
                return;
            }

            const desktopHost = audioControlsEl || document.getElementById('audioControls');
            if (desktopHost) {
                if (subtitleRecenterBtn.parentElement !== desktopHost) {
                    // Desktop: use the same flex layout flow as the other control icons.
                    desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                } else if (desktopHost.firstElementChild !== subtitleRecenterBtn) {
                    desktopHost.insertBefore(subtitleRecenterBtn, desktopHost.firstChild);
                }
            }
            subtitleRecenterBtn.style.position = 'static';
            subtitleRecenterBtn.style.left = '';
            subtitleRecenterBtn.style.top = '';
        }

        function isMobileRecenterZoneActive() {
            if (!subtitleRecenterBtn || !subtitleRecenterMobileRadius) return false;
            if (!window.matchMedia('(max-width: 768px)').matches) return false;
            const btnStyle = window.getComputedStyle(subtitleRecenterBtn);
            return btnStyle.display !== 'none' && isReadingMode && subtitleFollowLocked;
        }

        function updateMobileRecenterRadius(left, top, width, height) {
            if (!subtitleRecenterMobileRadius) return;
            if (!isMobileRecenterZoneActive()) {
                subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            const diameter = RECENTER_MOBILE_RADIUS_PX * 2;
            const centerX = left + (width * 0.5);
            const centerY = top + (height * 0.5);
            subtitleRecenterMobileRadius.style.width = `${diameter}px`;
            subtitleRecenterMobileRadius.style.height = `${diameter}px`;
            subtitleRecenterMobileRadius.style.left = `${centerX - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.top = `${centerY - RECENTER_MOBILE_RADIUS_PX}px`;
            subtitleRecenterMobileRadius.style.display = 'block';
        }

        function eventPointInMobileRecenterZone(e) {
            if (!isMobileRecenterZoneActive()) return false;
            if (!e) return false;

            const point = Number.isFinite(e.clientX) && Number.isFinite(e.clientY)
                ? { x: e.clientX, y: e.clientY }
                : (e.changedTouches && e.changedTouches.length > 0
                    ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY }
                    : (e.touches && e.touches.length > 0
                        ? { x: e.touches[0].clientX, y: e.touches[0].clientY }
                        : null));
            if (!point) return false;

            const rect = subtitleRecenterBtn.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) return false;
            const centerX = rect.left + (rect.width * 0.5);
            const centerY = rect.top + (rect.height * 0.5);
            const dx = point.x - centerX;
            const dy = point.y - centerY;
            return (dx * dx + dy * dy) <= (RECENTER_MOBILE_RADIUS_PX * RECENTER_MOBILE_RADIUS_PX);
        }

        function positionRecenterButton(reason = 'unspecified') {
            if (!subtitleRecenterBtn || subtitleRecenterBtn.style.display === 'none') return;

            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            syncRecenterButtonMount(isMobileLayout);
            if (!isMobileLayout) {
                if (subtitleRecenterMobileRadius) subtitleRecenterMobileRadius.style.display = 'none';
                return;
            }

            const anchorRect = fullscreenBtn ? fullscreenBtn.getBoundingClientRect() : null;
            if (!anchorRect) return;
            const btnRect = subtitleRecenterBtn.getBoundingClientRect();
            const gap = 10;

            const rawLeft = anchorRect.left + (anchorRect.width - btnRect.width) * 0.5;
            let rawTop = anchorRect.top - btnRect.height - gap;

            if (isMobileLayout) {
                const subtitleRect = subtitleContainer.getBoundingClientRect();
                const targetCenterY = subtitleRect.top + subtitleRect.height * 0.5;
                rawTop = targetCenterY - btnRect.height * 0.5;
            }

            let left = rawLeft;
            let top = rawTop;
            left = Math.max(6, Math.min(window.innerWidth - btnRect.width - 6, left));
            top = Math.max(6, Math.min(window.innerHeight - btnRect.height - 6, top));

            subtitleRecenterBtn.style.left = `${left}px`;
            subtitleRecenterBtn.style.top = `${top}px`;
            updateMobileRecenterRadius(left, top, btnRect.width, btnRect.height);
        }

        function recenterToCurrentTimestamp() {
            if (!subtitleTracks || subtitleTracks.length === 0) {
                setSubtitleFollowLocked(false, 'recenter-no-tracks');
                return;
            }

            const fallbackIndex = findSubtitleIndexForTime(audioPlayer.currentTime || 0);
            const safeIndex = Math.max(
                0,
                Math.min(
                    subtitleTracks.length - 1,
                    Number.isFinite(currentSubtitleIndex) && currentSubtitleIndex >= 0 ? currentSubtitleIndex : fallbackIndex
                )
            );

            setSubtitleFollowLocked(false, 'recenter');
            suppressFollowLockUntil = Date.now() + 450;
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false';
            currentSubtitleIndex = safeIndex;
            renderSubtitleLines(safeIndex);

            const activeEl = subtitleContainer.children[safeIndex];
            if (activeEl) {
                smoothScrollToElement(subtitleContainer, activeEl);
            }
        }

        let lastRecenterActivationAt = 0;
        let suppressSubtitleClickUntil = 0;
        function handleRecenterActivate(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            const now = Date.now();
            if (now - lastRecenterActivationAt < 260) return;
            lastRecenterActivationAt = now;
            // Touch devices may emit a delayed "ghost click" after the recenter tap.
            // Keep subtitle timestamp clicks muted briefly to avoid accidental seeks.
            const isMobileLayout = window.matchMedia('(max-width: 768px)').matches;
            suppressSubtitleClickUntil = isMobileLayout ? now + 600 : now;
            recenterToCurrentTimestamp();
        }

        if (subtitleRecenterBtn) {
            subtitleRecenterBtn.addEventListener('pointerdown', handleRecenterActivate);
            subtitleRecenterBtn.addEventListener('touchstart', handleRecenterActivate, { passive: false });
            subtitleRecenterBtn.addEventListener('click', handleRecenterActivate);
        }

        window.addEventListener('resize', () => {
            positionRecenterButton('resize');
        });
        window.addEventListener('orientationchange', () => {
            positionRecenterButton('orientationchange');
        });

        const TOP_FADE_BYPASS_COUNT = 2;
        function syncReadingTopFadeMask(activeIndex) {
            if (!subtitleContainer) return;
            const shouldDisableTopFade =
                isReadingMode &&
                Number.isFinite(activeIndex) &&
                activeIndex >= 0 &&
                activeIndex < TOP_FADE_BYPASS_COUNT;
            subtitleContainer.classList.toggle('no-top-fade', shouldDisableTopFade);
        }

        // Generiert die Untertitel-Zeilen dynamisch
        function renderSubtitleLines(centerIndex) {
            // A) Reading Mode: Rendere ALLE Zeilen (für Scrollbar)
            if (isReadingMode) {
                // Version Check: Ensure we are rendering the current set of subtitles
                if (subtitleTracks.length === 0) {
                    syncReadingTopFadeMask(-1);
                    subtitleContainer.innerHTML = '';
                    const emptyLine = document.createElement('div');
                    emptyLine.className = 'subtitle-line subtitle-current';
                    emptyLine.innerText = 'Warte auf Audio/Text...';
                    subtitleContainer.appendChild(emptyLine);
                    return;
                }

                const currentVersion = window.subtitleVersion || 0;
                const renderedVersion = parseInt(subtitleContainer.dataset.version || '-1');

                // Nur neu bauen, wenn Anzahl nicht stimmt ODER Version anders ist
                if (subtitleContainer.children.length !== subtitleTracks.length || renderedVersion !== currentVersion) {
                    subtitleContainer.innerHTML = '';
                    subtitleContainer.dataset.version = currentVersion;

                    subtitleTracks.forEach((track, i) => {
                        const div = document.createElement('div');
                        div.className = 'subtitle-line';
                        div.innerText = track.text;
                        div.dataset.index = i;

                        // Click to Seek
                        div.title = "Klicken zum Springen";
                        div.style.cursor = "pointer";
                        div.addEventListener('click', async (e) => {
                            if (contentSwitchInProgress) {
                                indexTrace('ui:timestamp:blocked', { reason: 'contentSwitchInProgress', index: i, targetTime: track.time });
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            if (eventPointInMobileRecenterZone(e)) {
                                indexTrace('ui:timestamp:blocked', { reason: 'mobileRecenterZone', index: i, targetTime: track.time });
                                handleRecenterActivate(e);
                                return;
                            }
                            if (Date.now() < suppressSubtitleClickUntil) {
                                indexTrace('ui:timestamp:blocked', { reason: 'suppressSubtitleClickUntil', index: i, targetTime: track.time });
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            if (subtitleContainer.dataset.wasDragging === 'true') {
                                console.log("Click ignored due to drag");
                                indexTrace('ui:timestamp:blocked', { reason: 'wasDragging', index: i, targetTime: track.time });
                                return;
                            }
                            // If a bookmark button is visible and was the click target, skip seek
                            if (e.target && typeof e.target.closest === 'function' && e.target.closest('.bookmark-btn')) {
                                indexTrace('ui:timestamp:blocked', { reason: 'bookmark-btn', index: i, targetTime: track.time });
                                return;
                            }
                            setSubtitleFollowLocked(false, 'timestamp-click');
                            console.log(`Seek to ${track.time}s`);
                            indexTrace('ui:timestamp:seek', { index: i, targetTime: track.time });
                            await seekAndSyncSubtitle(track.time, `reading-click:${i}`);
                            try {
                                await audioPlayer.play();
                                indexTrace('ui:timestamp:autoplay-ok', { index: i, targetTime: track.time });
                            } catch (_) {
                                // ignore autoplay gesture restrictions
                                indexTrace('ui:timestamp:autoplay-failed', { index: i, targetTime: track.time });
                            }
                            // Smooth scroll to clicked element
                            smoothScrollToElement(subtitleContainer, div);
                        });

                        // --- BOOKMARK BUTTON (mobile long-press / desktop right-click) ---
                        div.style.position = 'relative';
                        div.style.overflow = 'visible';
                        let _bmTimer = null;
                        const BOOKMARK_LABEL = 'Lesezeichen';
                        const BOOKMARK_SAVED_LABEL = 'Gespeichert';
                        const isDesktopPointer = () => window.matchMedia('(hover: hover) and (pointer: fine)').matches;
                        const clampBookmarkCoord = (value, min, max) => Math.max(min, Math.min(max, value));
                        const rectOverlapArea = (x, y, width, height, rect) => {
                            const overlapW = Math.max(0, Math.min(x + width, rect.right) - Math.max(x, rect.left));
                            const overlapH = Math.max(0, Math.min(y + height, rect.bottom) - Math.max(y, rect.top));
                            return overlapW * overlapH;
                        };
                        const isFlatBookmarkLayout = () => subtitleContainer.classList.contains('reader-layout-flat');
                        const setBookmarkButtonLabel = (btn, label) => {
                            if (!btn) return;
                            const labelNode = btn.querySelector('.bookmark-label');
                            if (labelNode) labelNode.textContent = label;
                            else btn.innerText = label;
                        };
                        const ensureBookmarkButtonMode = (btn, useFlatOverlay) => {
                            if (!btn) return;
                            if (useFlatOverlay) {
                                if (btn.dataset.flatOverlay !== '1') {
                                    btn.dataset.flatOverlay = '1';
                                    btn.innerHTML = '';
                                    const mapLayer = document.createElement('span');
                                    mapLayer.className = 'bookmark-map-layer';
                                    const overlayLayer = document.createElement('span');
                                    overlayLayer.className = 'bookmark-overlay-layer';
                                    const labelLayer = document.createElement('span');
                                    labelLayer.className = 'bookmark-label';
                                    labelLayer.textContent = BOOKMARK_LABEL;
                                    btn.appendChild(mapLayer);
                                    btn.appendChild(overlayLayer);
                                    btn.appendChild(labelLayer);
                                }
                                btn.classList.add('bookmark-btn-flat-overlay');
                            } else {
                                btn.classList.remove('bookmark-btn-flat-overlay');
                                if (btn.dataset.flatOverlay === '1') {
                                    btn.dataset.flatOverlay = '0';
                                    btn.replaceChildren(document.createTextNode(BOOKMARK_LABEL));
                                }
                            }
                        };
                        const resolveSceneCanvas = () => {
                            const gameCanvas = document.getElementById('gameCanvas');
                            if (gameCanvas instanceof HTMLCanvasElement) return gameCanvas;
                            const anyCanvas = document.querySelector('canvas');
                            return anyCanvas instanceof HTMLCanvasElement ? anyCanvas : null;
                        };
                        const applyFlatBookmarkMapLayer = (btn) => {
                            if (!btn || !btn.classList.contains('bookmark-btn-flat-overlay')) return;
                            const mapLayer = btn.querySelector('.bookmark-map-layer');
                            if (!mapLayer) return;
                            const sceneCanvas = resolveSceneCanvas();
                            if (!sceneCanvas || typeof sceneCanvas.toDataURL !== 'function') {
                                mapLayer.style.backgroundImage = 'none';
                                return;
                            }
                            try {
                                const canvasRect = sceneCanvas.getBoundingClientRect();
                                const btnRect = btn.getBoundingClientRect();
                                if (!canvasRect.width || !canvasRect.height || !btnRect.width || !btnRect.height) return;
                                const snapshotUrl = sceneCanvas.toDataURL('image/png');
                                mapLayer.style.backgroundImage = `url("${snapshotUrl}")`;
                                mapLayer.style.backgroundSize = `${canvasRect.width}px ${canvasRect.height}px`;
                                mapLayer.style.backgroundPosition = `${Math.round(canvasRect.left - btnRect.left)}px ${Math.round(canvasRect.top - btnRect.top)}px`;
                            } catch (_) {
                                mapLayer.style.backgroundImage = 'none';
                            }
                        };
                        const collectLineTextRects = (lineEl, containerRect) => {
                            const rects = [];
                            if (!lineEl) return rects;
                            for (const node of lineEl.childNodes) {
                                if (node.nodeType !== Node.TEXT_NODE) continue;
                                if (!(node.textContent || '').trim()) continue;
                                const range = document.createRange();
                                range.selectNodeContents(node);
                                for (const rect of range.getClientRects()) {
                                    if (rect.width <= 0 || rect.height <= 0) continue;
                                    if (rect.bottom < containerRect.top || rect.top > containerRect.bottom) continue;
                                    rects.push(rect);
                                }
                            }
                            return rects;
                        };
                        const collectSubtitleTextRects = () => {
                            const rects = [];
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            subtitleContainer.querySelectorAll('.subtitle-line').forEach((lineEl) => {
                                rects.push(...collectLineTextRects(lineEl, containerRect));
                            });
                            if (subtitleRecenterBtn && subtitleRecenterBtn.offsetParent !== null) {
                                const recenterRect = subtitleRecenterBtn.getBoundingClientRect();
                                if (recenterRect.width > 0 && recenterRect.height > 0) rects.push(recenterRect);
                            }
                            return { rects, containerRect };
                        };
                        const positionBookmarkButton = (btn) => {
                            const useFlatOverlay = isFlatBookmarkLayout();
                            ensureBookmarkButtonMode(btn, useFlatOverlay);
                            const lineRect = div.getBoundingClientRect();
                            const containerRect = subtitleContainer.getBoundingClientRect();
                            if (!lineRect.width || !lineRect.height || !containerRect.width || !containerRect.height) return;
                            const btnWidth = btn.offsetWidth || 0;
                            const btnHeight = btn.offsetHeight || 0;

                            if (useFlatOverlay) {
                                const lineTextRects = collectLineTextRects(div, containerRect);
                                const anchorRect = lineTextRects.length > 0 ? lineTextRects[0] : lineRect;
                                const edgeMargin = 6;
                                const x = clampBookmarkCoord(anchorRect.left, edgeMargin, Math.max(edgeMargin, window.innerWidth - btnWidth - edgeMargin));
                                const y = clampBookmarkCoord(anchorRect.top - btnHeight - 6, edgeMargin, Math.max(edgeMargin, window.innerHeight - btnHeight - edgeMargin));
                                btn.style.left = `${Math.round(x)}px`;
                                btn.style.top = `${Math.round(y)}px`;
                                applyFlatBookmarkMapLayer(btn);
                                return;
                            }

                            const { rects: textRects } = collectSubtitleTextRects();
                            const margin = 8;
                            const minX = containerRect.left + margin;
                            const maxX = Math.max(minX, containerRect.right - btnWidth - margin);
                            const minY = containerRect.top + margin;
                            const maxY = Math.max(minY, containerRect.bottom - btnHeight - margin);
                            const lineTextRects = collectLineTextRects(div, containerRect);
                            const anchorRect = lineTextRects.length > 0 ? lineTextRects[lineTextRects.length - 1] : lineRect;
                            const fallbackY = clampBookmarkCoord(
                                anchorRect.top + ((anchorRect.height - btnHeight) / 2),
                                minY,
                                maxY
                            );
                            const xCandidates = [
                                clampBookmarkCoord(anchorRect.right + margin, minX, maxX),
                                clampBookmarkCoord(anchorRect.right - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(anchorRect.left - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(containerRect.right - btnWidth - margin, minX, maxX),
                                clampBookmarkCoord(containerRect.left + margin, minX, maxX)
                            ];
                            const yCandidates = [
                                fallbackY,
                                clampBookmarkCoord(anchorRect.top - btnHeight - margin, minY, maxY),
                                clampBookmarkCoord(anchorRect.bottom + margin, minY, maxY),
                                clampBookmarkCoord(lineRect.top + ((lineRect.height - btnHeight) / 2), minY, maxY)
                            ];

                            let best = { score: Number.POSITIVE_INFINITY, x: xCandidates[0], y: yCandidates[0] };
                            for (const y of yCandidates) {
                                for (const x of xCandidates) {
                                    let overlapScore = 0;
                                    for (const rect of textRects) {
                                        overlapScore += rectOverlapArea(x, y, btnWidth, btnHeight, rect);
                                    }
                                    const centerPenalty = Math.abs((y + (btnHeight / 2)) - (anchorRect.top + (anchorRect.height / 2))) * 0.08;
                                    const idealCenterX = clampBookmarkCoord(
                                        anchorRect.right + margin + (btnWidth / 2),
                                        minX + (btnWidth / 2),
                                        maxX + (btnWidth / 2)
                                    );
                                    const sidePenalty = Math.abs((x + (btnWidth / 2)) - idealCenterX) * 0.03;
                                    const score = overlapScore + centerPenalty + sidePenalty;
                                    if (score < best.score) best = { score, x, y };
                                }
                            }

                            btn.style.left = `${Math.round(best.x - lineRect.left)}px`;
                            btn.style.top = `${Math.round(best.y - lineRect.top)}px`;
                        };

                        const showBookmarkButton = () => {
                            let btn = div.querySelector('.bookmark-btn');
                            if (!btn) {
                                btn = document.createElement('button');
                                btn.className = 'bookmark-btn';
                                setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                btn.addEventListener('click', async (ev) => {
                                    ev.stopPropagation();
                                    ev.preventDefault();
                                    btn.classList.remove('pop');
                                    void btn.offsetWidth;
                                    btn.classList.add('pop');
                                    setTimeout(() => btn.classList.remove('pop'), 220);
                                    const loreId = (isLoreMode && Number.isFinite(activeLoreId)) ? Number(activeLoreId) : null;
                                    const loreMeta = loreId && window.GameState && typeof window.GameState.getLore === 'function'
                                        ? window.GameState.getLore(loreId)
                                        : null;
                                    const bookmarkContentKey = loreId ? `lore${loreId}` : MAIN_CONTENT_KEY;
                                    const bookmarkChapter = loreId ? `lore${loreId}` : CURRENT_CHAPTER;
                                    const bookmarkChapterTitle = loreId
                                        ? (loreMeta && loreMeta.title ? `Lore ${loreId}: ${loreMeta.title}` : `Lore ${loreId}`)
                                        : CURRENT_CHAPTER_TITLE;
                                    const bookmarkAudioRef = loreId
                                        ? ((loreMeta && loreMeta.audio) || loreData.audio[loreId] || `assets/lore${loreId}.mp3`)
                                        : LEVEL.audioUrl;
                                    const bookmarkTextRef = loreId
                                        ? ((loreMeta && loreMeta.text) || `assets/lore${loreId}.txt`)
                                        : LEVEL.subtitleFile;
                                    const bm = {
                                        id: Date.now(),
                                        chapter: bookmarkChapter,
                                        chapterTitle: bookmarkChapterTitle,
                                        page: CURRENT_PAGE,
                                        time: track.time,
                                        textPreview: (track.text || '').substring(0, 60),
                                        contentKey: bookmarkContentKey,
                                        loreId: loreId,
                                        audioRef: bookmarkAudioRef,
                                        textRef: bookmarkTextRef,
                                        createdAt: Date.now()
                                    };
                                    const added = await window.GameState.addBookmark(bm);
                                    if (added) {
                                        btn.classList.add('saved');
                                        setBookmarkButtonLabel(btn, BOOKMARK_SAVED_LABEL);
                                        positionBookmarkButton(btn);
                                        setTimeout(() => {
                                            btn.classList.remove('visible', 'saved');
                                            ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                                            setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                                            positionBookmarkButton(btn);
                                        }, 1200);
                                    } else {
                                        btn.classList.remove('visible');
                                    }
                                });
                                div.appendChild(btn);
                            }
                            ensureBookmarkButtonMode(btn, isFlatBookmarkLayout());
                            if (!btn.classList.contains('saved')) setBookmarkButtonLabel(btn, BOOKMARK_LABEL);
                            subtitleContainer.querySelectorAll('.bookmark-btn.visible').forEach((otherBtn) => {
                                if (otherBtn !== btn) otherBtn.classList.remove('visible');
                            });
                            positionBookmarkButton(btn);
                            btn.classList.add('visible');
                            // Auto-hide after 4 seconds
                            setTimeout(() => {
                                if (!btn.classList.contains('saved')) {
                                    btn.classList.remove('visible');
                                }
                            }, 4000);
                        };

                        const startLongPress = () => {
                            if (isDesktopPointer()) return;
                            if (_bmTimer) clearTimeout(_bmTimer);
                            _bmTimer = setTimeout(() => {
                                _bmTimer = null;
                                showBookmarkButton();
                            }, 600);
                        };
                        const cancelLongPress = () => {
                            if (_bmTimer) { clearTimeout(_bmTimer); _bmTimer = null; }
                        };
                        div.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            startLongPress();
                        });
                        div.addEventListener('contextmenu', (e) => {
                            if (!isDesktopPointer()) return;
                            e.preventDefault();
                            e.stopPropagation();
                            cancelLongPress();
                            showBookmarkButton();
                        });
                        div.addEventListener('touchstart', startLongPress, { passive: true });
                        div.addEventListener('mouseup', cancelLongPress);
                        div.addEventListener('mouseleave', cancelLongPress);
                        div.addEventListener('touchend', cancelLongPress);
                        div.addEventListener('touchcancel', cancelLongPress);

                        subtitleContainer.appendChild(div);
                        applyFlatLeadingCompensation(div, track.text);
                    });
                }

                // Highlighting aktualisieren
                const oldActive = subtitleContainer.querySelector('.subtitle-current');
                if (oldActive) oldActive.classList.remove('subtitle-current');

                // Ensure centerIndex is valid
                const normalizedIndex = Number.isFinite(centerIndex) ? centerIndex : 0;
                const safeIndex = Math.max(0, Math.min(subtitleTracks.length - 1, normalizedIndex));
                syncReadingTopFadeMask(safeIndex);

                if (subtitleContainer.children.length > safeIndex) {
                    const activeEl = subtitleContainer.children[safeIndex];
                    activeEl.classList.add('subtitle-current');

                    // Auto-Scroll only if user is NOT actively dragging AND audio is playing
                    // Uses custom smooth scroll with variable duration (1-3s)
                    const isPlaying = !audioPlayer.paused;
                    if (subtitleContainer.dataset.isDragging !== 'true' && !subtitleFollowLocked && isPlaying) {
                        smoothScrollToElement(subtitleContainer, activeEl);
                    }
                }
                return;
            }

            // B) Game Mode: Nur kleines Fenster rendern (3 Zeilen)
            syncReadingTopFadeMask(-1);
            subtitleContainer.innerHTML = '';

            if (subtitleTracks.length === 0) {
                const div = document.createElement('div');
                div.className = 'subtitle-line subtitle-current';
                div.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(div);
                return;
            }

            // Fixe 3 Zeilen im Spielmodus
            const startIdx = Math.max(0, centerIndex - 1);
            const endIdx = Math.min(subtitleTracks.length - 1, centerIndex + 1);

            for (let i = startIdx; i <= endIdx; i++) {
                const div = document.createElement('div');
                div.className = 'subtitle-line';

                const distance = Math.abs(i - centerIndex);

                if (i === centerIndex) {
                    div.classList.add('subtitle-current');
                } else {
                    // Verblassen
                    if (distance >= 5) div.classList.add('fade-far');
                    else if (distance >= 3) div.classList.add('fade-mid');
                }

                div.innerText = subtitleTracks[i].text;
                subtitleContainer.appendChild(div);
            }
        }



        // 2. Parser für Timestamps - CORRECTLY distinguishes between formats:
        // [hh:mm:ss] - Colon before third part means SECONDS (kapitel1.txt uses [00:mm:ss])
        // [mm:ss.xx] - Dot before third part means CENTISECONDS (lore format)
        function parseSubtitles(rawText) {
            subtitleTracks = [];
            currentSubtitleIndex = -1;
            const lines = rawText.split('\n');

            // Capture the separator character to distinguish formats:
            // Group 1: first number
            // Group 2: second number  
            // Group 3: separator (: or .) - captured separately!
            // Group 4: third number if exists
            // Group 5: text
            const timeReg = /^\[(\d{1,2}):(\d{2})([:.])(\d{1,2}(?:\.\d+)?)\]\s*(.*)|\[(\d{1,2}):(\d{2})\]\s*(.*)/;

            let matchCount = 0;
            lines.forEach((line, idx) => {
                const match = line.match(timeReg);
                if (match) {
                    matchCount++;
                    let totalSeconds;
                    let text;

                    if (match[1] !== undefined) {
                        // Three-part format: [xx:xx:xx] or [xx:xx.xx]
                        const first = parseFloat(match[1]);
                        const second = parseFloat(match[2]);
                        const separator = match[3]; // ':' or '.'
                        const third = parseFloat(match[4]);
                        text = match[5] ? match[5].trim() : '';

                        if (separator === ':') {
                            // [hh:mm:ss] format - third part is SECONDS
                            totalSeconds = first * 3600 + second * 60 + third;
                        } else {
                            // [mm:ss.xx] format - third part is CENTISECONDS
                            totalSeconds = first * 60 + second + (third / 100);
                        }
                    } else {
                        // Two-part format: [mm:ss]
                        const first = parseFloat(match[6]);
                        const second = parseFloat(match[7]);
                        text = match[8] ? match[8].trim() : '';
                        totalSeconds = first * 60 + second;
                    }

                    if (text && text.length > 0) {
                        subtitleTracks.push({
                            time: totalSeconds,
                            text: text
                        });
                    }
                }
            });

            console.log(`[DEBUG] parseSubtitles: ${matchCount} matches from ${lines.length} lines, ${subtitleTracks.length} tracks with text`);
            if (subtitleTracks.length > 0) {
                console.log(`[DEBUG] First subtitle at ${subtitleTracks[0].time}s: "${subtitleTracks[0].text.substring(0, 40)}..."`);
                if (subtitleTracks.length > 1) {
                    console.log(`[DEBUG] Second subtitle at ${subtitleTracks[1].time}s: "${subtitleTracks[1].text.substring(0, 30)}..."`);
                }
            }

            subtitleTracks.sort((a, b) => a.time - b.time);
            setSubtitleFollowLocked(false, 'parse-subtitles');

            // Increment version to force re-render in Reading Mode
            window.subtitleVersion = (window.subtitleVersion || 0) + 1;
        }

        // 3. Update-Funktion für Anzeige
        function updateSubtitleDisplay(index) {
            if (index === currentSubtitleIndex) return;
            currentSubtitleIndex = index;
            renderSubtitleLines(Math.max(0, index));
        }

        // 4. Synchronisation (läuft bei jedem Audio-Update)
        audioPlayer.addEventListener('timeupdate', () => {
            const t = audioPlayer.currentTime;

            let newIndex = -1;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (t >= subtitleTracks[i].time) {
                    newIndex = i;
                    break;
                }
            }

            updateSubtitleDisplay(newIndex);
        });

        // 4b. Chapter Transition Logic (Main Audio Ended)
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode) {
                indexTrace('audio:ended:lore', { activeLoreId: activeLoreId || null });
                if (window.restoreMainAudio) {
                    window.restoreMainAudio({ saveCurrent: false, forceResume: true });
                }
                return;
            } else {
                // MAIN CHAPTER FINISHED
                console.log("Chapter 1 Finished. ReadingMode:", isReadingMode);

                // BUGFIX: Prevent transition if Text is not finished!
                // Only if we are in Reading Mode (where text matters).
                // Or generally? User said "Cut off bug".

                let textFinished = true;
                if (subtitleTracks.length > 0) {
                    // If we are significantly behind? use small buffer (e.g. within last 3 lines)
                    if (currentSubtitleIndex < subtitleTracks.length - 1) {
                        textFinished = false;
                    }
                }

                // Debug Decision
                console.log(`[DEBUG_SYS] Audio Ended. SubtitleIndex=${currentSubtitleIndex}/${subtitleTracks.length}. TextFinished=${textFinished}`);
                indexDebugNote('audio-ended', `idx=${currentSubtitleIndex}/${subtitleTracks.length} textFinished=${textFinished} reading=${isReadingMode}`);
                indexTrace('audio:ended:main', {
                    subtitleIndex: currentSubtitleIndex,
                    subtitleCount: subtitleTracks.length,
                    textFinished: !!textFinished,
                    readingMode: !!isReadingMode
                });
                const shouldClearMainState = !isReadingMode || textFinished;
                if (shouldClearMainState) {
                    clearContentState(MAIN_CONTENT_KEY);
                }

                if (isReadingMode) {
                    if (textFinished) {
                        transitionToNextChapter();
                    } else {
                        console.log("[DEBUG_SYS] Audio ended but text incomplete. Pausing audio, keeping Reading Mode open.");
                        // Stop audio but do not transition. 
                        // User can read remaining text, then manual action needed? 
                        // Or maybe we don't need to do anything, just let it stop.
                        audioPlayer.pause();
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else if (LEVEL.nextChapterTarget) {
                    // Game Mode: Show Button (nur wenn Folgekapitel vorhanden)
                    const btn = document.getElementById('nextChapterBtn');
                    if (btn) btn.classList.add('visible');

                    // UI Polish: switch to Pause icon? No, audio ended means it stopped.
                    // Just ensure logic state.
                }
            }
        });

        // PINCH-TO-ZOOM REMOVED per user request (caused jitter issues)


        window.transitionToNextChapter = async function () {
            const overlay = document.getElementById('transitionOverlay');
            if (overlay) overlay.classList.add('active');

            const nextTarget = LEVEL.nextChapterTarget;
            if (!nextTarget) return; // Kein Folgekapitel für dieses Level

            await waitForContentSwitchIdle('transition:next-chapter');
            await saveCurrentContentState({ reason: 'transition:next-chapter' });
            indexDebugNote('transition', `to ${nextTarget}`);
            markChapterAutoplayIntent('liminal_library', 'auto', 'chapter-transition');
            writeStateHandoff('liminal_library');

            // Fade out any remaining audio
            fadeAudio(audioPlayer, 0, 1500);

            setTimeout(() => {
                window.location.href = nextTarget;
            }, 2000); // 2s Fade Time
        };

        const nextChapterBtn = document.getElementById('nextChapterBtn');
        if (nextChapterBtn) {
            nextChapterBtn.addEventListener('click', () => {
                nextChapterBtn.classList.remove('visible');
                transitionToNextChapter();
            });
        }


        // 11. Custom Drag-to-Scroll Logic for Subtitle Container (with Momentum)
        let isDown = false;
        let startY;
        let scrollTop;
        let lastMoveY = 0;
        let lastMoveTime = 0;
        let swipeVelocity = 0;
        let momentumAnimId = null;

        function cancelMomentum() {
            if (momentumAnimId) {
                cancelAnimationFrame(momentumAnimId);
                momentumAnimId = null;
            }
        }

        const handleDown = (e) => {
            cancelMomentum();
            isDown = true;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false'; // Reset for next click check
            const pageY = e.pageY || e.touches[0].pageY;
            startY = pageY - subtitleContainer.offsetTop;
            scrollTop = subtitleContainer.scrollTop;
            lastMoveY = pageY;
            lastMoveTime = performance.now();
            swipeVelocity = 0;
            // Optional: Cursor style
            subtitleContainer.style.cursor = 'grabbing';
        };

        const handleMove = (e) => {
            if (!isDown) return;
            e.preventDefault(); // Prevent text selection
            const pageY = e.pageY || e.touches[0].pageY;
            const y = pageY - subtitleContainer.offsetTop;
            const walk = (y - startY) * 1.0; // Scroll speed

            // Track velocity for momentum
            const now = performance.now();
            const elapsed = now - lastMoveTime;
            if (elapsed > 0) {
                // velocity in px/ms, smoothed
                const instantVelocity = (pageY - lastMoveY) / elapsed;
                swipeVelocity = swipeVelocity * 0.6 + instantVelocity * 0.4;
            }
            lastMoveY = pageY;
            lastMoveTime = now;

            // Threshold check
            if (Math.abs(walk) > 5) {
                subtitleContainer.dataset.isDragging = 'true';
                subtitleContainer.dataset.wasDragging = 'true';
                if (isReadingMode && Date.now() >= suppressFollowLockUntil) {
                    setSubtitleFollowLocked(true, 'drag-threshold');
                }
                subtitleContainer.scrollTop = scrollTop - walk;
            }
        };

        const handleUp = () => {
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.style.cursor = 'auto';

            // Start momentum animation if velocity is significant
            const velocityPxPerMs = swipeVelocity;
            let velocityPxPerSec = -velocityPxPerMs * 1000 * 1.2; // Negate + moderate amplify
            const MAX_VELOCITY = 5000;
            const MIN_VELOCITY = 15;
            velocityPxPerSec = Math.max(-MAX_VELOCITY, Math.min(MAX_VELOCITY, velocityPxPerSec));

            if (Math.abs(velocityPxPerSec) > MIN_VELOCITY) {
                let lastFrame = performance.now();
                const animateMomentum = (now) => {
                    const dt = (now - lastFrame) / 1000;
                    lastFrame = now;

                    // Apply velocity
                    subtitleContainer.scrollTop += velocityPxPerSec * dt;

                    // Decay — 0.96 is much gentler than 0.92, so hard swipes coast far
                    velocityPxPerSec *= Math.pow(0.96, dt * 60);

                    // Stop when effectively still
                    if (Math.abs(velocityPxPerSec) < 0.5) {
                        momentumAnimId = null;
                        return;
                    }

                    momentumAnimId = requestAnimationFrame(animateMomentum);
                };
                momentumAnimId = requestAnimationFrame(animateMomentum);
            }
        };

        subtitleContainer.addEventListener('mousedown', handleDown);
        subtitleContainer.addEventListener('touchstart', handleDown, { passive: true });

        subtitleContainer.addEventListener('mouseleave', handleUp);
        subtitleContainer.addEventListener('mouseup', handleUp);
        subtitleContainer.addEventListener('touchend', handleUp);

        subtitleContainer.addEventListener('mousemove', handleMove);
        subtitleContainer.addEventListener('touchmove', handleMove, { passive: false });

        // 10. Scrollbar Auto-Hide Logic
        let scrollTimeout;
        subtitleContainer.addEventListener('scroll', () => {
            subtitleContainer.classList.add('is-scrolling');
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                subtitleContainer.classList.remove('is-scrolling');
            }, 1000); // 1 Sekunde nach Scroll-Ende ausblenden
        });

        // 5. Play/Pause Steuerung
        playBtn.addEventListener('click', () => {
            if (contentSwitchInProgress) {
                indexTrace('ui:play-toggle:blocked', { reason: 'contentSwitchInProgress' });
                return;
            }
            const transportPaused = isAudioTransportPaused();
            console.log("Play Button Clicked. Current Src:", audioPlayer.src, "Paused:", audioPlayer.paused);
            indexTrace('ui:play-toggle:click', {
                src: audioPlayer.src,
                paused: audioPlayer.paused,
                transportPaused,
                iconPlay: iconPlay.style.display,
                iconPause: iconPause.style.display
            });
            if (transportPaused) {
                audioPlayer.play()
                    .then(() => syncPlayPauseIcon())
                    .catch(e => {
                        console.error("Play verification failed:", e);
                        syncPlayPauseIcon();
                    });
            } else {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        });

        // 6. Skip Buttons (±15 Sekunden)
        async function skipBySecondsGlobal(deltaSec, reason = 'skip') {
            if (contentSwitchInProgress) return;
            const delta = Number(deltaSec) || 0;
            if (!delta) return;

            const wasPausedBeforeSkip = !!audioPlayer.paused;
            let before = Number(audioPlayer.currentTime);
            if (!Number.isFinite(before) || before < 0) before = 0;
            if (!wasPausedBeforeSkip && typeof audioPlayer.getAccurateCurrentTime === 'function') {
                const measuredBefore = await audioPlayer.getAccurateCurrentTime(900);
                if (Number.isFinite(measuredBefore) && measuredBefore >= 0) before = measuredBefore;
            }

            const target = Math.max(0, before + delta);
            await seekAndSyncSubtitle(target, `${reason}:${delta > 0 ? 'forward' : 'back'}`);

            if (wasPausedBeforeSkip) {
                audioPlayer.pause();
                syncPlayPauseIcon();
            }
        }

        skipBackBtn.addEventListener('click', () => {
            skipBySecondsGlobal(-15, 'btn-skip').catch((e) => {
                console.warn('[Skip] Back failed:', e);
            });
        });

        skipForwardBtn.addEventListener('click', () => {
            skipBySecondsGlobal(15, 'btn-skip').catch((e) => {
                console.warn('[Skip] Forward failed:', e);
            });
        });

        // 7. Modus-Wechsel mit robuster Animation
        let modeSwitchUiTimer = null;
        let modeSwitchLockUntil = 0;

        function syncModeToggleButton() {
            if (!modeToggleBtn) return;
            const nextModeLabel = isReadingMode ? 'Spielmodus aktivieren' : 'Lesemodus aktivieren';
            modeToggleBtn.title = nextModeLabel;
            modeToggleBtn.setAttribute('aria-label', nextModeLabel);
        }

        function setReadingMode(nextMode, reason = 'manual') {
            let normalized = !!nextMode;
            if (!normalized && globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                normalized = true;
            }
            const now = performance.now();

            if (now < modeSwitchLockUntil && normalized === isReadingMode) return;
            modeSwitchLockUntil = now + 120;

            isReadingMode = normalized;
            localStorage.setItem('gameboy_reading_mode', normalized ? 'true' : 'false');

            if (normalized) {
                syncAutoWalkToIndex();
                uiContainer.classList.add('reading-mode');
            } else {
                setSubtitleFollowLocked(false, 'mode-off');
                if (isLoreMode && !isMenuTriggeredLore) {
                    endLoreMode();
                }
                uiContainer.classList.remove('reading-mode');
            }

            syncModeToggleButton();
            moveTarget = null;
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));

            uiContainer.classList.add('mode-switching');
            if (modeSwitchUiTimer) clearTimeout(modeSwitchUiTimer);
            modeSwitchUiTimer = setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);

            indexDebugNote(
                'mode-switch',
                `${reason} reading=${isReadingMode} tracks=${subtitleTracks.length} switching=${contentSwitchInProgress}`
            );
            applySceneAudioMix(`mode-switch:${reason}`);
            updateRecenterButtonVisibility();
        }

        syncModeToggleButton();
        modeSwitchInitialized = true;
        if (pendingForceReadingFromFreeze) {
            setReadingMode(true, 'dimmer-freeze-init');
            pendingForceReadingFromFreeze = false;
        }

        modeToggleBtn.addEventListener('click', () => {
            // In frozen mode: reset dimmer to off + switch to game mode
            if (globalVisualDimmer && globalVisualDimmer.isFrozen()) {
                globalVisualDimmer.setLevel(0, { forceEmit: true });
                setReadingMode(false, 'ui-mode-toggle-unfreeze');
            } else {
                setReadingMode(!isReadingMode, 'ui-mode-toggle');
            }
        });

        // HELPER: Sync AutoWalk Index to current Player Position
        function syncAutoWalkToIndex() {
            if (!autoWalkPath || autoWalkPath.length === 0) return;

            // Calculate Foot Position
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const footX = player.x + spriteW / 2;
            const footY = player.y + spriteH + 15;

            // Find closest index
            let closestIdx = 0;
            let minDistSq = Infinity;

            for (let i = 0; i < autoWalkPath.length; i++) {
                const node = autoWalkPath[i];
                const dx = node.x - footX;
                const dy = node.y - footY;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestIdx = i;
                }
            }

            // Set Index
            autoWalkIndex = closestIdx;
            console.log(`AutoWalk Synced to Index: ${closestIdx} / ${autoWalkPath.length}`);
        }

        // 8. Wenn Audio zu Ende ist, Reset
        // 8. Wenn Audio zu Ende ist
        audioPlayer.addEventListener('ended', () => {
            if (isLoreMode || contentSwitchInProgress) return;
            iconPlay.style.display = 'block';
            renderSubtitleLines(subtitleTracks.length - 1);
        });

        // 9. Bei Fenster-Resize: Canvas anpassen & Zeilen neu berechnen
        window.addEventListener('resize', () => {
            // A) Canvas Resize Logic (Vollbild Unterstützung)
            if (mapW > 0 && mapH > 0 && gameReady) {
                SCREEN_W = Math.min(mapW, window.innerWidth);
                SCREEN_H = Math.min(mapH, window.innerHeight);
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;

                // Kamera neu zentrieren
                camX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                camY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));
            }

            // B) Untertitel Logic: Force Rebuild bei Resize
            if (isReadingMode && subtitleTracks.length > 0) {
                // Leere Container um Rebuild zu erzwingen (Fix für Scrollbar Resize Bug)
                subtitleContainer.innerHTML = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // 10. Fullscreen Logic
        function getFullscreenElementSafe() {
            return document.fullscreenElement || document.webkitFullscreenElement || null;
        }

        function isFullscreenSupported() {
            const root = document.documentElement;
            return !!(
                document.fullscreenEnabled ||
                document.webkitFullscreenEnabled ||
                root.requestFullscreen ||
                root.webkitRequestFullscreen
            );
        }

        function requestFullscreenSafe() {
            const root = document.documentElement;
            if (root.requestFullscreen) return root.requestFullscreen();
            if (root.webkitRequestFullscreen) return Promise.resolve(root.webkitRequestFullscreen());
            return Promise.reject(new Error('Fullscreen API not supported'));
        }

        function exitFullscreenSafe() {
            if (document.exitFullscreen) return document.exitFullscreen();
            if (document.webkitExitFullscreen) return Promise.resolve(document.webkitExitFullscreen());
            return Promise.resolve();
        }

        function syncFullscreenUi() {
            if (getFullscreenElementSafe()) {
                iconFsEnter.style.display = 'none';
                iconFsExit.style.display = 'block';
            } else {
                iconFsEnter.style.display = 'block';
                iconFsExit.style.display = 'none';
            }
            positionRecenterButton();
        }

        fullscreenBtn.addEventListener('click', async () => {
            if (!isFullscreenSupported()) {
                showNotification('Vollbild wird auf diesem Geraet nicht unterstuetzt.');
                syncFullscreenUi();
                return;
            }

            try {
                if (!getFullscreenElementSafe()) {
                    await requestFullscreenSafe();
                } else {
                    await exitFullscreenSafe();
                }
            } catch (err) {
                console.warn(`Error attempting to toggle fullscreen: ${err && err.message ? err.message : err}`);
                showNotification('Vollbild konnte nicht aktiviert werden.');
            } finally {
                syncFullscreenUi();
            }
        });

        document.addEventListener('fullscreenchange', syncFullscreenUi);
        document.addEventListener('webkitfullscreenchange', syncFullscreenUi);
        document.addEventListener('fullscreenerror', () => {
            syncFullscreenUi();
            showNotification('Vollbild ist auf diesem Geraet nicht verfuegbar.');
        });
        document.addEventListener('webkitfullscreenerror', () => {
            syncFullscreenUi();
            showNotification('Vollbild ist auf diesem Geraet nicht verfuegbar.');
        });

        // 11. Custom Fullscreen Button (siehe oben)
        let lastBrightness = 0;


        let lastBrightnessCheck = 0;
        let backgroundBrightnessTimer = null;

        function scheduleBackgroundBrightnessCheck(delayMs = 600) {
            if (backgroundBrightnessTimer) clearTimeout(backgroundBrightnessTimer);
            backgroundBrightnessTimer = setTimeout(() => {
                requestAnimationFrame(checkBackgroundBrightness);
            }, Math.max(120, delayMs || 0));
        }
        function checkBackgroundBrightness(timestamp) {
            if (manualBackgroundDimLevel > 0) {
                subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            // Im Lesemodus immer dunkler Hintergrund
            if (isReadingMode) {
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            if (!gameReady || uiContainer.style.display === 'none') {
                scheduleBackgroundBrightnessCheck(700);
                return;
            }

            // Throttle: Nur alle 1000ms prüfen (Performance!)
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastBrightnessCheck < 1000) {
                scheduleBackgroundBrightnessCheck(260);
                return;
            }
            lastBrightnessCheck = timestamp;

            try {
                const uiRect = uiContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const sampleX = Math.max(0, (uiRect.left - canvasRect.left) * (canvas.width / canvasRect.width));
                const sampleY = Math.max(0, (uiRect.top - canvasRect.top) * (canvas.height / canvasRect.height));
                const sampleW = Math.min(canvas.width - sampleX, uiRect.width * (canvas.width / canvasRect.width));
                const sampleH = Math.min(canvas.height - sampleY, uiRect.height * (canvas.height / canvasRect.height));

                if (sampleW > 0 && sampleH > 0 && sampleX >= 0 && sampleY >= 0) {
                    const imageData = ctx.getImageData(
                        Math.floor(sampleX),
                        Math.floor(sampleY),
                        Math.floor(Math.min(sampleW, 100)),
                        Math.floor(Math.min(sampleH, 60))
                    );

                    let totalBrightness = 0;
                    const pixels = imageData.data;
                    const pixelCount = pixels.length / 4;

                    for (let i = 0; i < pixels.length; i += 16) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                    }

                    const avgBrightness = totalBrightness / (pixelCount / 4);
                    lastBrightness = lastBrightness * 0.85 + avgBrightness * 0.15;

                    // Stärkerer Kontrast: noch früher einsetzen, höhere Basis
                    const threshold = 60;
                    const maxBrightness = 180;
                    const baseOpacity = 0.5;
                    const maxAdditionalOpacity = 0.8;

                    if (lastBrightness > threshold) {
                        const dynamicOpacity = ((lastBrightness - threshold) / (maxBrightness - threshold)) * maxAdditionalOpacity;
                        const opacity = Math.min(0.95, baseOpacity + dynamicOpacity);
                        const bgValue = `rgba(0, 0, 0, ${opacity.toFixed(2)})`;
                        subtitleContainer.style.background = bgValue;
                        audioControlsEl.style.background = bgValue;
                    } else {
                        subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                        audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                    }
                }
            } catch (e) {
                // Canvas-Zugriff kann bei bestimmten Bedingungen fehlschlagen
            }

            scheduleBackgroundBrightnessCheck(700);
        }

        // Starte die Hintergrund-Prüfung
        scheduleBackgroundBrightnessCheck(350);

        // Global Start Time for Grace Period
        const GAME_START_TIME = Date.now();

        // ============================================
        // LORE PROXIMITY SYSTEM
        // ============================================
        function updateLoreSystem() {
            // Grace Period: 3 Sekunden keine Trigger nach Start
            if (!gameReady || yellowLights.length === 0 || (Date.now() - GAME_START_TIME < 3000)) return;

            const refW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const refH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const offsetY = Math.floor(refH * 0.22);
            const hatOffset = Math.floor(refH * 0.15);

            // Bounding Box des Charakters (synchron mit der visuellen Anzeige)
            // Nur der "Körper" (Hut bis Füße) löst den Trigger aus
            const pLeft = player.x;
            const pRight = player.x + refW;
            const pTop = player.y + offsetY + hatOffset;
            const pBottom = player.y + offsetY + refH;

            // Finde das nächste Licht und die Distanz zur Bounding Box
            let nearestId = null;
            let minDist = Infinity;

            yellowLights.forEach(light => {
                // Finde den nächsten Punkt auf der Bounding Box zum Licht
                const closestX = Math.max(pLeft, Math.min(light.x, pRight));
                const closestY = Math.max(pTop, Math.min(light.y, pBottom));

                const dx = light.x - closestX;
                const dy = light.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearestId = light.id;
                }
            });

            const TRIGGER_DIST = 6; // Reduced by ~70% (was 20)
            const EXIT_DIST = 25; // Adjusted Hysteresis

            // SHIMMER SOUND TRIGGER (Unabhängig vom Text)
            if (nearestId && minDist < TRIGGER_DIST) {
                // BUGFIX: Do not play shimmer if already collected!
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));

                if (!alreadyCollected) {
                    if (lastShimmerLightId !== nearestId) {
                        shimmerSound.currentTime = 0;
                        if (allowAuxScPlayback()) {
                            shimmerSound.play().catch(() => { });
                        }
                        lastShimmerLightId = nearestId;
                    }
                }
            } else if (!nearestId || minDist > EXIT_DIST) {
                // Reset, wenn man den Einflussbereich verlassen hat
                lastShimmerLightId = null;
            }

            // START LORE - Dynamic Sequential Unlock
            if (nearestId && minDist < TRIGGER_DIST && !isLoreMode) {
                // Safety Check: Ignore if Player or Light is at (0,0) (Spawn Glitch)
                const light = yellowLights.find(l => l.id === nearestId);
                if ((player.x === 0 && player.y === 0) || (light && light.x === 0 && light.y === 0)) {
                    return;
                }

                // Check if this specific light was already collected
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "index";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));
                if (alreadyCollected) {
                    return;
                }

                activeLightSourceId = nearestId;

                // Use GameState for unified persistence (syncs with YellowLight.draw check)
                if (window.GameState) {
                    window.GameState.collectLight(sc, nearestId).then(unlockedLoreId => {
                        if (unlockedLoreId) {
                            console.log("[GameState] Collected Light -> Unlocked Lore:", unlockedLoreId);
                            // Refresh archive menu so new lore appears immediately
                            if (typeof renderArchive === 'function') renderArchive();
                            // Start lore mode with the UNLOCKED lore ID (not the light ID!)
                            startLoreMode(unlockedLoreId);
                        } else {
                            console.log("[GameState] Light collected but all lore already unlocked.");
                        }
                    });
                } else {
                    // Fallback to local LoreSystem if GameState not available
                    if (!LoreSystem.state.collectedLights[sc]) LoreSystem.state.collectedLights[sc] = [];
                    LoreSystem.state.collectedLights[sc].push(nearestId);
                    LoreSystem.save();
                    const nextLore = LoreSystem.state.collectedLore.length + 1;
                    if (LoreSystem.unlock(nextLore)) {
                        console.log("[LoreSystem] Unlocked Lore:", nextLore);
                        startLoreMode(nextLore);
                    }
                }

            }
            // Lore intentionally keeps playing even after leaving the trigger area.
        } // End updateLoreSystem

        // NEW: Restore Main Audio Function (Replaces basic endLoreMode logic)
        function getActiveContentKey() {
            if (isLoreMode && activeLoreId) return `lore${activeLoreId}`;
            return MAIN_CONTENT_KEY;
        }

        function clearContentState(key) {
            if (!key) return;
            if (window.PlayerStateManager) {
                window.PlayerStateManager.clear(key);
            }

            if (key === MAIN_CONTENT_KEY) {
                mainAudioState.time = 0;
                mainAudioState.wasPlaying = false;
            } else if (key.startsWith('lore')) {
                const loreId = parseInt(key.replace('lore', ''), 10);
                if (Number.isFinite(loreId)) {
                    loreData.resumeTimes[loreId] = 0;
                }
            }
        }

        function isCurrentContentCompleted() {
            if (!subtitleTracks || subtitleTracks.length === 0) return false;
            const t = audioPlayer.currentTime || 0;
            const duration = audioPlayer.duration || 0;
            const reachedAudioEnd = duration > 0 && t >= Math.max(0, duration - 0.25);
            const reachedSubtitleEnd = currentSubtitleIndex >= subtitleTracks.length - 1;
            return reachedAudioEnd && reachedSubtitleEnd;
        }

        async function saveCurrentContentState(options = {}) {
            const {
                keyOverride = null,
                clear = false,
                preferCachedTime = false,
                reason = 'unspecified'
            } = options;

            const key = keyOverride || getActiveContentKey();
            if (!key || !audioPlayer) return;

            if (clear) {
                clearContentState(key);
                indexDebug.lastSave = { key, cleared: true, reason, at: Date.now() };
                indexDebugNote('state-clear', `${key} (${reason})`);
                return;
            }

            try {
                let currentTime = audioPlayer.currentTime || 0;
                if (!preferCachedTime && typeof audioPlayer.getAccurateCurrentTime === 'function') {
                    currentTime = await audioPlayer.getAccurateCurrentTime(800);
                }

                const wasPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !audioPlayer.paused;

                if (window.PlayerStateManager) {
                    if (typeof window.PlayerStateManager.saveStateAt === 'function') {
                        const sentence = window.PlayerStateManager.findSentenceStart(currentTime, subtitleTracks);
                        window.PlayerStateManager.saveStateAt(key, {
                            sentenceIndex: sentence.index,
                            sentenceTime: sentence.time,
                            wasPlaying
                        });

                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: sentence.index,
                            sentenceTime: Number((sentence.time || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} -> ${sentence.time.toFixed(2)}s idx=${sentence.index} play=${wasPlaying} (${reason})`);
                    } else {
                        window.PlayerStateManager.saveState(key, subtitleTracks, audioPlayer);
                        indexDebug.lastSave = {
                            key,
                            reason,
                            currentTime: Number(currentTime.toFixed(3)),
                            sentenceIndex: null,
                            sentenceTime: Number((currentTime || 0).toFixed(3)),
                            wasPlaying,
                            at: Date.now()
                        };
                        indexDebugNote('state-save', `${key} (legacy) ${currentTime.toFixed(2)}s (${reason})`);
                    }
                }

                if (key === MAIN_CONTENT_KEY) {
                    mainAudioState.wasPlaying = wasPlaying;
                    mainAudioState.time = currentTime || 0;
                    mainAudioState.tracks = [...subtitleTracks];
                } else if (key.startsWith('lore')) {
                    const loreId = parseInt(key.replace('lore', ''), 10);
                    if (Number.isFinite(loreId)) {
                        loreData.resumeTimes[loreId] = currentTime || 0;
                    }
                }
            } catch (e) {
                console.warn('[State] saveCurrentContentState failed:', e);
                indexDebugNote('state-error', `${reason}: ${e && e.message ? e.message : e}`);
            }
        }

        async function ensureMainTextLoaded() {
            if (window.mainTextContent && window.mainTextContent.length > 0) {
                return window.mainTextContent;
            }
            const response = await fetch('assets/kapitel1.txt');
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            window.mainTextContent = await response.text();
            return window.mainTextContent;
        }

        async function ensureLoreTextLoaded(id) {
            if (loreData.text[id] && loreData.text[id].length > 0) {
                return loreData.text[id];
            }

            const content = window.GameState?.getLore(id);
            const textPath = content ? content.text : `assets/lore${id}.txt`;
            const response = await fetch(textPath);
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            loreData.text[id] = await response.text();
            return loreData.text[id];
        }

        function findSubtitleIndexForTime(timeSec) {
            if (!subtitleTracks || subtitleTracks.length === 0) return 0;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (timeSec >= subtitleTracks[i].time) return i;
            }
            return 0;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForContentSwitchIdle(reason, timeoutMs = 2200) {
            const endAt = Date.now() + Math.max(300, timeoutMs || 0);
            let waited = 0;
            while (contentSwitchInProgress && Date.now() < endAt) {
                await wait(60);
                waited += 60;
            }
            if (contentSwitchInProgress) {
                indexDebugNote('switch-wait-timeout', `${reason || 'unknown'} waited=${waited}ms`);
            } else if (waited > 0) {
                indexDebugNote('switch-wait', `${reason || 'unknown'} waited=${waited}ms`);
            }
        }

        async function seekAndSyncSubtitle(targetTime, reason) {
            const safeTarget = Math.max(0, Number(targetTime) || 0);
            indexTrace('seek:start', {
                reason,
                target: Number(safeTarget.toFixed(3)),
                before: Number(((audioPlayer && audioPlayer.currentTime) || 0).toFixed(3))
            });
            let seekResult = {
                ok: false,
                target: safeTarget,
                position: audioPlayer.currentTime || 0,
                attempts: 0
            };

            try {
                if (typeof audioPlayer.seekAndConfirm === 'function') {
                    seekResult = await audioPlayer.seekAndConfirm(safeTarget, {
                        maxAttempts: 5,
                        settleMs: 220,
                        tolerance: 0.9
                    });
                } else {
                    audioPlayer.currentTime = safeTarget;
                    await wait(260);
                    const pos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                        ? await audioPlayer.getAccurateCurrentTime(900)
                        : (audioPlayer.currentTime || 0);
                    seekResult = {
                        ok: Math.abs(pos - safeTarget) <= 1.0 || pos >= safeTarget - 1.0,
                        target: safeTarget,
                        position: pos,
                        attempts: 1
                    };
                }
            } catch (e) {
                indexDebugNote('seek-error', `${reason}: ${e && e.message ? e.message : e}`);
            }

            const effectiveTime = Number.isFinite(seekResult.position) ? seekResult.position : safeTarget;
            currentSubtitleIndex = findSubtitleIndexForTime(effectiveTime);
            renderSubtitleLines(currentSubtitleIndex);
            indexDebugNote('seek', `${reason} target=${safeTarget.toFixed(2)} pos=${effectiveTime.toFixed(2)} ok=${seekResult.ok} tries=${seekResult.attempts}`);
            indexTrace('seek:end', {
                reason,
                ok: !!seekResult.ok,
                attempts: seekResult.attempts || 0,
                target: Number(safeTarget.toFixed(3)),
                position: Number((effectiveTime || 0).toFixed(3)),
                subtitleIndex: currentSubtitleIndex
            });
            return seekResult;
        }

        async function pauseWithFade(duration = 800) {
            if (!audioPlayer || audioPlayer.paused) return;
            await new Promise(resolve => {
                fadeAudio(audioPlayer, 0, duration, () => {
                    audioPlayer.pause();
                    resolve();
                });
            });
        }

        async function verifyPlaybackStarted(retries = 2, delayMs = 320) {
            let previousPos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                ? await audioPlayer.getAccurateCurrentTime(600)
                : (audioPlayer.currentTime || 0);
            let sawRecentProgress = (typeof audioPlayer.hasRecentProgress === 'function')
                ? audioPlayer.hasRecentProgress(1800)
                : false;
            indexTrace('verify-play:start', {
                retries,
                delayMs,
                startPos: Number((previousPos || 0).toFixed(3)),
                paused: !!audioPlayer.paused,
                transportPaused: isAudioTransportPaused(),
                sawRecentProgress
            });

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    await audioPlayer.play();
                } catch (e) {
                    console.warn(`[Audio] play() failed on attempt ${attempt + 1}:`, e);
                    indexTrace('verify-play:play-error', { attempt: attempt + 1, message: e && e.message ? e.message : String(e) });
                }

                await wait(delayMs);
                const currentPos = (typeof audioPlayer.getAccurateCurrentTime === 'function')
                    ? await audioPlayer.getAccurateCurrentTime(700)
                    : (audioPlayer.currentTime || 0);
                const advanced = Number.isFinite(currentPos) && Number.isFinite(previousPos)
                    ? (currentPos - previousPos) >= 0.08
                    : false;
                const probablyPlaying = (typeof audioPlayer.isProbablyPlaying === 'function')
                    ? audioPlayer.isProbablyPlaying()
                    : !audioPlayer.paused;
                const transportPaused = isAudioTransportPaused();
                const hasRecentProgress = (typeof audioPlayer.hasRecentProgress === 'function')
                    ? audioPlayer.hasRecentProgress(1800)
                    : false;
                sawRecentProgress = sawRecentProgress || hasRecentProgress;
                const started = !transportPaused && (advanced || hasRecentProgress);
                indexDebugNote(
                    'play-check',
                    `attempt=${attempt + 1} paused=${audioPlayer.paused} playing=${probablyPlaying} adv=${advanced} t=${currentPos.toFixed(2)}`
                );
                indexTrace('verify-play:attempt', {
                    attempt: attempt + 1,
                    paused: !!audioPlayer.paused,
                    transportPaused,
                    probablyPlaying: !!probablyPlaying,
                    advanced: !!advanced,
                    hasRecentProgress,
                    previousPos: Number((previousPos || 0).toFixed(3)),
                    currentPos: Number((currentPos || 0).toFixed(3)),
                    started
                });
                if (started) {
                    indexTrace('verify-play:success', { attempt: attempt + 1, currentPos: Number((currentPos || 0).toFixed(3)) });
                    return true;
                }
                previousPos = Number.isFinite(currentPos) ? currentPos : previousPos;
            }
            // Last fallback: if transport isn't paused and we observed recent progress,
            // treat playback as started even when sampling delta was too small.
            const finalTransportPaused = isAudioTransportPaused();
            if (!finalTransportPaused && sawRecentProgress) {
                indexTrace('verify-play:success-fallback', { sawRecentProgress: true });
                return true;
            }
            indexTrace('verify-play:failed', { retries, delayMs });
            return false;
        }

        async function restoreMainAudio(options = {}) {
            const {
                saveCurrent = true,
                forceResume = false
            } = options;
            indexTrace('switch:restore-main:enter', { saveCurrent: !!saveCurrent, forceResume: !!forceResume });

            if (!isLoreMode && !contentSwitchInProgress) {
                return;
            }

            if (contentSwitchInProgress) {
                indexTrace('switch:restore-main:blocked', { reason: 'contentSwitchInProgress' });
                return;
            }
            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;
            indexTrace('switch:restore-main:lock', { switchToken });

            try {
                const loreIdBeforeSwitch = activeLoreId;
                if (saveCurrent && loreIdBeforeSwitch) {
                    await saveCurrentContentState({ keyOverride: `lore${loreIdBeforeSwitch}`, reason: 'restore-main:save-lore' });
                } else if (!saveCurrent && loreIdBeforeSwitch) {
                    clearContentState(`lore${loreIdBeforeSwitch}`);
                }

                // --- RADICAL iOS FALLBACK RESTORE ---
                if (typeof isIOSDevice !== 'undefined' && isIOSDevice) {
                    if (ambientAudio && ambientAudio.audioNode && !ambientAudio.audioNode.src) {
                        ambientAudio.src = getSCUrl(AUDIO_PROFILE.ambientUrl || 'assets/wind.mp3');
                    }
                    if (footstepSound && footstepSound.audioNode && !footstepSound.audioNode.src) {
                        footstepSound.src = getSCUrl('assets/footstep.mp3');
                    }
                }
                // ------------------------------------

                isLoreMode = false;
                isMenuTriggeredLore = false;
                activeLoreId = null;
                activeLightSourceId = null;
                applySceneAudioMix('restore-main:mode');

                if (loreResumeTimeout) {
                    clearTimeout(loreResumeTimeout);
                    loreResumeTimeout = null;
                }

                uiContainer.classList.add('mode-switching');
                indexTrace('switch:restore-main:ui-mode-switching-on', { switchToken });

                await pauseWithFade(700);
                if (switchToken !== contentSwitchToken) return;

                audioPlayer.src = getSCUrl(window.mainAudioUrl || LEVEL.audioUrl);
                indexTrace('switch:restore-main:src-set', { switchToken, src: audioPlayer.src });

                const mainText = await ensureMainTextLoaded();
                if (switchToken !== contentSwitchToken) return;
                parseSubtitles(mainText);
                indexTrace('switch:restore-main:text-parsed', { switchToken, tracks: subtitleTracks.length });

                const savedMain = window.PlayerStateManager ? window.PlayerStateManager.getState(MAIN_CONTENT_KEY) : null;
                const resumeTime = savedMain && savedMain.sentenceTime !== undefined
                    ? savedMain.sentenceTime
                    : Math.max(0, mainAudioState.time || 0);
                indexTrace('switch:restore-main:resume-time', {
                    switchToken,
                    resumeTime: Number((resumeTime || 0).toFixed(3)),
                    hasSavedMain: !!savedMain
                });
                indexDebugNote('restore-main', `resume=${resumeTime.toFixed(2)}s saved=${!!savedMain}`);
                await seekAndSyncSubtitle(resumeTime, 'restore-main:pre-play');

                const shouldResumePlayback = forceResume || (savedMain ? !!savedMain.wasPlaying : !!mainAudioState.wasPlaying);
                indexTrace('switch:restore-main:resume-decision', { switchToken, shouldResumePlayback: !!shouldResumePlayback });
                if (shouldResumePlayback) {
                    audioPlayer.volume = 0;
                    const started = await verifyPlaybackStarted(4, 320);
                    indexTrace('switch:restore-main:verify-result', { switchToken, started: !!started });
                    if (started) {
                        // Re-render subtitles at the already-seeked position without re-seeking
                        currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                        renderSubtitleLines(currentSubtitleIndex);
                        fadeAudio(audioPlayer, 1.0, 700);
                        iconPlay.style.display = 'none';
                        iconPause.style.display = 'block';
                    } else {
                        audioPlayer.volume = 1.0;
                        iconPlay.style.display = 'block';
                        iconPause.style.display = 'none';
                    }
                } else {
                    audioPlayer.volume = 1.0;
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error('[Switch] Failed to restore main audio:', e);
                indexTrace('switch:restore-main:error', { message: e && e.message ? e.message : String(e) });
                indexDebugNote('restore-main-error', e && e.message ? e.message : String(e));
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                    indexTrace('switch:restore-main:unlock', { switchToken });
                }
            }
        }

        async function startLoreMode(id, fromMenu = false) {
            indexTrace('switch:start-lore:enter', { id, fromMenu: !!fromMenu });
            if (isLoreMode && activeLoreId === id) return;
            if (contentSwitchInProgress) {
                await waitForContentSwitchIdle(`start-lore:${id}`);
                if (contentSwitchInProgress) {
                    indexTrace('switch:start-lore:blocked-after-wait', { id });
                    return;
                }
            }

            const content = window.GameState?.getLore(id) || {
                audio: loreData.audio[id] || `assets/lore${id}.mp3`,
                text: `assets/lore${id}.txt`
            };

            contentSwitchInProgress = true;
            const switchToken = ++contentSwitchToken;
            indexTrace('switch:start-lore:lock', { id, switchToken });

            try {
                await saveCurrentContentState({ reason: `start-lore:${id}` });

                // --- RADICAL iOS FALLBACK: Free hardware audio slot ---
                if (typeof isIOSDevice !== 'undefined' && isIOSDevice) {
                    if (ambientAudio && typeof ambientAudio.pause === 'function') ambientAudio.pause();
                    if (footstepSound && typeof footstepSound.pause === 'function') footstepSound.pause();
                    if (ambientAudio && ambientAudio.audioNode) {
                        ambientAudio.audioNode.removeAttribute('src');
                        ambientAudio.audioNode.load();
                    }
                    if (footstepSound && footstepSound.audioNode) {
                        footstepSound.audioNode.removeAttribute('src');
                        footstepSound.audioNode.load();
                    }
                }
                // -----------------------------------------------------

                isLoreMode = true;
                activeLoreId = id;
                isMenuTriggeredLore = !!fromMenu;
                moveTarget = null;
                applySceneAudioMix('start-lore:mode');

                if (isReadingMode) {
                    uiContainer.classList.add('reading-mode');
                } else {
                    uiContainer.classList.remove('reading-mode');
                }
                uiContainer.classList.add('mode-switching');
                indexTrace('switch:start-lore:ui-mode-switching-on', { id, switchToken });

                await pauseWithFade(800);
                if (switchToken !== contentSwitchToken) return;

                const loreText = await ensureLoreTextLoaded(id);
                if (switchToken !== contentSwitchToken) return;

                const loreAudioSrc = getSCUrl(content.audio || loreData.audio[id] || `assets/lore${id}.mp3`);
                audioPlayer.src = loreAudioSrc;
                indexTrace('switch:start-lore:src-set', { id, switchToken, src: loreAudioSrc });

                parseSubtitles(loreText);
                indexTrace('switch:start-lore:text-parsed', { id, switchToken, tracks: subtitleTracks.length });
                const savedLore = window.PlayerStateManager ? window.PlayerStateManager.getState(`lore${id}`) : null;
                const resumeTime = savedLore && savedLore.sentenceTime !== undefined
                    ? savedLore.sentenceTime
                    : Math.max(0, loreData.resumeTimes[id] || 0);
                indexTrace('switch:start-lore:resume-time', {
                    id,
                    switchToken,
                    resumeTime: Number((resumeTime || 0).toFixed(3)),
                    hasSavedLore: !!savedLore
                });
                indexDebugNote('start-lore', `id=${id} resume=${resumeTime.toFixed(2)}s saved=${!!savedLore} fromMenu=${!!fromMenu}`);
                await seekAndSyncSubtitle(resumeTime, `start-lore:${id}:pre-play`);

                audioPlayer.volume = 0;
                const started = await verifyPlaybackStarted(3, 320);
                indexTrace('switch:start-lore:verify-result', { id, switchToken, started: !!started });
                if (switchToken !== contentSwitchToken) return;

                if (started) {
                    // Re-render subtitles at the already-seeked position without re-seeking
                    currentSubtitleIndex = findSubtitleIndexForTime(resumeTime);
                    renderSubtitleLines(currentSubtitleIndex);
                    fadeAudio(audioPlayer, 1.0, 900);
                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';
                } else {
                    audioPlayer.volume = 1.0;
                    console.warn(`[Switch] Lore ${id} loaded but playback did not start.`);
                    iconPlay.style.display = 'block';
                    iconPause.style.display = 'none';
                }
            } catch (e) {
                console.error(`[Switch] Failed to start lore ${id}:`, e);
                indexTrace('switch:start-lore:error', { id, message: e && e.message ? e.message : String(e) });
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            } finally {
                if (switchToken === contentSwitchToken) {
                    contentSwitchInProgress = false;
                    uiContainer.classList.remove('mode-switching');
                    indexTrace('switch:start-lore:unlock', { id, switchToken });
                }
            }
        }

        function endLoreMode() {
            indexTrace('switch:end-lore', { activeLoreId: activeLoreId || null });
            restoreMainAudio({ saveCurrent: true });
        }

        function fadeAudio(audio, targetVolume, duration, callback) {
            const startVolume = audio.volume;
            const diff = targetVolume - startVolume;
            const startTime = Date.now();

            function tick() {
                const now = Date.now();
                const progress = Math.min(1, (now - startTime) / duration);
                audio.volume = startVolume + diff * progress;

                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (callback) {
                    callback();
                }
            }
            tick();
        }


    </script>
</body>

</html>
