<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 1c - Steingasse</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            min-height: 100vh;
            height: 100vh;
            /* Volle Höhe für Filter */
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        /* LOADING SCREEN (über allem) */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #444;
            font-family: 'Segoe UI', system-ui, sans-serif;
            transition: opacity 1s ease;
        }

        #loading-screen .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        #dropZone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            z-index: 100;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        #dropZone.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #dropZone.dragover {
            background: linear-gradient(135deg, #1a1a3e 0%, #2a2a4e 100%);
        }

        .drop-content {
            text-align: center;
            color: #888;
            pointer-events: none;
        }

        .drop-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .drop-title {
            font-size: 28px;
            font-weight: 300;
            color: #ccc;
            margin-bottom: 15px;
        }

        .drop-subtitle {
            font-size: 14px;
            color: #666;
            margin-bottom: 30px;
        }

        .color-hints {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .color-hint {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .color-swatch.magenta {
            background: #FF00FF;
        }

        .color-swatch.cyan {
            background: #00FFFF;
        }

        .color-label {
            font-size: 13px;
            color: #aaa;
        }

        .color-desc {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }

        .file-input-wrapper {
            margin-top: 20px;
        }

        .file-input-wrapper input {
            display: none;
        }

        .file-btn {
            padding: 14px 32px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            pointer-events: all;
        }

        .file-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        /* FILTER UI */
        #filterControls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            color: #ccc;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s;
        }

        #filterControls:hover {
            opacity: 1;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 13px;
        }

        .filter-option input {
            accent-color: #3b82f6;
        }

        /* CANVAS WRAPPER für OVERLAYS */
        #gameWrapper {
            position: relative;
            line-height: 0;
            /* Kein Gap unten */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            /* Force GPU for Filters (Mobile Fix) */
            transform: translate3d(0, 0, 0);
            will-change: filter;
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* FILTER 1: PAL OPTIK 
           Kombination aus SVG Filter (Blur/H-Smear) und CSS Filter (Sättigung/Kontrast) */
        .effect-pal #gameCanvas {
            filter: url(#pal-filter) contrast(1.0) brightness(1.15) saturate(0.85);
        }

        /* FILTER 2: GLITCH (Störung) 
           Displacement Map via SVG */
        .effect-glitch #gameCanvas {
            filter: url(#glitch-filter);
        }

        /* Kombinationen ermöglichen */
        .effect-pal.effect-glitch #gameCanvas {
            filter: url(#pal-filter) url(#glitch-filter) contrast(1.0) brightness(1.15) saturate(0.85);
        }

        /* FILTER 3: CRT OVERLAY - NUR VIGNETTE (Scanlines entfernt wg. Moiré) */
        #crtOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
            /* Keine Scanlines mehr - verursachten diagonale Artefakte */
            background: transparent;
        }

        .effect-crt #crtOverlay {
            opacity: 1;
        }

        /* Vignette für CRT Look */
        #crtOverlay::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(0, 0, 0, 0) 60%, rgba(0, 0, 0, 0) 100%);
            pointer-events: none;
        }


        #controlsHint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            color: #888;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        #controlsHint.visible {
            opacity: 1;
        }

        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            border-radius: 4px;
            margin: 0 3px;
            font-family: monospace;
            border: 1px solid #555;
        }

        #processingInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 12px;
            color: white;
            text-align: center;
            z-index: 200;
            display: none;
        }

        #processingInfo .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #3b82f6;
            border-radius: 50%;
            margin: 0 auto 15px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #debugLog {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 4px;
            z-index: 9999;
            pointer-events: none;
            max-width: 300px;
            display: block;
        }

        /* AUDIO PLAYER UI */
        #audioPlayerUI {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 800px;
            display: flex;
            align-items: center;
            /* Buttons auf Höhe der mittleren Zeile */
            gap: 15px;
            z-index: 1000;
            transition: bottom 0.4s ease, transform 0.4s ease;
        }

        #audioPlayerUI.reading-mode {
            bottom: 50%;
            transform: translateX(-50%) translateY(50%);
        }

        /* Während Modus-Wechsel: Buttons ausblenden */
        #audioPlayerUI.mode-switching #audioControls {
            opacity: 0 !important;
            pointer-events: none;
        }

        #subtitleContainer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            /* Anchor to bottom in Game Mode */
            align-items: flex-start;
            gap: 8px;
            /* Slightly more gap */
            padding: 16px 21px;
            border-radius: 8px;
            background: transparent !important;
            transition: background 0.5s ease;
            max-height: none;
            /* DO NOT LIMIT HEIGHT IN GAME MODE - Let text grow up */
            min-height: 80px;
            /* Ensure at least some height */
        }

        #audioPlayerUI.reading-mode #subtitleContainer {
            max-height: 70vh;
            background: transparent !important;
            /* WAR: rgba(0, 0, 0, 0.85); */
            overflow-y: auto;
            pointer-events: auto;
            /* Ensure interactions work */
            /* Scrollen ermöglichen */

            /* Custom Scrollbar Styles */
            scrollbar-width: thin;
            /* Firefox */
            scrollbar-color: rgba(255, 255, 255, 0.4) transparent;
            /* Firefox */
        }

        /* Webkit Scrollbar Styling (Chrome, Edge, Safari) */
        #audioPlayerUI.reading-mode #subtitleContainer::-webkit-scrollbar {
            width: 6px !important;
            /* Thinner */
        }

        #audioPlayerUI.reading-mode #subtitleContainer::-webkit-scrollbar-track {
            background: transparent !important;
            /* Totally transparent */
            margin: 4px 0;
        }

        #audioPlayerUI.reading-mode #subtitleContainer::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            /* Subtle semi-transparent white */
            border-radius: 10px;
            /* Fully rounded */
            border: 1px solid transparent;
            /* Padding trick */
            background-clip: content-box;
            transition: background-color 0.2s;
        }

        /* Sichtbar bei Hover oder beim Scrollen per JS-Klasse */
        #audioPlayerUI.reading-mode #subtitleContainer:hover::-webkit-scrollbar-thumb,
        #audioPlayerUI.reading-mode #subtitleContainer.is-scrolling::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.4);
        }

        #audioPlayerUI.reading-mode #subtitleContainer::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.6);
        }

        .subtitle-line {
            text-align: left;
            font-size: 18px;
            font-weight: 400;
            /* War 500 */
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 1), 0 0 20px rgba(0, 0, 0, 0.8);
            transition: color 0.3s, opacity 0.3s;
            opacity: 1;
        }

        .subtitle-current {
            color: rgba(255, 255, 255, 0.95) !important;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        /* Lesemodus: NOCH deutlicherer diffuse Umwölkung hinter den Buchstaben */
        #audioPlayerUI.reading-mode .subtitle-line {
            text-shadow:
                0 0 5px rgba(0, 0, 0, 1),
                0 0 10px rgba(0, 0, 0, 1),
                0 0 20px rgba(0, 0, 0, 1),
                0 0 30px rgba(0, 0, 0, 1),
                0 0 45px rgba(0, 0, 0, 1);
            opacity: 1 !important;
        }

        /* Soft Edges Mask for Reading Mode Container */
        #audioPlayerUI.reading-mode #subtitleContainer {
            /* Reset Flex Alignment for Reading Mode: Top-Down flow */
            justify-content: flex-start;

            mask-image: linear-gradient(to bottom, transparent 0px, black 120px, black calc(100% - 120px), transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0px, black 120px, black calc(100% - 120px), transparent 100%);

            padding-top: 120px;
            /* Push first line below the top fade */
            padding-bottom: 120px;
            /* Push last line above bottom fade */

            pointer-events: auto !important;
            touch-action: pan-y;
            user-select: none;
            /* Improve drag feel */
        }

        /* NEXT CHAPTER BUTTON */
        #nextChapterBtn {
            position: absolute;
            bottom: 120px;
            /* Above controls */
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-family: 'Georgia', serif;
            font-size: 18px;
            letter-spacing: 2px;
            cursor: pointer;
            border-radius: 4px;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease, transform 0.2s ease;
            z-index: 200;
            text-transform: uppercase;
        }

        #nextChapterBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%) scale(1.05);
        }

        #nextChapterBtn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* BLACK OVERLAY FOR TRANSITION */
        #transitionOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
            z-index: 9999;
        }

        #transitionOverlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Zeilen die weit vom Zentrum entfernt sind verblassen */
        .subtitle-line.fade-far {
            opacity: 0.4;
        }

        .subtitle-line.fade-mid {
            opacity: 0.6;
        }

        /* Controls Container - Kreuz-Layout */
        #audioControls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            flex-shrink: 0;
            padding: 8px;
            border-radius: 8px;
            background: transparent !important;
            transition: background 0.5s ease, opacity 0.3s ease;
        }

        /* Horizontale Reihe: Zurück - Play - Vor (im Spielmodus) */
        .controls-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            justify-items: center;
            align-items: center;
            width: 140px;
            /* Fixed width for alignment */
            /* gap removed, grid handles it */
            transition: opacity 0.3s ease;
        }

        /* Im Lesemodus: Alles vertikal */
        #audioPlayerUI.reading-mode .controls-row {
            display: flex;
            /* Revert to flex for column layout */
            flex-direction: column;
            width: auto;
            /* Reset width */
            gap: 8px;
        }

        .audio-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 6px;
            transition: transform 0.2s, opacity 0.3s ease;
            opacity: 0.7;
        }

        .audio-btn:hover {
            transform: scale(1.15);
            opacity: 1;
        }

        .audio-btn svg {
            filter: drop-shadow(2px 2px 6px rgba(0, 0, 0, 0.8));
            width: 24px;
            height: 24px;
        }

        #audioToggleBtn svg {
            width: 32px;
            height: 32px;
        }

        /* Modus-Button-Styling - Fade statt display toggle */
        #readingModeBtn svg,
        #gameModeBtn svg {
            width: 20px;
            height: 20px;
        }

        #gameModeBtn {
            opacity: 0;
            pointer-events: none;
            position: absolute;
            transition: opacity 0.3s ease;
        }

        #readingModeBtn {
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        #audioPlayerUI.reading-mode #readingModeBtn {
            opacity: 0;
            pointer-events: none;
            position: absolute;
        }

        #audioPlayerUI.reading-mode #gameModeBtn {
            opacity: 1 !important;
            /* Force Visibility */
            pointer-events: auto;
            position: relative;
            display: block !important;
        }

        .mode-btn-wrapper {
            position: relative;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            justify-items: center;
            align-items: center;
            width: 140px;
            /* Match controls-row width */
            min-height: 32px;
            /* gap removed */
        }

        /* Im Lesemodus: Vertikale Anordnung der Mode-Buttons (Mode + Fullscreen) */
        #audioPlayerUI.reading-mode .mode-btn-wrapper {
            display: flex;
            /* Revert to flex */
            flex-direction: column;
            width: auto;
            margin-top: 4px;
            /* Etwas Abstand zur Steuer-Reihe darüber */
        }

        #fullscreenBtn svg {
            width: 22px;
            height: 22px;
        }

        /* =========================================
           MOBILE OPTIMIZATIONS (Max-width: 768px) 
           ========================================= */
        @media (max-width: 768px) {

            /* 1. Canvas responsive machen */
            #gameWrapper {
                width: 100% !important;
                height: 100vh !important;
                /* Volle Bildschirmhöhe für Filter */
                display: flex;
                justify-content: center;
                align-items: flex-start;
                /* Oben ausrichten */
            }

            #gameCanvas {
                width: 100% !important;
                height: 100% !important;
                max-width: 100%;
                /* Keine feste Aspect-Ratio auf Mobile, da wir dynamisch resizen */
                object-fit: fill;
            }

            /* 2. Audio Player UI: Unten angedockt, volle Breite */
            #audioPlayerUI {
                width: 100%;
                max-width: 100%;
                bottom: 10px;
                padding: 0 10px;
                flex-direction: column;
                /* Stapeln für bessere Raumnutzung */
                align-items: stretch;
                /* Volle Breite nutzen */
                gap: 8px;
                position: fixed;
                /* Ensure fixed here too */
            }

            /* Controls Row horizontal zentriert */
            .controls-row {
                justify-content: center;
                width: 100%;
            }

            /* Game Mode UI etwas hoeher schieben damit Text nicht abgeschnitten wird */
            #audioPlayerUI:not(.reading-mode) {
                bottom: 20px;
                /* War 10px */
            }

            /* ALL 6 BUTTONS IN ONE ROW */
            #audioControls {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                justify-content: space-evenly !important;
                align-items: center !important;
                width: 100% !important;
                gap: 0 !important;
                padding: 8px 10px !important;
                position: fixed !important;
                bottom: 15px !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 2000 !important;
                background: transparent !important;
            }

            /* Flatten control rows into the main flex container */
            .controls-row,
            .mode-btn-wrapper {
                display: contents !important;
            }



            /* Ensure Subtitle Container doesn't overlap controls */
            #subtitleContainer {
                padding-bottom: 60px !important;
                /* Reserve space for absolute controls */
            }

            /* Buttons größer für Touch */
            .audio-btn svg {
                width: 28px;
                height: 28px;
            }

            #audioToggleBtn svg {
                width: 36px;
                height: 36px;
            }

            .audio-btn:focus,
            .audio-btn:focus-visible {
                outline: none !important;
            }

            /* 3. Untertitel Container: Spielmodus */
            #subtitleContainer {
                align-items: flex-start;
                text-align: left;
                background: transparent !important;
                /* backdrop-filter: blur(2px); REMOVED */
                margin-bottom: 5px;
                margin-bottom: 5px;
                /* Dynamische Höhe: zeige komplette Timestamps */
                max-height: 200px;
                min-height: 80px;
                overflow-y: auto;
                /* Scrollen wenn nötig */
            }

            .subtitle-line {
                text-align: left;
                /* User-Wunsch: Flattersatz (Linksbuendig) */
                font-size: 16px;
                width: 100%;
            }

            /* 4. Lesemodus Mobile: Unten positionieren, Buttons nebeneinander */
            #audioPlayerUI.reading-mode {
                bottom: 20px;
                top: auto;
                /* Desktop setzt top, das müssen wir überschreiben */
                transform: translateX(-50%);
                /* Nur horizontal zentriert */
            }

            /* Buttons nebeneinander wie im Spielmodus */
            #audioPlayerUI.reading-mode .controls-row {
                flex-direction: row;
            }

            #audioPlayerUI.reading-mode #audioControls,
            #audioPlayerUI.reading-mode #gameModeBtn {
                pointer-events: auto;
            }
        }

        /* LEGACY ARCHIVE CSS DELETED */

        /* REPLACED ARCHIVE CSS with INHALT DESIGN */
        /* REPLACED ARCHIVE CSS with INHALT DESIGN - STRICT WHITE */
        #archiveModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            /* PURE BLUR, NO TINT */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: transparent;
        }

        #archiveModal.visible {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        .archive-card {
            width: 80%;
            max-width: 600px;
            height: 70%;
            display: flex;
            flex-direction: column;
            /* PURE WHITE TEXT */
            color: #FFFFFF;
            font-family: "Georgia", serif;
            text-shadow: none;
            /* Removed shadows as requested */
        }

        .archive-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border: none;
            /* NO LINES */
        }

        .archive-title {
            font-size: 24px;
            font-weight: normal;
            /* No bold */
            letter-spacing: 2px;
            text-shadow: none;
        }

        .close-btn {
            background: none;
            border: none;
            color: #FFFFFF;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .close-btn:hover {
            opacity: 1.0;
            text-shadow: none;
        }

        /* 2-Column Layout */
        .archive-content {
            display: flex;
            gap: 40px;
            flex: 1;
            overflow: hidden;
        }

        .col-left,
        .col-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .col-header {
            font-size: 14px;
            color: #FFFFFF;
            /* Pure White */
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: normal;
        }

        /* Menu Items */
        .menu-item {
            cursor: pointer;
            padding: 5px 0;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 2px;
            opacity: 1.0;
            /* No dimming for active items */
        }

        .menu-item:hover {
            transform: translateX(5px);
        }

        .menu-item.locked {
            opacity: 0.3;
            cursor: default;
        }

        .menu-item.locked:hover {
            transform: none;
        }

        .item-main-text {
            font-size: 18px;
            color: #FFFFFF;
            font-weight: normal;
        }

        .item-sub-text {
            font-size: 11px;
            color: #FFFFFF;
            /* Pure White */
            font-style: italic;
        }

        /* Active State */
        .menu-item.active .item-main-text {
            color: #FFFFFF;
            text-decoration: underline;
            /* Simple active indicator instead of color/gold */
        }

        .menu-item.locked {
            opacity: 0.3;
            cursor: default;
        }

        .menu-item.locked:hover {
            transform: none;
            text-shadow: none;
        }

        .item-main-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.95);
        }

        .item-sub-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        /* Active State (e.g. current chapter) */
        .menu-item.active .item-main-text {
            color: #ffd700;
            /* Goldish for active? Or just White */
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* SCROLL BARS HIDDEN */
        .col-left::-webkit-scrollbar,
        .col-right::-webkit-scrollbar {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.98);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* NEXT CHAPTER BUTTON */
        #nextChapterBtn {
            position: absolute;
            bottom: 120px;
            /* Above controls */
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-family: 'Georgia', serif;
            font-size: 18px;
            letter-spacing: 2px;
            cursor: pointer;
            border-radius: 4px;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease, transform 0.2s ease;
            z-index: 2000;
            /* High z-index */
            text-transform: uppercase;
        }

        #nextChapterBtn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%) scale(1.05);
        }

        #nextChapterBtn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* BLACK OVERLAY FOR TRANSITION */
        #transitionOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
            z-index: 9999;
        }

        #transitionOverlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* =========================================
           MOBILE OPTIMIZATIONS (Max-width: 768px)
           ========================================= */
        @media (max-width: 768px) {

            /* ALL 6 BUTTONS IN ONE ROW */
            #audioControls {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                justify-content: space-evenly !important;
                align-items: center !important;
                width: 100% !important;
                gap: 0 !important;
                padding: 8px 10px !important;
                position: fixed !important;
                bottom: 15px !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 2000 !important;
                background: transparent !important;
            }

            /* Flatten control rows into the main flex container */
            .controls-row,
            .mode-btn-wrapper {
                display: contents !important;
            }

            /* Buttons */
            .audio-btn {
                padding: 8px !important;
            }

            .audio-btn svg {
                width: 26px !important;
                height: 26px !important;
            }

            #audioToggleBtn svg {
                width: 32px !important;
                height: 32px !important;
            }

            /* AUDIO PLAYER UI - Fixed at Bottom */
            #audioPlayerUI {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
                max-width: 100% !important;
                padding: 10px !important;
                flex-direction: column !important;
                align-items: flex-start !important;
                transform: none !important;
            }

            /* SUBTITLE CONTAINER - Above Controls */
            #subtitleContainer {
                padding-bottom: 80px !important;
                max-height: 45vh !important;
                align-items: flex-start !important;
                text-align: left !important;
                width: 100% !important;
            }

            .subtitle-line {
                text-align: left !important;
            }

            /* READING MODE - Text uses upper screen */
            #audioPlayerUI.reading-mode {
                top: 0 !important;
                bottom: 0 !important;
                height: 100% !important;
                transform: none !important;
            }

            #audioPlayerUI.reading-mode #subtitleContainer {
                flex-grow: 1 !important;
                max-height: calc(100% - 70px) !important;
                padding-top: 60px !important;
                padding-bottom: 80px !important;
                overflow-y: auto !important;
            }
        }
    </style>
</head>

<body>

    <!-- LOADING SCREEN (über ALLEM) -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>INITIALIZING...</p>
    </div>

    <!-- SVG Filter Definitionen -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1"
        xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- PAL Filter: Horizontal Blur + leichte Farbverschiebung -->
            <filter id="pal-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="0.6 0" result="blur" />
                <feColorMatrix in="blur" type="matrix" values="
                    0.9 0.1 0.0 0 0
                    0.0 0.9 0.1 0 0
                    0.0 0.0 0.9 0 0
                    0   0   0   1 0" result="colored" />
            </filter>

            <!-- Glitch Filter: Turbulenz Displacement -->
            <!-- <filter id="glitch-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feTurbulence type="fractalNoise" baseFrequency="0.002 0.005" numOctaves="3" seed="0" result="noise">
                    <animate attributeName="baseFrequency" dur="60s" values="0.002 0.005;0.005 0.01;0.002 0.005"
                        repeatCount="indefinite" />
                    <animate attributeName="seed" dur="3s" values="0;100;0" repeatCount="indefinite" />
                </feTurbulence>
                <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R"
                    yChannelSelector="G" />
            </filter> -->
        </defs>
    </svg>

    <!-- DropZone removed for Electron App -->

    <div id="processingInfo">
        <div class="spinner"></div>
        <div>Verarbeite Karte...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="transitionOverlay"></div>

    <!-- MAIN GAME AREA -->
    <div id="gameWrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="crtOverlay"></div>
    </div>

    <div id="audioPlayerUI" style="display:none;">
        <div id="subtitleContainer">
            <!-- Dynamisch generierte Zeilen -->
        </div>

        <!-- Next Chapter Button (Hidden by default) -->
        <button id="nextChapterBtn">Weiter</button>

        <div id="audioControls">
            <div class="controls-row">
                <button id="skipBackBtn" class="audio-btn" title="-15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
                <button id="audioToggleBtn" class="audio-btn" tabindex="-1">
                    <svg id="iconPlay" viewBox="0 0 24 24" fill="white">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg id="iconPause" viewBox="0 0 24 24" fill="white" style="display:none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </button>
                <button id="skipForwardBtn" class="audio-btn" title="+15 Sekunden" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z" />
                        <text x="12" y="15" text-anchor="middle" font-size="7" fill="white">15</text>
                    </svg>
                </button>
            </div>
            <div class="mode-btn-wrapper">
                <button id="bookBtn" class="audio-btn" title="Inhalt" tabindex="-1">
                    <!-- Resize Book Button by ~20% (scale 0.8 or smaller SVG) -->
                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" style="width: 20px; height: 20px;">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                </button>

                <button id="readingModeBtn" class="audio-btn" title="Lesemodus" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="gameModeBtn" class="audio-btn" title="Spielmodus" tabindex="-1">
                    <svg viewBox="0 0 24 24" fill="white">
                        <circle cx="6" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <circle cx="18" cy="12" r="4" fill="none" stroke="white" stroke-width="2" />
                        <path d="M10 12h4" stroke="white" stroke-width="2" />
                    </svg>
                </button>
                <button id="fullscreenBtn" class="audio-btn" title="Vollbild" tabindex="-1">
                    <!-- ENTER FULLSCREEN (Corners pointing OUT) -->
                    <svg id="iconFsEnter" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square">
                        <path d="M7 10V7h3" />
                        <path d="M17 10V7h-3" />
                        <path d="M17 14v3h-3" />
                        <path d="M7 14v3h3" />
                    </svg>
                    <!-- EXIT FULLSCREEN (Corners pointing IN) -->
                    <svg id="iconFsExit" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                        stroke-linecap="square" style="display:none;">
                        <path d="M4 14h6v6" />
                        <path d="M20 14h-6v6" />
                        <path d="M20 10h-6V4" />
                        <path d="M4 10h6V4" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- ARCHIVE MODAL (INHALT) -->
    <div id="archiveModal">
        <div class="archive-card">
            <div class="archive-header">
                <div class="archive-title">Inhalt</div>
                <button class="close-btn" id="closeArchiveBtn">&times;</button>
            </div>

            <div class="archive-content">
                <!-- LINKS: KAPITEL -->
                <div class="col-left" id="chapterList">
                    <div class="col-header">Kapitel</div>
                    <!-- Hardcoded Chapter 1 -->
                    <div class="menu-item" id="chapter1Btn">
                        <div class="item-main-text">Kapitel 1</div>
                        <div class="item-sub-text">Der Marktplatz</div>
                    </div>

                    <!-- Chapter 1b -->
                    <div class="menu-item" id="chapter1bBtn">
                        <div class="item-main-text">Kapitel 1b</div>
                        <div class="item-sub-text">Liminal Library</div>
                    </div>

                    <!-- Chapter 1c (Current) -->
                    <div class="menu-item active" id="chapter1cBtn">
                        <div class="item-main-text">Kapitel 1c</div>
                        <div class="item-sub-text">Steingasse (Hier)</div>
                    </div>
                </div>

                <!-- RECHTS: LORE -->
                <div class="col-right" id="loreList">
                    <div class="col-header">Lore</div>
                    <!-- Dynamisch gefüllt -->
                </div>
            </div>
            <!-- SAVE/LOAD FOOTER -->
            <div class="archive-footer"
                style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; display: flex; gap: 20px; justify-content: center;">
                <button id="btnSaveData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">SAVE
                    (Export)</button>
                <button id="btnLoadData"
                    style="font-family: inherit; color: white; cursor: pointer; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.1); transition: all 0.2s;">LOAD
                    (Import)</button>
                <input type="file" id="fileInputSave" style="display: none;" accept=".json">
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SETUP & FILTER LOGIK
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropZone = document.getElementById('dropZone');
        const controlsHint = document.getElementById('controlsHint');



        const processingInfo = document.getElementById('processingInfo');
        const gameWrapper = document.getElementById('gameWrapper');

        // PAL + CRT Effekte permanent aktiviert
        console.log("Applying Visual Fixes..."); // DEBUG
        gameWrapper.classList.add('effect-pal');
        gameWrapper.classList.add('effect-crt');

        // Turbulenz für Glitch laufend aktualisieren für "Randomness"
        // const turb = document.querySelector('#glitch-filter feTurbulence');
        // const disp = document.querySelector('#glitch-filter feDisplacementMap');

        // Glitch Loop: Manchmal stärker, manchmal schwächer
        // setInterval(() => {
        //     if (Math.random() > 0.95) {
        //         // Kurzer starker Glitch
        //         disp.setAttribute('scale', (Math.random() * 30 + 10).toString());
        //         turb.setAttribute('seed', Math.floor(Math.random() * 100).toString());
        //         setTimeout(() => {
        //             disp.setAttribute('scale', '4'); // Zurück zu subtil
        //         }, 100);
        //     }
        // }, 500);

        let gameReady = false;
        const SCENE_NAME = 'steingasse';
        let bgImage = null;
        let foregroundImage = null;
        let spriteReady = false;
        let collisionData = [];   // true = Wand
        let foregroundData = [];  // true = Vordergrund (verdeckt Spieler)
        let flowData = [];        // true = Magischer Fluss (Grün)
        let magentaPixels = [];
        let cyanPixels = new Set();
        let greenPixels = [];     // Zum Verstecken
        let yellowLights = [];    // Lore Lights (Global)
        let autoWalkPath = [];
        let autoWalkIndex = 0;
        // isReadingMode already exists in this file

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================
        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        // ============================================
        // LORE SYSTEM & VARIABLES
        // ============================================

        let GameState = null; // Will be loaded dynamically

        let mainAudioState = { time: 0, wasPlaying: false, tracks: [] };
        let activeLoreId = null;
        let activeLightSourceId = null;
        let isLoreMode = false;
        let isMenuTriggeredLore = false;
        let loreResumeTimeout = null;

        const loreData = {
            audio: {},
            text: {},
            resumeTimes: {}
        };

        // Initialize GameState
        (async function initGameState() {
            try {
                const module = await import('./assets/js/GameState.js');
                GameState = module.GameState;
                window.GameState = GameState; // Global Ref
                await GameState.init();
                console.log("[Kapitel1c] GameState Loaded & Initialized");

                // Populate loreData for compatibility (audio + text)
                const db = GameState.getAllLore();
                for (const [id, content] of Object.entries(db)) {
                    loreData.audio[id] = content.audio;
                    // Pre-fetch text for reliability
                    try {
                        const res = await fetch(content.text);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`[Init] Pre-loaded text for lore ${id}`);
                        }
                    } catch (e) {
                        console.warn(`[Init] Could not pre-load text for lore ${id}:`, e);
                    }
                }
            } catch (e) {
                console.error("Failed to load GameState:", e);
            }
        })();

        // kapitel1.mp3 als Haupt-Audio
        window.mainAudioUrl = 'assets/kapitel1.mp3';

        // Unlock Logic Wrapper
        async function unlockLoreItem(id) {
            if (!GameState) return;
            const newUnlock = await GameState.unlockLore(id);
            if (newUnlock) {
                const item = GameState.getLore(id);
                showNotification(`Eintrag freigeschaltet: ${item ? item.title : 'Unbekannt'}`);
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('controlsHint');
            if (el) {
                el.innerText = msg;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
        }

        // --- MENU LOGIC ---
        function renderArchive() {
            const list = document.getElementById('loreList');
            // Keep Header
            const header = list.querySelector('.col-header') || document.createElement('div');
            if (!list.querySelector('.col-header')) {
                header.className = 'col-header';
                header.innerText = 'Lore';
            }
            list.innerHTML = '';
            list.appendChild(header);

            if (!window.GameState) return;

            const db = window.GameState.getAllLore();
            const collectedIds = window.GameState.state.collectedLore;

            if (collectedIds.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'menu-item locked';
                empty.innerText = 'Keine Lore gefunden';
                list.appendChild(empty);
            } else {
                collectedIds.sort((a, b) => a - b).forEach(id => {
                    const content = db[id];
                    if (!content) return;

                    const item = document.createElement('div');
                    item.className = 'menu-item';

                    if (isLoreMode && activeLoreId === id) {
                        item.classList.add('active');
                    }

                    const mainText = document.createElement('div');
                    mainText.className = 'item-main-text';
                    mainText.innerText = content.title;

                    const subText = document.createElement('div');
                    subText.className = 'item-sub-text';
                    subText.innerText = content.duration;

                    item.appendChild(mainText);
                    item.appendChild(subText);

                    item.addEventListener('click', () => {
                        document.getElementById('archiveModal').classList.remove('visible');
                        startLoreMode(id, true);
                    });
                    list.appendChild(item);
                });
            }
            // (Chapter Logic continues inside renderArchive)

            // Chapter Logic (Left Column)
            const ch1 = document.getElementById('chapter1Btn');
            if (ch1) {
                const newCh1 = ch1.cloneNode(true);
                ch1.parentNode.replaceChild(newCh1, ch1);

                newCh1.addEventListener('click', () => {
                    console.log("Navigating to Chapter 1...");
                    window.location.href = 'index.html';
                });
            }

            // Chapter 1b Logic
            const ch1b = document.getElementById('chapter1bBtn');
            if (ch1b) {
                // Remove old listeners by cloning (if any exist spread from updates)
                const newCh1b = ch1b.cloneNode(true);
                ch1b.parentNode.replaceChild(newCh1b, ch1b);

                newCh1b.addEventListener('click', () => {
                    console.log("Loading Chapter 1b...");
                    window.location.href = 'liminal library.html';
                });
            }

            // Chapter 1c Logic (Current - Just close modal)
            const ch1c = document.getElementById('chapter1cBtn');
            if (ch1c) {
                const newCh1c = ch1c.cloneNode(true);
                ch1c.parentNode.replaceChild(newCh1c, ch1c);

                newCh1c.addEventListener('click', () => {
                    console.log("Already in Chapter 1c, closing modal...");
                    document.getElementById('archiveModal').classList.remove('visible');

                    // Resume audio if needed
                    if (isLoreMode) {
                        restoreMainAudio();
                    } else {
                        if (audioPlayer.paused) {
                            audioPlayer.play();
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        }
                    }
                });
            }
        }

        // LEGACY - DEACTIVATED
        // LEGACY REMOVED

        // EVENT LISTENERS FOR ARCHIVE
        document.getElementById('bookBtn').addEventListener('click', () => {
            renderArchive();
            document.getElementById('archiveModal').classList.add('visible');
        });

        document.getElementById('closeArchiveBtn').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('visible');
        });

        // SAVE / LOAD LOGIC
        const btnSave = document.getElementById('btnSaveData');
        const btnLoad = document.getElementById('btnLoadData');
        const fileInput = document.getElementById('fileInputSave');

        if (btnSave) {
            btnSave.addEventListener('click', () => {
                if (!window.GameState) return;
                const json = window.GameState.exportState();
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'liminal_save_' + Date.now() + '.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        if (btnLoad) {
            btnLoad.addEventListener('click', () => {
                if (fileInput) fileInput.click();
            });
        }

        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    if (window.GameState) {
                        const success = await window.GameState.importState(ev.target.result);
                        if (success) {
                            alert("Save Data Imported Successfully! Reloading...");
                            window.location.reload();
                        } else {
                            alert("Invalid Save File.");
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        // YellowLight Klasse für visualisierte Lore-Trigger
        class YellowLight {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.seed = Math.random() * 100;
                this.activeFactor = 0; // 0.0 bis 1.0 (Soft Transition Status)

                // Init State: Check if already collected on load
                this.vanished = false;
                if (window.GameState && window.GameState.isLightCollected(SCENE_NAME, this.id)) {
                    this.vanished = true;
                }
                this.animPhase = 0; // 0=None, 1=Grow, 2=Shrink
                this.animScale = 1.0;
            }

            draw(ctx) {
                if (this.vanished) return;

                // Check for collection event (Start Animation)
                if (this.animPhase === 0 && window.GameState && window.GameState.isLightCollected(SCENE_NAME, this.id)) {
                    this.animPhase = 1;
                }

                // ANIMATION UPDATE
                if (this.animPhase > 0) {
                    // Grow Phase
                    if (this.animPhase === 1) {
                        this.animScale += 0.05; // speed
                        if (this.animScale >= 1.5) { // Max scale
                            this.animPhase = 2;
                        }
                    }
                    // Shrink Phase
                    else if (this.animPhase === 2) {
                        this.animScale -= 0.05;
                        if (this.animScale <= 0) {
                            this.vanished = true;
                            return;
                        }
                    }
                }

                const time = Date.now() / 1000;
                const swayX = Math.sin(time + this.seed) * 1.5;
                const swayY = Math.cos(time * 1.2 + this.seed) * 1.5;
                const isActive = (isLoreMode && this.id === activeLightSourceId);

                // Smooth Animation für Zustandswechsel
                const targetFactor = isActive ? 1.0 : 0.0;
                this.activeFactor += (targetFactor - this.activeFactor) * 0.02;

                const currentBaseRadius = 10 + this.activeFactor * 15;
                const pulseAmp = 2 + this.activeFactor * 2; // Pulsieren

                // Calculate Radius with Animation Scale
                let radius = (currentBaseRadius + Math.sin(time * 3 + this.seed) * pulseAmp) * this.animScale;
                if (radius < 0) radius = 0;

                // Calculate Alpha
                let alpha = (0.7 + Math.sin(time * 2 + this.seed) * 0.2);
                if (this.animPhase === 2) alpha *= (this.animScale / 1.5); // Fade out during shrink

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                const grad = ctx.createRadialGradient(this.x + swayX, this.y + swayY, 0, this.x + swayX, this.y + swayY, radius);

                grad.addColorStop(0, `rgba(255, 255, 240, ${alpha})`);
                grad.addColorStop(0.6, `rgba(255, 240, 100, ${alpha * 0.6})`);
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x + swayX, this.y + swayY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Click-to-Move für Mobile
        let moveTarget = null; // {x, y} oder null

        // ============================================
        // PARTIKEL SYSTEM
        // ============================================
        const particles = [];
        const NUM_PARTICLES = 300; // Reduziert um 50%
        let particleSprite = null;

        // Spotlight-System: Sammelt Lichtquellen mit Richtung und Intensität
        let nearbyLights = []; // {x, y, intensity}

        // Dust-Particles: Staubwolken beim Laufen
        const dustParticles = [];

        // Screen-Shake bei Kollision
        let screenShake = 0;

        // Wolken-System (Parallax, selten)
        const clouds = [];
        const MAX_CLOUDS = 3;
        let cloudSpawnTimer = 0;

        class Cloud {
            constructor(startX, startY) {
                // WELT-Koordinaten - Wolken sind an der KARTE fixiert
                this.x = startX !== undefined ? startX : mapW + 100;
                this.y = startY !== undefined ? startY : Math.random() * mapH;
                this.speed = 0.15 + Math.random() * 0.1; // Langsame Drift über Karte
                this.size = 100 + Math.random() * 150;
                this.alpha = 0.5;
            }
            update() {
                this.x -= this.speed;
                // Wrap: links raus -> rechts wieder rein
                if (this.x < -this.size * 2) {
                    this.x = mapW + this.size;
                    this.y = Math.random() * mapH;
                }
            }
            draw(ctx, camX, camY) {
                // WELT-Koordinaten - ctx ist bereits mit Kamera translated
                // KEIN setTransform Reset! Dadurch bewegen sich Wolken mit Karte
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.filter = 'blur(25px)';
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Wolken initialisieren - gleichmäßig über KARTE verteilt
        function initClouds() {
            clouds.length = 0;
            if (mapW <= 0 || mapH <= 0) return;

            // Wolken verteilt über die Kartenfläche
            const numClouds = Math.max(3, Math.floor((mapW * mapH) / 150000));
            for (let i = 0; i < numClouds; i++) {
                const x = Math.random() * mapW;
                const y = Math.random() * mapH;
                clouds.push(new Cloud(x, y));
            }
            console.log("Clouds initialized:", clouds.length, "for map", mapW, "x", mapH);
        }

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        const footstepSound = new Audio('assets/footsteps.mp3');
        footstepSound.volume = 0.25;
        footstepSound.loop = true;

        const shimmerSound = new Audio('assets/shimmer.mp3');
        shimmerSound.volume = 0.4; // Angenehme Lautstärke
        let lastShimmerLightId = null; // Speichert ID des zuletzt vertonten Lichts
        let footstepPlaying = false;

        // Fallback: Manueller Loop falls Browser-Loop nicht funktioniert
        footstepSound.addEventListener('ended', () => {
            if (footstepPlaying) {
                footstepSound.currentTime = 0;
                footstepSound.play().catch(() => { });
            }
        });

        let audioUnlocked = false;

        // Ambient-Sound (permanent)
        const ambientSound = new Audio('assets/medieval_town.mp3');
        ambientSound.loop = true;
        ambientSound.volume = 0.06; // +45% louder

        // Fallback: Manueller Loop für Ambient
        ambientSound.addEventListener('ended', () => {
            ambientSound.currentTime = 0;
            ambientSound.play().catch(() => { });
        });

        // Audio entsperren bei erstem User-Input
        function unlockAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;
            // Starte Ambient-Sound
            ambientSound.play().catch(() => { });
        }
        document.addEventListener('click', unlockAudio, { once: true });
        document.addEventListener('keydown', unlockAudio, { once: true });
        document.addEventListener('touchstart', unlockAudio, { once: true });

        // Periodisch Ambient neu starten falls gestoppt
        setInterval(() => {
            if (audioUnlocked && ambientSound.paused) {
                ambientSound.play().catch(() => { });
            }
        }, 3000);

        function createGlowSprite() {
            const size = 64;
            const half = size / 2;
            const c = document.createElement('canvas');
            c.width = size;
            c.height = size;
            const ctx = c.getContext('2d');

            const grad = ctx.createRadialGradient(half, half, 2, half, half, half);
            // Sehr subtiler Nebel
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.1)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);

            return c;
        }

        class Particle {
            constructor(startX, startY) {
                this.sizeMod = 0.5 + Math.random() * 1.5;
                this.resetVelocity();
                if (startX !== undefined && startY !== undefined) {
                    this.x = startX;
                    this.y = startY;
                } else {
                    this.reset();
                }
            }

            resetVelocity() {
                // Etwas langsamer
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.2 + Math.random() * 0.4;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.life = Math.random();
                this.pulseSpeed = 0.01 + Math.random() * 0.02;
                this.maxLife = 0.5 + Math.random() * 0.5;
                this.onFlow = false;
            }

            resetTo(x, y) {
                this.x = x;
                this.y = y;
                this.resetVelocity();
            }

            reset() {
                if (greenPixels.length > 0) {
                    // Versuche bis zu 10 mal eine gültige Position zu finden
                    for (let attempt = 0; attempt < 10; attempt++) {
                        const idx = Math.floor(Math.random() * greenPixels.length);
                        const gp = greenPixels[idx];

                        // Jitter NUR wenn kein Wall
                        let testX = gp.x + (Math.random() - 0.5) * 8;
                        let testY = gp.y + (Math.random() - 0.5) * 8;

                        const ix = Math.floor(testX), iy = Math.floor(testY);

                        // Prüfe ob Position NICHT in Wand ist
                        if (ix >= 0 && ix < mapW && iy >= 0 && iy < mapH) {
                            if (!collisionData[iy][ix]) {
                                this.resetTo(testX, testY);
                                return;
                            }
                        }
                    }
                    // Fallback: Exakt auf grünem Pixel (ohne Jitter)
                    const gp = greenPixels[Math.floor(Math.random() * greenPixels.length)];
                    this.resetTo(gp.x, gp.y);
                } else {
                    this.x = Math.random() * mapW;
                    this.y = Math.random() * mapH;
                    this.resetVelocity();
                }
            }

            update() {
                // SOFORTIGER WALL-CHECK: Bin ich in/nahe einer Wand? -> Reset!
                const myX = Math.floor(this.x), myY = Math.floor(this.y);
                const wallCheckR = 2;
                let inWall = false;
                for (let cy = -wallCheckR; cy <= wallCheckR && !inWall; cy++) {
                    for (let cx = -wallCheckR; cx <= wallCheckR && !inWall; cx++) {
                        const checkX = myX + cx, checkY = myY + cy;
                        if (checkX >= 0 && checkX < mapW && checkY >= 0 && checkY < mapH) {
                            if (collisionData[checkY][checkX]) {
                                inWall = true;
                            }
                        }
                    }
                }
                if (inWall) {
                    this.reset();
                    return;
                }

                // 1. Mehr Chaos & Torkeln (Abweichung) - DOUBLED
                this.vx += (Math.random() - 0.5) * 0.4;
                this.vy += (Math.random() - 0.5) * 0.4;

                // 2. Flow-Movement (Sanftes Schweben entlang der grünen Zonen)
                // Statt hartem "Zurückziehen" lassen wir sie driften.
                // Prüfe, ob wir "nah" an Grün sind (größerer Radius)
                let nearFlow = false;
                const lookAhead = 10; // Weit vorausschauen

                // Wir nutzen scanForFlow, aber nutzen das Ergebnis sanfter
                const flowDir = this.scanForFlow(20); // Suchradius erhöht

                if (flowDir) {
                    // Wir sind in der Nähe von Grün -> Sanfter Drift in diese Richtung
                    // Aber wir lassen viel Randomness zu (aus Schritt 1)
                    this.vx += flowDir.x * 0.02; // SEHR sanfter Zug (war 0.08)
                    this.vy += flowDir.y * 0.02;
                    nearFlow = true;
                } else {
                    // Weit weg von Grün davon schweben lassen
                }

                // ==========================================
                // NEU: MAGNETISCHE ANZIEHUNG (User Request)
                // ==========================================
                // Soll wirken wie ein Magnet an einer Schnur.
                // Schnur = Flow Logic (zieht zurück), Magnet = Player Logic (zieht hin).

                // Center on Player Sprite (approximation)
                const pCenterX = player.x + 8;
                const pCenterY = player.y + 10;

                const dx = pCenterX - this.x;
                const dy = pCenterY - this.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                const magnetRange = 200;

                if (distToPlayer < magnetRange) {
                    // Quadratische Zunahme der Kraft: Je näher, desto stärker
                    // 0 am Rand (200px), 1.0 bei 0px
                    const urgency = Math.pow((magnetRange - distToPlayer) / magnetRange, 2);

                    // Stärke des Magneten.
                    // Muss gegen die Randomness (0.4) und Flow (0.02) ankommen, aber nicht teleportieren.
                    const pullStrength = 1.0 * urgency;

                    this.vx += (dx / distToPlayer) * pullStrength;
                    this.vy += (dy / distToPlayer) * pullStrength;
                }
                // ==========================================

                // 3. Speed Limit (50% langsamer)
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxSpeed = 0.375; // 50% langsamer
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                // 3b. Kollision mit anderen Partikeln (Abstoßung)
                const collisionRadius = 8; // Größe wie Männchen-Kopf
                for (const other of particles) {
                    if (other === this) continue;
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = collisionRadius * 2;

                    if (distSq < minDist * minDist && distSq > 0) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        // Normalisierte Richtung weg vom anderen
                        const nx = dx / dist;
                        const ny = dy / dist;
                        // Abstoßung proportional zur Überlappung
                        this.vx += nx * overlap * 0.1;
                        this.vy += ny * overlap * 0.1;
                    }
                }

                // 4. Kollision mit Wänden - DICKERE PRÜFUNG (3x3 Bereich)
                const nextX = this.x + this.vx;
                const nextY = this.y + this.vy;

                let hitWall = false;
                // Prüfe 3x3 Bereich um die nächste Position
                const checkRadius = 2;
                for (let checkY = -checkRadius; checkY <= checkRadius && !hitWall; checkY++) {
                    for (let checkX = -checkRadius; checkX <= checkRadius && !hitWall; checkX++) {
                        const ix = Math.floor(nextX + checkX);
                        const iy = Math.floor(nextY + checkY);
                        if (ix >= 0 && ix < mapW && iy >= 0 && iy < mapH) {
                            if (collisionData[iy][ix]) {
                                hitWall = true;
                            }
                        }
                    }
                }

                if (hitWall) {
                    // Abprallen
                    this.vx *= -0.5;
                    this.vy *= -0.5;
                    this.vx += (Math.random() - 0.5) * 0.3;
                    this.vy += (Math.random() - 0.5) * 0.3;
                } else {
                    this.x = nextX;
                    this.y = nextY;
                }

                // 5. Spieler Beleuchtung - Sammle nur NAHE Lichtquellen
                if (typeof player !== 'undefined') {
                    const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
                    const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
                    const visualShiftY = Math.floor(refH / 3) - 4;

                    // Zentrum des gerenderten Sprites (Präzise Mitte der Bounding Box)
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = this.x - px;
                    const ddy = this.y - py;
                    const distSq = ddx * ddx + ddy * ddy;

                    // Radius = ca 65px (4225 squared) für sehr großzügige Erfassung
                    if (distSq < 4225) {
                        const dist = Math.sqrt(distSq);
                        nearbyLights.push({
                            x: this.x,
                            y: this.y,
                            dist: dist,
                            life: this.life
                        });
                    }
                }

                // Lifecycle
                this.life += this.pulseSpeed;
                if (this.life > this.maxLife || this.life < 0.1) this.pulseSpeed *= -1;

                // Out of Bounds Reset
                if (this.x < -50 || this.x > mapW + 50 || this.y < -50 || this.y > mapH + 50) {
                    this.reset();
                }
            }

            isOnFlow(x, y) {
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                const r = 4;

                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        const cx = ix + dx, cy = iy + dy;
                        if (cx >= 0 && cx < mapW && cy >= 0 && cy < mapH) {
                            if (flowData[cy][cx]) return true;
                        }
                    }
                }
                return false;
            }

            scanForFlow() {
                const angles = [-0.5, 0.5, -1.0, 1.0, -1.5, 1.5];
                const currentAngle = Math.atan2(this.vy, this.vx);
                const scanDist = 10;

                for (let a of angles) {
                    const checkAngle = currentAngle + a;
                    const dx = Math.cos(checkAngle);
                    const dy = Math.sin(checkAngle);
                    const cx = this.x + dx * scanDist;
                    const cy = this.y + dy * scanDist;

                    if (this.isOnFlow(cx, cy)) {
                        return { x: dx, y: dy };
                    }
                }
                return null;
            }

            draw(ctx, camX, camY) {
                const drawSize = 64 * this.sizeMod;

                // Culling (Screen Check)
                const sx = this.x - camX;
                const sy = this.y - camY;

                if (sx < -drawSize || sx > SCREEN_W + drawSize || sy < -drawSize || sy > SCREEN_H + drawSize) return;

                const alpha = Math.max(0, Math.min(1, this.life));

                // Partikel-Schatten (sanft nach unten)
                ctx.globalAlpha = alpha * 0.12;
                ctx.drawImage(particleSprite,
                    this.x - drawSize / 2 + 3,
                    this.y - drawSize / 2 + drawSize * 0.35,
                    drawSize, drawSize * 0.35);

                // Partikel selbst
                ctx.globalAlpha = alpha;
                ctx.drawImage(particleSprite, this.x - drawSize / 2, this.y - drawSize / 2, drawSize, drawSize);
                ctx.globalAlpha = 1.0;
            }
        }

        function initParticles() {
            if (!particleSprite) particleSprite = createGlowSprite();

            particles.length = 0;
            if (greenPixels.length > 0) {
                for (let i = 0; i < 60; i++) { // User Request: 60 Particles
                    // Versuche gültige Position zu finden
                    let startX, startY;
                    let found = false;

                    for (let attempt = 0; attempt < 5; attempt++) {
                        const idx = Math.floor(Math.random() * greenPixels.length);
                        const gp = greenPixels[idx];

                        startX = gp.x + (Math.random() - 0.5) * 8;
                        startY = gp.y + (Math.random() - 0.5) * 8;

                        const ix = Math.floor(startX), iy = Math.floor(startY);
                        if (ix >= 0 && ix < mapW && iy >= 0 && iy < mapH) {
                            if (!collisionData[iy][ix]) {
                                found = true;
                                break;
                            }
                        }
                    }

                    // Fallback: Exakt auf grünem Pixel
                    if (!found) {
                        const gp = greenPixels[Math.floor(Math.random() * greenPixels.length)];
                        startX = gp.x;
                        startY = gp.y;
                    }

                    particles.push(new Particle(startX, startY));
                }
            } else {
                for (let i = 0; i < 60; i++) particles.push(new Particle()); // User Request: 60 Particles
            }
        }

        // ============================================
        // LORE PERSISTENCE HELPER
        // ============================================
        const LoreSystem = {
            key: 'liminal_save',
            state: {
                collectedLore: [],
                collectedLights: {}
            },

            load() {
                try {
                    const raw = localStorage.getItem(this.key);
                    if (raw) {
                        this.state = JSON.parse(raw);
                        console.log("[LoreSystem] Loaded:", this.state);
                    }
                } catch (e) { console.warn("Lore Load Error:", e); }
            },

            save() {
                try {
                    localStorage.setItem(this.key, JSON.stringify(this.state));
                    // console.log("[LoreSystem] Saved:", this.state);
                } catch (e) { console.warn("Lore Save Error:", e); }
            },

            unlock(id) {
                id = parseInt(id);
                if (!this.state.collectedLore.includes(id)) {
                    this.state.collectedLore.push(id);
                    this.save();
                    return true;
                }
                return false;
            },

            isUnlocked(id) {
                return this.state.collectedLore.includes(parseInt(id));
            }
        };

        LoreSystem.load();

        let mapW = 0, mapH = 0;

        // Dynamische Auflösung
        let SCREEN_W = 320;
        let SCREEN_H = 240;

        function updateDimensions() {
            // Robust Responsive Logic
            // Aim for maintaining pixel density while filling the screen.
            // Base resolution reference: 320x240 (4:3)

            const targetRatio = 320 / 240; // 1.333
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const winRatio = winW / winH;

            if (winRatio > targetRatio) {
                // Window is wider than 4:3 (Landscape / Wide)
                // Fix Height at 240, expand Width
                SCREEN_H = 240;
                SCREEN_W = Math.ceil(SCREEN_H * winRatio);
            } else {
                // Window is taller/narrower than 4:3 (Portrait / Square)
                // Fix Width at 320, expand Height
                SCREEN_W = 320;
                SCREEN_H = Math.ceil(SCREEN_W / winRatio);
            }

            // Canvas Größe aktualisieren
            if (canvas) {
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;
            }
            console.log(`Resolution updated: ${SCREEN_W}x${SCREEN_H} (Win: ${winW}x${winH}, Ratio: ${winRatio.toFixed(2)})`);
        }

        // Initial und bei Resize
        // Initial resize
        updateDimensions(); // Keep the original initial call
        window.addEventListener('resize', () => { // Keep the original resize listener
            updateDimensions();
            // Auch Subtitles neu rendern falls nötig
            if (isReadingMode && subtitleTracks.length > 0) {
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // --- VISUAL CALIBRATION TOOL ---
        let params = {
            brightness: 1.15,
            contrast: 1.10,
            saturate: 0.85
        };
        let activeParam = 'brightness';

        const dispBrit = document.getElementById('dispBrit');
        const dispCont = document.getElementById('dispCont');
        const dispSat = document.getElementById('dispSat');
        const dispSel = document.getElementById('dispSel');
        const debugCanvas = document.getElementById('gameCanvas');

        window.addEventListener('keydown', (e) => {
            // Select Parameter
            if (e.key === '1') { activeParam = 'brightness'; dispSel.innerText = 'Brightness'; }
            if (e.key === '2') { activeParam = 'contrast'; dispSel.innerText = 'Contrast'; }
            if (e.key === '3') { activeParam = 'saturate'; dispSel.innerText = 'Saturation'; }

            // Adjust
            if (e.key === '+' || e.key === 'Add' || e.key === '=') {
                params[activeParam] = Math.round((params[activeParam] + 0.05) * 100) / 100;
                updateVisuals();
            } else if (e.key === '-' || e.key === 'Subtract' || e.key === '_') {
                params[activeParam] = Math.round((params[activeParam] - 0.05) * 100) / 100;
                updateVisuals();
            }
        });

        function updateVisuals() {
            // Apply override to canvas
            // Standard PAL structure
            debugCanvas.style.filter = `url(#pal-filter) contrast(${params.contrast}) brightness(${params.brightness}) saturate(${params.saturate})`;

            dispBrit.innerText = params.brightness.toFixed(2);
            dispCont.innerText = params.contrast.toFixed(2);
            dispSat.innerText = params.saturate.toFixed(2);

            console.log(`Params: B=${params.brightness}, C=${params.contrast}, S=${params.saturate}`);
        }
        // Initialize with default values once to ensure UI matches
        // updateVisuals();
        // End of VISUAL CALIBRATION TOOL

        let camX = 0, camY = 0;
        let targetCamX = 0, targetCamY = 0;

        // Sprite Sheet Konfiguration
        const SPRITE = {
            frameWidth: 0,   // Wird berechnet
            frameHeight: 0,  // Wird berechnet
            cols: 4,         // 4 Frames pro Reihe
            baseScale: 0.15, // Original Skalierung
            scale: 0.15      // Dynamische Skalierung
        };

        // Spieler
        const player = {
            x: 50, y: 50,
            w: 14, h: 8,      // Kollisionsbox (Füße)
            speed: 35,        // Pixels per second (unified with index.html)
            dir: 0,           // 0=down, 1=up, 2=left, 3=right
            frame: 0,         // 0-3 für Animation
            animTimer: 0,
            isMoving: false,
            isBehindForeground: false
        };

        const keys = {};

        // ============================================
        // SPRITES LADEN (alle 4 Richtungen)
        // ============================================
        let spriteFront = null;   // Frontalansicht (down)
        let spriteBack = null;    // Rückenansicht (up)
        let spriteSide = null;    // Seitenansicht (right, links wird gespiegelt)
        let spritesLoaded = 0;
        const TOTAL_SPRITES = 3;

        function loadAllSprites() {
            // Frontal (nach unten schauend, NEU: spriteneu.png)
            spriteFront = new Image();
            spriteFront.onload = function () {
                // WICHTIG: Math.floor() für ganzzahlige Frame-Breite!
                SPRITE.frameWidth = Math.floor(this.width / SPRITE.cols); // Fallback-Wert, wird für DrawCoords überschrieben
                SPRITE.frameHeight = this.height;
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log(`Sprite Front (New) geladen: ${this.width}x${this.height}`);
            };
            spriteFront.src = 'assets/spriteneu.png';
            spriteFront.onerror = () => console.warn('assets/spriteneu.png nicht gefunden');

            // Rücken (nach oben schauend, NEU: spriterueckenneu.png)
            spriteBack = new Image();
            spriteBack.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Back (New) geladen');
            };
            spriteBack.src = 'assets/spriterueckenneu.png';
            spriteBack.onerror = () => console.warn('assets/spriterueckenneu.png nicht gefunden');

            // Seitlich (für rechts, links wird gespiegelt)
            spriteSide = new Image();
            spriteSide.onload = function () {
                spritesLoaded++;
                checkAllSpritesLoaded();
                console.log('Sprite Side (New) geladen');
            };
            spriteSide.src = 'assets/seitlichneu.png';
            spriteSide.onerror = () => console.warn('assets/seitlichneu.png nicht gefunden');
        }

        // Front (spriteneu.png)
        const FRONT_SPRITE_DATA = [
            { left: 38, width: 141, footX: 106, footY: 267 },
            { left: 201, width: 138, footX: 273, footY: 265 },
            { left: 361, width: 140, footX: 436, footY: 270 },
            { left: 534, width: 137, footX: 604, footY: 268 }
        ];
        // Ping-Pong Animation für Front (0-1-2-3-2-1)
        const FRONT_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        // Back (spriterueckenneu.png)
        const BACK_SPRITE_DATA = [
            { left: 16, width: 147, footX: 90, footY: 282 },
            { left: 177, width: 144, footX: 253, footY: 283 },
            { left: 336, width: 152, footX: 417, footY: 285 }
        ];
        // Ping-Pong Animation für Back (0-1-2-1)
        const BACK_ANIM_CYCLE = [0, 1, 2, 1];

        // NEU: Marker-Daten für seitlichneu.png (X, Y)
        const SIDE_SPRITE_DATA = [
            { left: 20, footX: 92, footY: 275 },
            { left: 200, footX: 268, footY: 281 },
            { left: 372, footX: 440, footY: 280 },
            { left: 528, footX: 595, footY: 284 }
        ];

        // Ping-Pong Animation für Seitlich (0-1-2-3-2-1)
        const SIDE_ANIM_CYCLE = [0, 1, 2, 3, 2, 1];

        function checkAllSpritesLoaded() {
            if (spritesLoaded >= TOTAL_SPRITES) {
                spriteReady = true;
                console.log('Alle Sprites geladen!');
            }
        }

        loadAllSprites();

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // GLOBAL ERROR HANDLER (DEBUG)
        // ============================================
        window.onerror = function (msg, url, line, col, error) {
            const pi = document.getElementById('processingInfo');
            if (pi) {
                pi.style.display = 'block';
                pi.style.color = '#ff5555';
                pi.style.background = 'rgba(0,0,0,0.9)';
                pi.innerText += "\nERROR: " + msg + "\nLine: " + line;
            }
            console.error(msg, error);
            return false;
        };

        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        // ============================================
        // ELECTRON AUTO-LOAD
        // ============================================
        window.addEventListener('DOMContentLoaded', async () => {
            console.log("Electron Mode: Auto-Loading...");

            // RESTORE READING MODE STATE
            const savedMode = localStorage.getItem('gameboy_reading_mode');
            if (savedMode === 'true') {
                isReadingMode = true;
                const ui = document.getElementById('audioPlayerUI');
                if (ui) ui.classList.add('reading-mode');
            }

            // FALLBACK: Hide DropZone after 3 seconds if map fails
            setTimeout(() => {
                const dz = document.getElementById('dropZone');
                const pi = document.getElementById('processingInfo');
                if (dz && !dz.classList.contains('hidden')) {
                    console.warn("Force hiding DropZone due to timeout!");
                    dz.classList.add('hidden');
                }
                if (pi) pi.style.display = 'none';
                // Force Start Loop if not ready
                if (!gameReady) {
                    console.warn("Force starting game loop!");
                    gameReady = true;
                    // Ensure Canvas Size
                    const c = document.getElementById('gameCanvas');
                    c.width = window.innerWidth;
                    c.height = window.innerHeight;
                    startGameLoop();
                }
            }, 3000);

            // 1. Load Map (Default)
            const mapImg = new Image();
            mapImg.src = 'assets/kapitel1c.png';
            mapImg.onload = () => {
                console.log("Map Loaded, processing...");
                try {
                    processMap(mapImg);
                } catch (e) {
                    console.error("Critical: processMap crashed!", e);
                }
            };
            mapImg.onerror = (e) => {
                console.error("Map Load Error", e);
                // Try alternate path for debugging
            };

            // 2. Load Audio & Text (Chapter 1c) -> Default Main Audio
            const mainAudioSrc = 'assets/kapitel1c.mp3';
            audioPlayer.src = mainAudioSrc;
            window.mainAudioUrl = mainAudioSrc;

            try {
                const response = await fetch('assets/kapitel1c.txt');
                const text = await response.text();
                window.mainTextContent = text;
                parseSubtitles(text);
                renderSubtitleLines(0);
                console.log("Chapter 1c Loaded");
            } catch (e) {
                console.error("Chapter 1c Load Error:", e);
                window.mainTextContent = "";
                subtitleTracks = [];
            }

            // 2b. Preload Lore 1 Text
            try {
                const lRes = await fetch('assets/lore1.txt');
                loreData.text[1] = await lRes.text();
                console.log("Lore 1 Loaded");
            } catch (e) {
                console.error("Lore 1 Text Load Error:", e);
                loreData.text[1] = "";
            }

            // Always show UI
            if (typeof uiContainer !== 'undefined' && uiContainer) uiContainer.style.display = 'flex';

            // 3. Load Save Game
            // Handled by generic GameState.init() called at top of script
            // if (window.electronAPI) { ... }
        });

        // Helper for manual image loading (optional debugging)
        function loadImageFile(file) {
            processingInfo.style.display = 'block';
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => setTimeout(() => processMap(img), 50);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ============================================
        // KEYBOARD
        // ============================================
        window.addEventListener('keydown', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
                // CRITICAL FIX: Ensure Audio Player NEVER has focus, preventing "fast forward"
                if (audioPlayer) audioPlayer.blur();
                document.body.focus();
            }
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
            // Tastendruck bricht Click-to-Move ab
            moveTarget = null;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;
        });

        // Click-to-Move für Mobile
        function handleClickMove(screenX, screenY) {
            if (!gameReady) return;

            // Berechne Welt-Koordinaten aus Screen-Koordinaten
            const rect = canvas.getBoundingClientRect();
            // CSS-Pixel zu Canvas-Pixel Umrechnung
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (screenX - rect.left) * scaleX;
            const canvasY = (screenY - rect.top) * scaleY;

            // Welt-Position = Canvas-Position + Kamera-Offset
            const worldX = canvasX + camX;
            const worldY = canvasY + camY;

            // Setze Ziel (Spieler-Mitte soll dort hin)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            moveTarget = {
                x: worldX - spriteW / 2,
                y: worldY - spriteH / 2
            };
        }

        canvas.addEventListener('click', e => {
            handleClickMove(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (e.touches.length > 0) {
                handleClickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        // ============================================
        // MAP PROCESSING
        // ============================================
        // ============================================
        // MAP PROCESSING (NUCLEAR FALLBACK VERSION)
        // ============================================
        // ============================================
        // MAP PROCESSING (ADVANCED RESTORED)
        // ============================================
        function processMap(img) {
            console.log("Processing Map (Advanced):", img.width, "x", img.height);
            mapW = img.width;
            mapH = img.height;

            SCREEN_W = Math.min(mapW, window.innerWidth);
            SCREEN_H = Math.min(mapH, window.innerHeight);
            canvas.width = SCREEN_W;
            canvas.height = SCREEN_H;

            // VISUAL DEBUG
            const pi = document.getElementById('processingInfo');

            // --- AUTO-WALK PATH SORTER (Pure Nearest Neighbor) ---
            // Immer den ALLERNÄCHSTEN Pixel. Keine Bereiche, keine Schwellen.
            function sortAutoWalkPath(pixels, startPoint) {
                if (pixels.length === 0) return [];

                const path = [];
                let pool = [...pixels];

                // 1. Startpunkt: Der Pixel, der am nächsten zum Spawn liegt.
                let minDistSq = Infinity;
                let startIndex = -1;

                for (let i = 0; i < pool.length; i++) {
                    const dx = pool[i].x - startPoint.x;
                    const dy = pool[i].y - startPoint.y;
                    const dSq = dx * dx + dy * dy;
                    if (dSq < minDistSq) {
                        minDistSq = dSq;
                        startIndex = i;
                    }
                }

                if (startIndex === -1) return [];

                let current = pool.splice(startIndex, 1)[0];
                path.push(current);

                // 2. Stur: Immer den ALLERNÄCHSTEN noch nicht besuchten Pixel wählen.
                while (pool.length > 0) {
                    let bestIndex = -1;
                    let bestDistSq = Infinity;

                    for (let i = 0; i < pool.length; i++) {
                        const dx = pool[i].x - current.x;
                        const dy = pool[i].y - current.y;
                        const dSq = dx * dx + dy * dy;

                        if (dSq < bestDistSq) {
                            bestDistSq = dSq;
                            bestIndex = i;
                        }
                    }

                    // Immer nehmen, egal wie weit weg.
                    if (bestIndex !== -1) {
                        current = pool.splice(bestIndex, 1)[0];
                        path.push(current);
                    } else {
                        break;
                    }
                }
                return path;
            }
            if (pi) {
                pi.innerText = "PROCESSING PIXELS...";
                pi.style.display = 'block';
            }

            // ATTEMPT PIXEL PROCESSING
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapW;
                tempCanvas.height = mapH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imgData = tempCtx.getImageData(0, 0, mapW, mapH);
                const data = imgData.data;

                // 1. Initialisieren der Arrays
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                foregroundData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));
                flowData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false));

                magentaPixels = [];
                cyanPixels = new Set();
                greenPixels = [];
                let orangePixels = []; // For Auto-Walk
                yellowLights = []; // Init global var
                let spawnPixel = null;

                // 2. Scan-Pass
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        const i = (y * mapW + x) * 4;
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Magenta = Kollision
                        if (r > 200 && g < 80 && b > 200) {
                            collisionData[y][x] = true;
                            magentaPixels.push({ x, y, i });
                        }
                        // Cyan = Vordergrund
                        else if (r < 80 && g > 200 && b > 200) {
                            cyanPixels.add(`${x},${y}`);
                        }
                        // Grün = Flow (Lichter)
                        else if (r < 80 && g > 200 && b < 80) {
                            flowData[y][x] = true;
                            greenPixels.push({ x, y, i });
                        }
                        // GELB = Lore Trigger (#FFFF00)
                        else if (r > 250 && g > 250 && b < 10) {
                            const id = yellowLights.length + 1;
                            yellowLights.push(new YellowLight(x, y, id));
                        }
                        // BLAU = Spawn Punkt (#0000FF)
                        else if (r < 50 && g < 50 && b > 200) {
                            console.log(`Blue Pixel found at ${x},${y}: RGB(${r},${g},${b})`);
                            if (!spawnPixel) {
                                spawnPixel = { x, y, i };
                                console.log("Spawn Pixel SET at", x, y);
                            }
                        }
                        // ORANGE = Auto-Walk Pfad (#FFA500 -> R>240, G~165, B<50)
                        else if (r > 240 && g > 130 && g < 200 && b < 50) {
                            orangePixels.push({ x, y, i });
                        }
                    }
                }

                // 3. Flood Fill Cyan
                if (cyanPixels.size > 0) findEnclosedAreas(cyanPixels, mapW, mapH);

                // 4. Pixel Hiding (Flow, Lore, Spawn)
                // Use pullNearbyPixel to hide the debug colors
                for (const gp of greenPixels) {
                    const repl = pullNearbyPixel(data, gp.x, gp.y, mapW, mapH, cyanPixels);
                    data[gp.i] = repl.r; data[gp.i + 1] = repl.g; data[gp.i + 2] = repl.b;
                }
                for (const yl of yellowLights) {
                    const i = (yl.y * mapW + yl.x) * 4;
                    const repl = pullNearbyPixel(data, yl.x, yl.y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }
                if (spawnPixel) {
                    const repl = pullNearbyPixel(data, spawnPixel.x, spawnPixel.y, mapW, mapH, cyanPixels);
                    data[spawnPixel.i] = repl.r; data[spawnPixel.i + 1] = repl.g; data[spawnPixel.i + 2] = repl.b;
                }

                // 4b. Process Auto-Walk Path
                if (orangePixels.length > 0) {
                    const startRef = spawnPixel || { x: mapW / 2, y: mapH / 2 };

                    // Direct Sort (Strict 1px - Pure Nearest Neighbor)
                    autoWalkPath = sortAutoWalkPath(orangePixels, startRef);
                    autoWalkIndex = 0;

                    // Hide Orange Pixels
                    for (const op of orangePixels) {
                        const repl = pullNearbyPixel(data, op.x, op.y, mapW, mapH, cyanPixels);
                        data[op.i] = repl.r; data[op.i + 1] = repl.g; data[op.i + 2] = repl.b;
                    }
                }

                // 5. Magenta Cleanup & Wall Dilatation (Robust Collision)
                // First, collect all collision pixels to avoid cascading growth during iteration
                const extraWalls = [];
                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (collisionData[y][x]) {
                            // Add neighbors to be solidified
                            if (x > 0) extraWalls.push({ x: x - 1, y: y });
                            if (x < mapW - 1) extraWalls.push({ x: x + 1, y: y });
                            if (y > 0) extraWalls.push({ x: x, y: y - 1 });
                            if (y < mapH - 1) extraWalls.push({ x: x, y: y + 1 });
                            // Diagonals for extra robustness?
                            // extraWalls.push({x: x-1, y: y-1}, {x: x+1, y: y-1}, ...); 
                        }
                    }
                }

                // Apply Dilatation
                for (const w of extraWalls) {
                    collisionData[w.y][w.x] = true;
                }

                // Restore Magenta Pixels visually
                for (const mp of magentaPixels) {
                    const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                    data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;
                }

                // Multi-pass to fill large magenta areas from outside in
                let remainingMagenta = [...magentaPixels];
                const maxPasses = 10;
                for (let pass = 0; pass < maxPasses && remainingMagenta.length > 0; pass++) {
                    const stillRemaining = [];
                    for (const mp of remainingMagenta) {
                        const repl = pullNearbyPixel(data, mp.x, mp.y, mapW, mapH, cyanPixels);
                        // If result is the fallback gray (60,55,50), it means no neighbor found yet
                        // But wait, pullNearbyPixel returns fallback if nothing found. 
                        // We need a way to know if it found something good. 
                        // For now, let's just accept the replacement. The loop is fine.
                        data[mp.i] = repl.r; data[mp.i + 1] = repl.g; data[mp.i + 2] = repl.b;

                        // Heuristic: If we are deep inside magenta, we might get gray. 
                        // Ideally we want to wait for neighbors. But this is fast enough.
                    }
                    remainingMagenta = []; // Assume processed (simplification for speed)
                }

                // 6. Cyan Cleanup
                for (const cp of cyanPixels) {
                    const [x, y] = cp.split(',').map(Number);
                    const i = (y * mapW + x) * 4;
                    const repl = pullNearbyPixel(data, x, y, mapW, mapH, cyanPixels);
                    data[i] = repl.r; data[i + 1] = repl.g; data[i + 2] = repl.b;
                }

                // 7. Create Foreground/Background Layers
                const bgData = new Uint8ClampedArray(data);
                const fgData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < fgData.length; i += 4) fgData[i + 3] = 0; // Clear Alpha

                for (let y = 0; y < mapH; y++) {
                    for (let x = 0; x < mapW; x++) {
                        if (foregroundData[y][x]) {
                            const i = (y * mapW + x) * 4;
                            fgData[i] = data[i];
                            fgData[i + 1] = data[i + 1];
                            fgData[i + 2] = data[i + 2];
                            fgData[i + 3] = 255;
                        }
                    }
                }

                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = mapW; bgCanvas.height = mapH;
                bgCanvas.getContext('2d').putImageData(new ImageData(bgData, mapW, mapH), 0, 0);

                const fgCanvas = document.createElement('canvas');
                fgCanvas.width = mapW; fgCanvas.height = mapH;
                fgCanvas.getContext('2d').putImageData(new ImageData(fgData, mapW, mapH), 0, 0);

                bgImage = new Image();
                bgImage.src = bgCanvas.toDataURL();

                foregroundImage = new Image();
                foregroundImage.src = fgCanvas.toDataURL();

                bgImage.onload = () => {
                    gameReady = true;
                    if (document.getElementById('processingInfo')) document.getElementById('processingInfo').style.display = 'none';
                    if (document.getElementById('dropZone')) document.getElementById('dropZone').classList.add('hidden');
                    // Hide Loading Screen
                    const ls = document.getElementById('loading-screen');
                    if (ls) ls.style.display = 'none';

                    if (spawnPixel) {
                        // FIX: Blue pixel marks FOOT position, not sprite top
                        // Robust: use the same spriteH logic as checkCollisionAt

                        // 1. Update scale for spawn depth (initial guess)
                        if (mapH > 0) {
                            const yNorm = Math.max(0, Math.min(1, spawnPixel.y / mapH));
                            const depthFactor = 0.5 + (0.8 * yNorm);
                            SPRITE.scale = SPRITE.baseScale * depthFactor;
                        }

                        const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                        const FOOT_OFFSET_Y = 15; // Must match checkCollisionAt

                        player.x = spawnPixel.x - 8; // Center horizontally
                        player.y = spawnPixel.y - spriteH - FOOT_OFFSET_Y; // Feet at spawnPixel.y

                        console.log(`Spawn: Blue(${spawnPixel.x},${spawnPixel.y}) -> Feet at Y=${spawnPixel.y}, SpriteH=${spriteH.toFixed(1)}, Player.y=${player.y.toFixed(1)}`);
                    } else {
                        player.x = mapW / 2;
                        player.y = mapH / 2;
                    }

                    // Center Camera
                    camX = targetCamX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                    camY = targetCamY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));

                    // Init Extras
                    initParticles();
                    initClouds();

                    // Start Audio
                    if (typeof ambientAudio !== 'undefined') ambientAudio.play().catch(() => { });

                    startGameLoop();
                    console.log("Map Processed & Ready.");
                };


            } catch (e) {
                console.error("Advanced Processing Crash", e);
                // Fallback to RAW if crash
                bgImage = img;
                foregroundImage = null;
                collisionData = new Array(mapH).fill(null).map(() => new Array(mapW).fill(false)); // Safe init
                gameReady = true;
                startGameLoop();
            }
        }

        // ============================================
        // AUDIO BACKGROUND HANDLING (FIX FOR FIREFOX MOBILE)
        // ============================================
        let wasAmbientPlaying = false;
        let wasPlayerPlaying = false;
        window.gamePaused = false;

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                window.gamePaused = true;

                // APP BACKGROUNDED -> PAUSE ALL
                if (typeof ambientAudio !== 'undefined' && !ambientAudio.paused) {
                    wasAmbientPlaying = true;
                    ambientAudio.pause();
                } else {
                    wasAmbientPlaying = false;
                }

                if (typeof audioPlayer !== 'undefined' && !audioPlayer.paused) {
                    wasPlayerPlaying = true;
                    audioPlayer.pause();
                } else {
                    wasPlayerPlaying = false;
                }

                if (typeof footstepSound !== 'undefined') footstepSound.pause();

            } else {
                // APP FOREGROUND -> RESUME IF WAS PLAYING
                lastTime = 0;
                window.gamePaused = false;

                setTimeout(() => {
                    if (wasAmbientPlaying && typeof ambientAudio !== 'undefined') {
                        ambientAudio.play().catch(e => console.warn("Resume ambient failed", e));
                    }
                    if (wasPlayerPlaying && typeof audioPlayer !== 'undefined') {
                        audioPlayer.play().catch(e => console.warn("Resume player failed", e));
                    }
                }, 100);
            }
        });

        // Fallback: Audio starten bei erster Interaktion, falls Autoplay blockiert wurde
        document.addEventListener('click', () => {
            if (gameReady && ambientAudio.paused) {
                ambientAudio.play().catch(e => console.warn("Ambient play failed:", e));
            }
        }, { once: true }); // Nur einmal ausführen

        function findSafeStart() {
            // Suche ausgehend von der Mitte nach einer Position ohne Kollision
            const startX = Math.floor(mapW / 2);
            const startY = Math.floor(mapH / 2);

            for (let radius = 0; radius < 100; radius++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const x = startX + dx;
                        const y = startY + dy;
                        if (x >= 0 && x < mapW - 16 && y >= 0 && y < mapH - 16) {
                            if (!checkCollisionAt(x, y)) {
                                player.x = x;
                                player.y = y;
                                return;
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // FLOOD FILL MIT DILATATION
        // ============================================
        function findEnclosedAreas(cyanPixels, w, h) {
            const visited = new Array(h).fill(null).map(() => new Array(w).fill(0));

            // Dilatation der Cyan-Grenzen
            const dilationRadius = 2;
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
                    for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) <= dilationRadius) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                visited[ny][nx] = 2;
                            }
                        }
                    }
                }
            }

            // Flood Fill vom Rand
            const queue = [];
            for (let x = 0; x < w; x++) {
                if (visited[0][x] === 0) queue.push([x, 0]);
                if (visited[h - 1][x] === 0) queue.push([x, h - 1]);
            }
            for (let y = 0; y < h; y++) {
                if (visited[y][0] === 0) queue.push([0, y]);
                if (visited[y][w - 1] === 0) queue.push([w - 1, y]);
            }

            let idx = 0;
            while (idx < queue.length) {
                const [x, y] = queue[idx++];
                if (x < 0 || x >= w || y < 0 || y >= h || visited[y][x] !== 0) continue;
                visited[y][x] = 1;
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Innere Bereiche markieren
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (visited[y][x] === 0 || visited[y][x] === 2) {
                        foregroundData[y][x] = true;
                    }
                }
            }

            // Original Cyan-Pixel auch markieren
            for (const cp of cyanPixels) {
                const [x, y] = cp.split(',').map(Number);
                foregroundData[y][x] = true;
            }
        }

        // ============================================
        // PIXEL-PULLING (Spiralförmige Suche für alle Linienrichtungen)
        // ============================================
        function pullNearbyPixel(data, x, y, w, h, cyanPixels) {
            // Spiralförmige Suche: Sucht in expandierenden Kreisen
            // Funktioniert für horizontale, vertikale UND diagonale Linien
            const maxRadius = 15;  // Maximaler Suchradius

            for (let radius = 1; radius <= maxRadius; radius++) {
                // Alle Punkte auf dem aktuellen "Quadrat-Ring" durchsuchen
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        // Nur Randpunkte des Quadrats (nicht innere)
                        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;

                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;

                        const ni = (ny * w + nx) * 4;
                        const r = data[ni], g = data[ni + 1], b = data[ni + 2];

                        // Skip Magenta (Kollision) und Cyan (Vordergrund)
                        if (r > 200 && g < 80 && b > 200) continue;
                        if (r < 80 && g > 200 && b > 200) continue;
                        if (cyanPixels.has(`${nx},${ny}`)) continue;

                        // Gültiges Pixel gefunden!
                        return { r, g, b };
                    }
                }
            }

            // Fallback: Neutrales Grau-Braun (passt zu den meisten Umgebungen)
            return { r: 60, g: 55, b: 50 };
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function startGameLoop() {
            if (window.gameLoopRunning) return;
            window.gameLoopRunning = true;
            lastTime = 0;
            console.log("startGameLoop");
            requestAnimationFrame(gameLoop);
        }

        // Global vars for timing
        let lastTime = 0;

        function gameLoop(timestamp) {
            if (window.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTime) lastTime = timestamp;
            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (dt > 0.1) dt = 0.1;

            update(dt);
            updateLoreSystem();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            if (!dt) dt = 0.016;
            if (!gameReady) return;

            // --- DYNAMIC SCALING (Depth Effect) ---
            if (mapH > 0) {
                const yNorm = Math.max(0, Math.min(1, player.y / mapH));
                const depthFactor = 0.5 + (0.8 * yNorm);
                SPRITE.scale = SPRITE.baseScale * depthFactor;
            }

            // --- MOVEMENT ---
            let didAutoWalk = false;

            // --- AUTO-WALK (READING MODE & COASTDOWN) ---
            if ((isReadingMode || (player.slowdownTimer > 0)) && autoWalkPath.length > 0) {
                didAutoWalk = true;

                if (isReadingMode) {
                    player.slowdownTimer = 1.0;
                } else {
                    player.slowdownTimer -= dt;
                }

                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
                const footX = player.x + spriteW / 2;
                const footY = player.y + spriteH + 15;

                let target = autoWalkPath[autoWalkIndex];
                const tdx = target.x - footX;
                const tdy = target.y - footY;
                const dist = Math.sqrt(tdx * tdx + tdy * tdy);

                let walkSpeed = player.speed;
                if (!isReadingMode) walkSpeed *= Math.max(0, player.slowdownTimer);
                const step = walkSpeed * dt;

                if (dist < 4) {
                    autoWalkIndex++;
                    if (autoWalkIndex >= autoWalkPath.length) {
                        autoWalkIndex = autoWalkPath.length - 1;
                        if (!isReadingMode) player.slowdownTimer = 0;
                    }
                }

                if (autoWalkIndex < autoWalkPath.length && player.slowdownTimer > 0) {
                    const nextTdx = target.x - footX;
                    const nextTdy = target.y - footY;
                    const nextDist = Math.sqrt(nextTdx * nextTdx + nextTdy * nextTdy);

                    if (nextDist > 1) {
                        const dx = (nextTdx / nextDist) * step;
                        const dy = (nextTdy / nextDist) * step;
                        player.x += dx;
                        player.y += dy;
                        player.isMoving = true;

                        if (Math.abs(nextTdx) > Math.abs(nextTdy)) {
                            player.dir = nextTdx > 0 ? 3 : 2;
                        } else {
                            player.dir = nextTdy > 0 ? 0 : 1;
                        }

                        player.animTimer += dt;
                        let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                        if (player.animTimer > animThreshold) {
                            player.animTimer = 0;
                            player.frame = (player.frame + 1) % 12;
                        }
                    } else {
                        player.isMoving = false;
                    }
                } else {
                    player.isMoving = false;
                }

                player.debugFootX = undefined;
            }

            // --- MANUAL MOVEMENT (only if not auto-walking) ---
            if (!didAutoWalk) {
                let dx = 0, dy = 0;
                player.isMoving = false;

                // Keyboard
                if (keys['w'] || keys['arrowup'] || keys['ArrowUp']) { dy = -1; player.dir = 1; }
                if (keys['s'] || keys['arrowdown'] || keys['ArrowDown']) { dy = 1; player.dir = 0; }
                if (keys['a'] || keys['arrowleft'] || keys['ArrowLeft']) { dx = -1; player.dir = 2; }
                if (keys['d'] || keys['arrowright'] || keys['ArrowRight']) { dx = 1; player.dir = 3; }

                // Click-to-Move
                if (dx === 0 && dy === 0 && moveTarget && !isReadingMode) {
                    const tdx = moveTarget.x - player.x;
                    const tdy = moveTarget.y - player.y;
                    const tdist = Math.sqrt(tdx * tdx + tdy * tdy);

                    const moveStep = player.speed * dt;

                    if (tdist < moveStep) {
                        player.x = moveTarget.x;
                        player.y = moveTarget.y;
                        moveTarget = null;
                    } else {
                        dx = tdx / tdist;
                        dy = tdy / tdist;

                        if (Math.abs(tdx) > Math.abs(tdy)) player.dir = tdx > 0 ? 3 : 2;
                        else player.dir = tdy > 0 ? 0 : 1;
                    }
                }

                // Normalisieren & Move
                if (dx !== 0 || dy !== 0) {
                    player.isMoving = true;

                    if (Math.abs(dx) === 1 && Math.abs(dy) === 1) {
                        const inv = 0.7071;
                        dx *= inv; dy *= inv;
                    }

                    const amount = player.speed * dt;
                    const vx = dx * amount;
                    const vy = dy * amount;

                    const targetX = player.x + vx;
                    const targetY = player.y + vy;

                    if (!checkCollisionAt(targetX, targetY)) {
                        player.x = targetX;
                        player.y = targetY;
                    } else {
                        if (!checkCollisionAt(targetX, player.y)) player.x = targetX;
                        else if (!checkCollisionAt(player.x, targetY)) player.y = targetY;
                    }

                    player.animTimer += dt;
                    let animThreshold = (player.dir === 0 || player.dir === 1) ? 0.30 : 0.15;

                    if (player.animTimer > animThreshold) {
                        player.animTimer = 0;
                        player.frame = (player.frame + 1) % 12;
                    }
                } else {
                    player.frame = 1; // Stand
                }
            }

            // --- ALWAYS RUN: Sound, Dust, Camera, Particles ---

            // Sound handling
            if (player.isMoving) {
                if (audioUnlocked && !footstepPlaying) {
                    footstepSound.play().catch(() => { });
                    footstepPlaying = true;
                }
            } else {
                if (footstepPlaying) {
                    footstepSound.pause();
                    footstepPlaying = false;
                }
            }

            // Dust Update (no spawn in kapitel1c per user decision)
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                const d = dustParticles[i];
                d.x += d.vx * dt;  // Frame-rate independent
                d.y += d.vy * dt;
                d.life -= 2.5 * dt;
                if (d.life <= 0) dustParticles.splice(i, 1);
            }

            // Map Bounds (with sprite size and foot offset)
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const FOOT_OFFSET_Y = 15;
            player.x = Math.max(0, Math.min(player.x, mapW - spriteW));
            player.y = Math.max(0, Math.min(player.y, mapH - spriteH - FOOT_OFFSET_Y));

            player.isBehindForeground = checkForeground(player.x, player.y);

            // Camera
            targetCamX = player.x - SCREEN_W / 2 + 10;
            targetCamY = player.y - SCREEN_H * 0.30 + 10;
            targetCamX = Math.max(0, Math.min(targetCamX, Math.max(0, mapW - SCREEN_W)));
            targetCamY = Math.max(0, Math.min(targetCamY, Math.max(0, mapH - SCREEN_H)));

            camX += (targetCamX - camX) * 5.0 * dt;
            camY += (targetCamY - camY) * 5.0 * dt;

            // Particles
            nearbyLights = [];
            for (const p of particles) p.update(dt);
            for (const c of clouds) c.update(dt);
        }

        // ============================================
        // KOLLISIONSPRÜFUNG - ROBUST (Ecken-Check)
        // ============================================
        function checkCollisionAt(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const boxWidth = 8;

            const centerX = px + spriteW / 2;
            const bottomY = py + spriteH + 15;

            const left = Math.floor(centerX - boxWidth / 2);
            const right = Math.floor(centerX + boxWidth / 2);
            const yFn = Math.floor(bottomY);

            if (isSolid(left, yFn)) return true;
            if (isSolid(right, yFn)) return true;

            return false;
        }

        function isSolid(x, y) {
            if (x < 0 || x >= mapW || y < 0 || y >= mapH) return true;
            if (collisionData[y][x]) return true;
            return false;
        }

        function checkForeground(px, py) {
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

            const cx = Math.floor(px + spriteW / 2);
            const cy = Math.floor(py + spriteH / 2);

            if (foregroundData && foregroundData[cy] && cy >= 0 && cy < mapH && cx >= 0 && cx < mapW) {
                return foregroundData[cy][cx];
            }
            return false;
        }

        // ============================================
        // DRAWING
        // ============================================
        function draw() {
            // LCD Ghosting: Vorherigen Frame mit Transparenz beibehalten
            // Disable Ghosting
            // ctx.save(); ... ctx.restore();

            // Clear Canvas fully every frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameReady) return;

            ctx.save();
            // Screen-Shake anwenden
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;

            // SMOOTH CAMERA: Use sub-pixel values (remove Math.floor)
            ctx.translate(-camX + shakeX, -camY + shakeY);

            screenShake *= 0.8; // Schnell abklingen

            // Hintergrund
            if (bgImage) ctx.drawImage(bgImage, 0, 0);

            // Partikel (Additives Leuchten)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (const p of particles) p.draw(ctx, camX, camY);
            ctx.restore();

            // Gelbe Lore-Lichter zeichnen
            for (const light of yellowLights) {
                light.draw(ctx);

                // Beleuchtung hinzufügen wenn aktiv!
                if (activeLightSourceId === light.id && isLoreMode) {
                    const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                    const px = coords.x + coords.w / 2;
                    const py = coords.y + coords.h / 2;

                    const ddx = light.x - px;
                    const ddy = light.y - py;
                    const dist = Math.sqrt(ddx * ddx + ddy * ddy);
                    nearbyLights.push({
                        x: light.x,
                        y: light.y,
                        dist: dist,
                        life: 1.0,
                        isYellow: true
                    });
                }
            }

            // Spieler-Schatten (diffuse Ellipse unter den Füßen)
            {
                const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
                const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;

                // Offsets identisch zu drawPlayer berechnen
                const offsetY = Math.floor(spriteH * 0.22);
                const shiftY = Math.floor(spriteH / 3) - 4;
                const totalYOffset = offsetY + shiftY;

                // Schatten-Position: exakt unter den Füßen des Sprites
                const shadowCenterX = player.x + spriteW / 2;
                const shadowCenterY = player.y + totalYOffset + spriteH - 15; // Korrigiert

                // Schatten-Größe: klein und diffus
                const shadowWidth = spriteW * 0.4;
                const shadowHeight = 3;

                // Schatten-Deckkraft
                let shadowAlpha = 0.35;

                if (nearbyLights.length > 0) {
                    const light = nearbyLights[0];
                    const distFactor = 1 - (light.dist / 35);
                    shadowAlpha = 0.25 + distFactor * 0.15;
                }

                // Diffuser Schatten mit radialem Gradient
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    shadowCenterX, shadowCenterY, 0,
                    shadowCenterX, shadowCenterY, shadowWidth
                );
                gradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
                gradient.addColorStop(0.5, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(shadowCenterX, shadowCenterY, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Spieler NORMAL zeichnen (keine Transparenz!)
            drawPlayer(ctx, player.x, player.y, player.dir, player.frame);

            // DEBUG: Fadenkreuz an Fuß-Position (nur im Reading Mode)
            if (isReadingMode && player.debugFootX !== undefined) {
                const fx = player.debugFootX;
                const fy = player.debugFootY;
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(fx - 8, fy);
                ctx.lineTo(fx + 8, fy);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(fx, fy - 8);
                ctx.lineTo(fx, fy + 8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Beleuchtung: Direktional mit Gradient
            if (nearbyLights.length > 0) {
                nearbyLights.sort((a, b) => a.dist - b.dist);

                const maxRadius = 65; // Erhöht (war 35) für weichere Übergänge
                let totalIntensity = 0;
                let avgDx = 0, avgDy = 0;
                let useYellow = false;

                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const spriteW = coords.w;
                const spriteH = coords.h;
                const playerCX = coords.x + spriteW / 2;
                const playerCY = coords.y + spriteH / 2;

                const numLights = Math.min(2, nearbyLights.length);
                for (let i = 0; i < numLights; i++) {
                    const light = nearbyLights[i];
                    if (light.isYellow) useYellow = true;

                    // Distanz-Modulation: 0% am Rand, 100% direkt am Spieler
                    const distFactor = (1 - (light.dist / maxRadius));
                    // Gelbes Licht etwas intensiver
                    const intensity = distFactor * light.life * (light.isYellow ? 1.5 : 1.0);
                    totalIntensity += intensity * 0.4; // Subtiler (war 0.6)

                    // Richtung vom Licht zum Spieler (normalisiert)
                    const dx = playerCX - light.x;
                    const dy = playerCY - light.y;
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    avgDx += (dx / len) * intensity;
                    avgDy += (dy / len) * intensity;
                }

                // Max 50% Aufhellung (subtiler Effekt), Gelb darf etwas heller sein (70%)
                totalIntensity = Math.min(useYellow ? 0.7 : 0.5, totalIntensity);

                if (totalIntensity > 0.02) {
                    // Normalisiere Durchschnittsrichtung
                    const dirLen = Math.sqrt(avgDx * avgDx + avgDy * avgDy) || 1;
                    const ndx = avgDx / dirLen;
                    const ndy = avgDy / dirLen;

                    // OffScreen-Canvas für Gradient-Beleuchtung
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = spriteW;
                    lightCanvas.height = spriteH;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Zeichne Sprite exakt so wie es auf dem Hauptcanvas erscheint, aber relativ zu (0,0)
                    lightCtx.save();
                    lightCtx.translate(-coords.x, -coords.y);
                    drawPlayer(lightCtx, player.x, player.y, player.dir, player.frame);
                    lightCtx.restore();

                    // Gleichmäßigere Beleuchtung (statt harter Gradient)
                    // Wir füllen das Sprite fast gleichmäßig auf (mit sehr weichem Rand-Ausfall)
                    const r = useYellow ? 255 : 255;
                    const g = useYellow ? 220 : 255;
                    const b = useYellow ? 50 : 255;

                    lightCtx.globalCompositeOperation = 'source-in';
                    // Fast gleichmäßige Füllung basierend auf Intensität
                    lightCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.8})`;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Ein ganz dezenter Gradient für Dreidimensionalität
                    const rad = Math.max(spriteW, spriteH) * 2;
                    const gradient = lightCtx.createRadialGradient(
                        spriteW / 2 + ndx * (spriteW / 2),
                        spriteH / 2 + ndy * (spriteH / 2),
                        0,
                        spriteW / 2,
                        spriteH / 2,
                        rad
                    );
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${totalIntensity * 0.2})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    lightCtx.fillStyle = gradient;
                    lightCtx.fillRect(0, 0, spriteW, spriteH);

                    // Zeichne beleuchtetes Sprite an die berechnete Sprite-Position
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(lightCanvas, coords.x, coords.y);
                    ctx.restore();
                }
            }

            // Dust-Particles zeichnen
            ctx.save();
            for (const d of dustParticles) {
                ctx.globalAlpha = d.life * 0.4;
                ctx.fillStyle = '#a89070';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Vordergrund
            if (foregroundImage) ctx.drawImage(foregroundImage, 0, 0);

            // Graue Silhouette IMMER berechnen (Pixel-genaues Masking)
            if (foregroundImage && spriteReady) {
                const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
                const px = coords.x;
                const py = coords.y;
                const dw = coords.w;
                const dh = coords.h;

                // OffScreen-Canvas für Masking
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = dw + 4;
                maskCanvas.height = dh + 4;
                const maskCtx = maskCanvas.getContext('2d');

                // 1. Zeichne den Foreground-Ausschnitt über dem Spieler
                maskCtx.drawImage(foregroundImage,
                    px - 2, py - 2, dw + 4, dh + 4,
                    0, 0, dw + 4, dh + 4);

                // 2. Source-In: Nur wo Foreground-Pixel existieren
                maskCtx.globalCompositeOperation = 'source-in';

                // 3. Zeichne graues Sprite
                const graySprite = createGraySpriteCanvas();
                if (graySprite) {
                    maskCtx.drawImage(graySprite, 2, 2);
                }

                // 4. Zeichne das Ergebnis
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.drawImage(maskCanvas, px - 2, py - 2);
                ctx.restore();
            }

            // Wolken-Layer (Parallax, über allem)
            for (const c of clouds) c.draw(ctx, camX, camY);

            ctx.restore();
        }

        // NEU: Hilfsfunktion für konsistente Koordinatenberechnung
        function getPlayerDrawCoords(x, y, dir, frame) {
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;
            const flipX = (dir === 3);

            // FRONT (Marker-basiert, 6-Step)
            if (dir === 0) {
                const cycleIdx = frame % 6;
                const frameIdx = FRONT_ANIM_CYCLE[cycleIdx];
                const data = FRONT_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteFront.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                return {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteFront.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // BACK (NEU: Marker-basiert, 4-Step Cycle)
            else if (dir === 1) {
                const cycleIdx = frame % 4;
                const frameIdx = BACK_ANIM_CYCLE[cycleIdx];
                const data = BACK_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = data.width;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteBack.height * SPRITE.scale);

                const dx = x + refW / 2 - footRelX * SPRITE.scale;
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                return {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteBack.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: false
                };
            }
            // SIDE (Marker-basiert, 6-Step Ping-Pong)
            else if (dir === 2 || dir === 3) {
                const cycleIdx = frame % 6;
                const frameIdx = SIDE_ANIM_CYCLE[cycleIdx];
                const data = SIDE_SPRITE_DATA[frameIdx];
                const footRelX = data.footX - data.left;
                const footRelY = data.footY;

                const sw = 175;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(spriteSide.height * SPRITE.scale);

                let dx;
                if (flipX) {
                    // Gespiegelt: Ankerpunkt (x + refW/2) ist die Achse.
                    // Die linke Kante ist (Anker + verschobener_Anker) - Breite
                    dx = (x + refW / 2 + footRelX * SPRITE.scale) - dw;
                } else {
                    dx = x + refW / 2 - footRelX * SPRITE.scale;
                }
                const dy = y + refH + visualShiftY - footRelY * SPRITE.scale;

                return {
                    x: dx, y: dy, w: dw, h: dh,
                    isSide: true, frameIdx: frameIdx,
                    sx: data.left, sw: sw, sh: spriteSide.height,
                    footRelX: footRelX * SPRITE.scale,
                    flipX: flipX
                };
            } else {
                let sprite = (dir === 1) ? (spriteBack || spriteFront) : spriteFront;
                const sw = Math.floor(sprite.width / SPRITE.cols);
                const sh = sprite.height;
                const dw = Math.floor(sw * SPRITE.scale);
                const dh = Math.floor(sh * SPRITE.scale);
                const offsetY = Math.floor(dh * 0.22);

                const frameIdx = frame % 4;
                const sx = frameIdx * sw;

                const finalX = x;
                const finalY = y + offsetY + visualShiftY;
                return {
                    x: finalX, y: finalY, w: dw, h: dh,
                    isSide: false, frameIdx: frameIdx,
                    sx: sx, sw: sw, sh: sh,
                    flipX: false
                };
            }
        }

        // ============================================
        // SPIELER SPRITE ZEICHNEN
        // ============================================
        function drawPlayer(ctx, x, y, dir, frame) {
            if (!spriteReady) return;

            const coords = getPlayerDrawCoords(x, y, dir, frame);
            const refW = Math.floor(SPRITE.frameWidth * SPRITE.scale);
            const refH = Math.floor(SPRITE.frameHeight * SPRITE.scale);
            const visualShiftY = Math.floor(refH / 3) - 4;

            ctx.save();
            let sprite;
            if (dir === 0) sprite = spriteFront;
            else if (dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            // DEBUG-DOT an der Fuß-Koordinate
            if (window.debugFoot) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(x + refW / 2, y + refH + visualShiftY, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(x + refW / 2 - 2, y + refH + visualShiftY - 2, 4, 4);
                ctx.restore();
            }

            if (coords.isSide && coords.flipX) {
                // Spiegeln: Translate zur EXAKT berechneten linken Kante + Breite
                ctx.translate(coords.x + coords.w, coords.y);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);
            } else {
                ctx.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, coords.x, coords.y, coords.w, coords.h);
            }

            ctx.restore();
        }

        window.debugFoot = false;

        // Erstellt ein einfarbig graues Sprite-Canvas
        function createGraySpriteCanvas() {
            if (!spriteReady) return null;

            const coords = getPlayerDrawCoords(player.x, player.y, player.dir, player.frame);
            const flipX = (player.dir === 3);

            let sprite;
            if (player.dir === 0) sprite = spriteFront;
            else if (player.dir === 1) sprite = spriteBack || spriteFront;
            else sprite = spriteSide || spriteFront;

            const c = document.createElement('canvas');
            c.width = coords.w;
            c.height = coords.h;
            const gc = c.getContext('2d');

            if (coords.isSide && flipX) {
                gc.translate(coords.w, 0);
                gc.scale(-1, 1);
            }
            gc.drawImage(sprite, coords.sx, 0, coords.sw, coords.sh, 0, 0, coords.w, coords.h);

            gc.globalCompositeOperation = 'source-in';
            gc.fillStyle = 'rgb(180, 180, 180)';
            gc.fillRect(0, 0, coords.w, coords.h);

            return c;
        }

        function drawPlayerOutline(ctx, x, y) {
            if (!spriteReady || !spriteFront) return;

            const dir = player.dir;
            let sprite;
            let flipX = false;

            switch (dir) {
                case 0: sprite = spriteFront; break;
                case 1: sprite = spriteBack || spriteFront; break;
                case 2: sprite = spriteSide || spriteFront; break;
                case 3: sprite = spriteSide || spriteFront; flipX = true; break;
                default: sprite = spriteFront;
            }

            const spriteW = Math.floor(sprite.width / SPRITE.cols);
            const spriteH = sprite.height;
            const drawW = Math.floor(spriteW * SPRITE.scale);
            const drawH = Math.floor(spriteH * SPRITE.scale);
            const frame = player.frame % SPRITE.cols;

            // Erstelle OffScreen-Canvas für einfarbige Silhouette
            const offCanvas = document.createElement('canvas');
            offCanvas.width = drawW;
            offCanvas.height = drawH;
            const offCtx = offCanvas.getContext('2d');

            // Zeichne Sprite ins OffScreen-Canvas
            if (flipX) {
                offCtx.translate(drawW, 0);
                offCtx.scale(-1, 1);
            }
            offCtx.drawImage(sprite, frame * spriteW, 0, spriteW, spriteH, 0, 0, drawW, drawH);

            // Wandle alle sichtbaren Pixel in einheitliches Grau
            offCtx.globalCompositeOperation = 'source-in';
            offCtx.fillStyle = 'rgb(200, 200, 200)'; // Helles Grau
            offCtx.fillRect(0, 0, drawW, drawH);

            // Zeichne die graue Silhouette halbtransparent
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(offCanvas, Math.floor(x), Math.floor(y));
            ctx.restore();
        }

        // ============================================
        // AUDIO & SUBTITLE SYSTEM
        // ============================================

        const audioPlayer = new Audio();
        let subtitleTracks = []; // Array aus { time: sekunden, text: string }
        let currentSubtitleIndex = -1;
        let isReadingMode = false;

        const uiContainer = document.getElementById('audioPlayerUI');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const audioControlsEl = document.getElementById('audioControls');
        const playBtn = document.getElementById('audioToggleBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipForwardBtn = document.getElementById('skipForwardBtn');
        const readingModeBtn = document.getElementById('readingModeBtn');
        const gameModeBtn = document.getElementById('gameModeBtn');
        const iconPlay = document.getElementById('iconPlay');
        const iconPause = document.getElementById('iconPause');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const iconFsEnter = document.getElementById('iconFsEnter');
        const iconFsExit = document.getElementById('iconFsExit');

        // FORCE REMOVE FOCUS FROM BUTTONS
        // This prevents the "Orange Box" from appearing when using arrow keys after clicking a button
        document.querySelectorAll('button').forEach(btn => {
            // Option 1: Blur on click
            btn.addEventListener('click', () => {
                btn.blur();
                window.focus();
            });
            // Option 2: Build wall against focus
            btn.addEventListener('focus', () => {
                btn.blur();
            });
            // Option 3: Prevent default on mousedown (stops focus, keeps click)
            btn.addEventListener('mousedown', (e) => {
                if (document.activeElement !== btn) {
                    e.preventDefault();
                }
            });
        });

        // Ambient und Schritte Audio mit 75% Lautstärke (25% leiser als Standard)
        const ambientAudio = new Audio('medieval_town.mp3');
        ambientAudio.loop = true;
        ambientAudio.volume = 0.75;

        const footstepsAudio = new Audio('footsteps.mp3');
        footstepsAudio.loop = true;
        footstepsAudio.volume = 0.75;

        // Berechne die Anzahl sichtbarer Zeilen basierend auf Bildschirmhöhe
        function getMaxVisibleLines() {
            if (!isReadingMode) return 3;
            const lineHeight = 28; // Ungefähre Zeilenhöhe in px
            const availableHeight = window.innerHeight * 0.6; // 60% der Bildschirmhöhe
            return Math.min(15, Math.max(5, Math.floor(availableHeight / lineHeight)));
        }

        // Generiert die Untertitel-Zeilen dynamisch
        function renderSubtitleLines(centerIndex) {
            // A) Reading Mode: Rendere ALLE Zeilen (für Scrollbar)
            if (isReadingMode) {
                // Nur neu bauen, wenn Anzahl nicht stimmt (Performance!)
                if (subtitleContainer.children.length !== subtitleTracks.length) {
                    subtitleContainer.innerHTML = '';
                    subtitleTracks.forEach((track, i) => {
                        const div = document.createElement('div');
                        div.className = 'subtitle-line';
                        div.innerText = track.text;
                        div.dataset.index = i;

                        // Click to Seek
                        div.title = "Klicken zum Springen";
                        div.style.cursor = "pointer";
                        div.addEventListener('click', (e) => {
                            if (subtitleContainer.dataset.wasDragging === 'true') {
                                console.log("Click ignored due to drag");
                                return;
                            }
                            console.log(`Seek to ${track.time}s`);
                            audioPlayer.currentTime = track.time;
                            updateSubtitleDisplay(i);
                        });

                        subtitleContainer.appendChild(div);
                    });
                }

                // Highlighting aktualisieren
                const oldActive = subtitleContainer.querySelector('.subtitle-current');
                if (oldActive) oldActive.classList.remove('subtitle-current');

                // Ensure centerIndex is valid
                const safeIndex = centerIndex < 0 ? 0 : centerIndex;

                if (subtitleContainer.children.length > safeIndex) {
                    const activeEl = subtitleContainer.children[safeIndex];
                    activeEl.classList.add('subtitle-current');

                    // Auto-Scroll nur, wenn User nicht gerade selbst scrollt
                    if (!subtitleContainer.classList.contains('is-scrolling') && !subtitleContainer.dataset.isDragging) {
                        activeEl.scrollIntoView({ block: 'center', behavior: 'smooth' });
                    }
                }
                return;
            }

            // B) Game Mode: Nur kleines Fenster rendern (3 Zeilen)
            subtitleContainer.innerHTML = '';

            if (subtitleTracks.length === 0) {
                const div = document.createElement('div');
                div.className = 'subtitle-line subtitle-current';
                div.innerText = 'Warte auf Audio/Text...';
                subtitleContainer.appendChild(div);
                return;
            }

            // Fixe 3 Zeilen im Spielmodus
            const startIdx = Math.max(0, centerIndex - 1);
            const endIdx = Math.min(subtitleTracks.length - 1, centerIndex + 1);

            for (let i = startIdx; i <= endIdx; i++) {
                const div = document.createElement('div');
                div.className = 'subtitle-line';

                const distance = Math.abs(i - centerIndex);

                if (i === centerIndex) {
                    div.classList.add('subtitle-current');
                } else {
                    // Verblassen
                    if (distance >= 5) div.classList.add('fade-far');
                    else if (distance >= 3) div.classList.add('fade-mid');
                }

                div.innerText = subtitleTracks[i].text;
                subtitleContainer.appendChild(div);
            }
        }



        // 2. Parser für Timestamps: [mm:ss.xx] Text
        function parseSubtitles(rawText) {
            subtitleTracks = [];
            currentSubtitleIndex = -1;
            const lines = rawText.split('\n');
            const timeReg = /\[(\d{2}):(\d{2}(?:\.\d+)?)\](.*)/;

            lines.forEach(line => {
                const match = line.match(timeReg);
                if (match) {
                    const minutes = parseFloat(match[1]);
                    const seconds = parseFloat(match[2]);
                    const text = match[3].trim();
                    const totalSeconds = minutes * 60 + seconds;

                    subtitleTracks.push({
                        time: totalSeconds,
                        text: text
                    });
                }
            });
            subtitleTracks.sort((a, b) => a.time - b.time);
        }

        // 3. Update-Funktion für Anzeige
        function updateSubtitleDisplay(index) {
            if (index === currentSubtitleIndex) return;
            currentSubtitleIndex = index;
            renderSubtitleLines(Math.max(0, index));
        }

        // 4. Synchronisation (läuft bei jedem Audio-Update)
        audioPlayer.addEventListener('timeupdate', () => {
            const t = audioPlayer.currentTime;

            let newIndex = -1;
            for (let i = subtitleTracks.length - 1; i >= 0; i--) {
                if (t >= subtitleTracks[i].time) {
                    newIndex = i;
                    break;
                }
            }

            updateSubtitleDisplay(newIndex);
        });

        // 4b. Chapter Transition Logic (Main Audio Ended)
        audioPlayer.addEventListener('ended', () => {
            // If Lore Mode, we let the OTHER listener (if exists) or restoreMainAudio handle it.
            // But since I couldn't find the other listener, I'll add a safe check here.
            // If we are in Lore Mode, we usually want to go back to Main Audio.
            // Converting to "Global" logic:
            if (isLoreMode) {
                // Determine if there is another handler. 
                // If restoreMainAudio exists, call it.
                if (window.restoreMainAudio) {
                    window.restoreMainAudio();
                }
            } else {
                // MAIN CHAPTER FINISHED
                console.log("Chapter 1 Finished. ReadingMode:", isReadingMode);
                if (isReadingMode) {
                    transitionToNextChapter();
                } else {
                    // Game Mode: Show Button
                    const btn = document.getElementById('nextChapterBtn');
                    if (btn) btn.classList.add('visible');

                    // UI Polish: switch to Pause icon? No, audio ended means it stopped.
                    // Just ensure logic state.
                }
            }
        });

        window.transitionToNextChapter = function () {
            const overlay = document.getElementById('transitionOverlay');
            if (overlay) overlay.classList.add('active');

            // Fade out any remaining audio
            fadeAudio(audioPlayer, 0, 1500);

            setTimeout(() => {
                alert("Ende der aktuellen Demo-Inhalte.");
                window.location.href = 'index.html'; // Return to start
            }, 2000); // 2s Fade Time
        };

        const nextChapterBtn = document.getElementById('nextChapterBtn');
        if (nextChapterBtn) {
            nextChapterBtn.addEventListener('click', () => {
                nextChapterBtn.classList.remove('visible');
                transitionToNextChapter();
            });
        }


        // 11. Custom Drag-to-Scroll Logic for Subtitle Container
        let isDown = false;
        let startY;
        let scrollTop;

        const handleDown = (e) => {
            isDown = true;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.dataset.wasDragging = 'false'; // Reset for next click check
            const pageY = e.pageY || e.touches[0].pageY;
            startY = pageY - subtitleContainer.offsetTop;
            scrollTop = subtitleContainer.scrollTop;
            // Optional: Cursor style
            subtitleContainer.style.cursor = 'grabbing';
        };

        const handleMove = (e) => {
            if (!isDown) return;
            e.preventDefault(); // Prevent text selection
            const pageY = e.pageY || e.touches[0].pageY;
            const y = pageY - subtitleContainer.offsetTop;
            const walk = (y - startY) * 1.0; // Scroll speed

            // Threshold check
            if (Math.abs(walk) > 5) {
                subtitleContainer.dataset.isDragging = 'true';
                subtitleContainer.dataset.wasDragging = 'true';
                subtitleContainer.scrollTop = scrollTop - walk;
            }
        };

        const handleUp = () => {
            isDown = false;
            subtitleContainer.dataset.isDragging = 'false';
            subtitleContainer.style.cursor = 'auto';
        };

        subtitleContainer.addEventListener('mousedown', handleDown);
        subtitleContainer.addEventListener('touchstart', handleDown);

        subtitleContainer.addEventListener('mouseleave', handleUp);
        subtitleContainer.addEventListener('mouseup', handleUp);
        subtitleContainer.addEventListener('touchend', handleUp);

        subtitleContainer.addEventListener('mousemove', handleMove);
        subtitleContainer.addEventListener('touchmove', handleMove);

        // 10. Scrollbar Auto-Hide Logic
        let scrollTimeout;
        subtitleContainer.addEventListener('scroll', () => {
            subtitleContainer.classList.add('is-scrolling');
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                subtitleContainer.classList.remove('is-scrolling');
            }, 1000); // 1 Sekunde nach Scroll-Ende ausblenden
        });

        // 5. Play/Pause Steuerung
        playBtn.addEventListener('click', () => {
            console.log("Play Button Clicked. Current Src:", audioPlayer.src, "Paused:", audioPlayer.paused);
            if (audioPlayer.paused) {
                audioPlayer.play().catch(e => console.error("Play verification failed:", e));
                iconPlay.style.display = 'none';
                iconPause.style.display = 'block';
            } else {
                audioPlayer.pause();
                iconPlay.style.display = 'block';
                iconPause.style.display = 'none';
            }
        });

        // 6. Skip Buttons (±15 Sekunden)
        skipBackBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 15);
        });

        skipForwardBtn.addEventListener('click', () => {
            audioPlayer.currentTime = Math.min(audioPlayer.duration || 0, audioPlayer.currentTime + 15);
        });

        // 7. Modus-Wechsel mit schneller Animation
        readingModeBtn.addEventListener('click', () => {
            uiContainer.classList.add('mode-switching');
            // Sofort umschalten, Buttons faden währenddessen
            isReadingMode = true;
            localStorage.setItem('gameboy_reading_mode', 'true'); // STATE PERSISTENCE

            // CRITICAL: Synchronize Path Direction
            syncAutoWalkToIndex();

            moveTarget = null; // Stoppe Bewegung
            uiContainer.classList.add('reading-mode');
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            // Nach kurzer Zeit Buttons wieder einblenden
            setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);
        });

        // HELPER: Sync AutoWalk Index to current Player Position
        function syncAutoWalkToIndex() {
            if (!autoWalkPath || autoWalkPath.length === 0) return;

            // Calculate Foot Position
            const spriteW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const spriteH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const footX = player.x + spriteW / 2;
            const footY = player.y + spriteH + 15;

            // Find closest index
            let closestIdx = 0;
            let minDistSq = Infinity;

            for (let i = 0; i < autoWalkPath.length; i++) {
                const node = autoWalkPath[i];
                const dx = node.x - footX;
                const dy = node.y - footY;
                const distSq = dx * dx + dy * dy;

                if (distSq < minDistSq) {
                    minDistSq = distSq;
                    closestIdx = i;
                }
            }

            // Set Index
            autoWalkIndex = closestIdx;
            console.log(`AutoWalk Synced to Index: ${closestIdx} / ${autoWalkPath.length}`);
        }

        gameModeBtn.addEventListener('click', () => {
            uiContainer.classList.add('mode-switching');
            isReadingMode = false;
            localStorage.setItem('gameboy_reading_mode', 'false'); // STATE PERSISTENCE

            // Fix: Ensure Lore Mode is also exited IF it was proximity triggered
            // If menu triggered, allow it to continue (as per user request)
            if (isLoreMode && !isMenuTriggeredLore) {
                endLoreMode();
            }

            // Do NOT force isLoreMode = false if we want it to continue playing!
            // isLoreMode = false; // REMOVED to allow playback

            // But if we kept it running, we must ensure moveTarget is clear?
            moveTarget = null;  // Clear any pending movement

            uiContainer.classList.remove('reading-mode');
            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            setTimeout(() => {
                uiContainer.classList.remove('mode-switching');
            }, 150);
        });

        // 8. Wenn Audio zu Ende ist, Reset
        // 8. Wenn Audio zu Ende ist
        audioPlayer.addEventListener('ended', () => {
            // Auto-Resume Main Audio if in Lore Mode
            if (isLoreMode) {
                console.log("Lore ended. Returning to Main Audio...");
                restoreMainAudio();
                return;
            }

            iconPlay.style.display = 'block';
            renderSubtitleLines(subtitleTracks.length - 1);
        });

        // 9. Bei Fenster-Resize: Canvas anpassen & Zeilen neu berechnen
        window.addEventListener('resize', () => {
            // A) Canvas Resize Logic (Vollbild Unterstützung)
            if (mapW > 0 && mapH > 0 && gameReady) {
                SCREEN_W = Math.min(mapW, window.innerWidth);
                SCREEN_H = Math.min(mapH, window.innerHeight);
                canvas.width = SCREEN_W;
                canvas.height = SCREEN_H;

                // Kamera neu zentrieren
                camX = Math.max(0, Math.min(player.x - SCREEN_W / 2 + 10, mapW - SCREEN_W));
                camY = Math.max(0, Math.min(player.y - SCREEN_H * 0.30 + 10, mapH - SCREEN_H));
            }

            // B) Untertitel Logic: Force Rebuild bei Resize
            if (isReadingMode && subtitleTracks.length > 0) {
                // Leere Container um Rebuild zu erzwingen (Fix für Scrollbar Resize Bug)
                subtitleContainer.innerHTML = '';
                renderSubtitleLines(Math.max(0, currentSubtitleIndex));
            }
        });

        // 10. Fullscreen Logic
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                iconFsEnter.style.display = 'none';
                iconFsExit.style.display = 'block';
            } else {
                iconFsEnter.style.display = 'block';
                iconFsExit.style.display = 'none';
            }
        });

        // 11. Custom Fullscreen Button (siehe oben)
        let lastBrightness = 0;


        let lastBrightnessCheck = 0;
        function checkBackgroundBrightness(timestamp) {
            // Im Lesemodus immer dunkler Hintergrund
            if (isReadingMode) {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            if (!gameReady || uiContainer.style.display === 'none') {
                setTimeout(() => requestAnimationFrame(checkBackgroundBrightness), 500);
                return;
            }

            // Throttle: Nur alle 1000ms prüfen (Performance!)
            if (!timestamp) timestamp = performance.now();
            if (timestamp - lastBrightnessCheck < 1000) {
                requestAnimationFrame(checkBackgroundBrightness);
                return;
            }
            lastBrightnessCheck = timestamp;

            try {
                const uiRect = uiContainer.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const sampleX = Math.max(0, (uiRect.left - canvasRect.left) * (canvas.width / canvasRect.width));
                const sampleY = Math.max(0, (uiRect.top - canvasRect.top) * (canvas.height / canvasRect.height));
                const sampleW = Math.min(canvas.width - sampleX, uiRect.width * (canvas.width / canvasRect.width));
                const sampleH = Math.min(canvas.height - sampleY, uiRect.height * (canvas.height / canvasRect.height));

                if (sampleW > 0 && sampleH > 0 && sampleX >= 0 && sampleY >= 0) {
                    const imageData = ctx.getImageData(
                        Math.floor(sampleX),
                        Math.floor(sampleY),
                        Math.floor(Math.min(sampleW, 100)),
                        Math.floor(Math.min(sampleH, 60))
                    );

                    let totalBrightness = 0;
                    const pixels = imageData.data;
                    const pixelCount = pixels.length / 4;

                    for (let i = 0; i < pixels.length; i += 16) {
                        const r = pixels[i];
                        const g = pixels[i + 1];
                        const b = pixels[i + 2];
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                    }

                    const avgBrightness = totalBrightness / (pixelCount / 4);
                    lastBrightness = lastBrightness * 0.85 + avgBrightness * 0.15;

                    // Stärkerer Kontrast: noch früher einsetzen, höhere Basis
                    const threshold = 60;
                    const maxBrightness = 180;
                    const baseOpacity = 0.5;
                    const maxAdditionalOpacity = 0.8;

                    if (lastBrightness > threshold) {
                        const dynamicOpacity = ((lastBrightness - threshold) / (maxBrightness - threshold)) * maxAdditionalOpacity;
                        const opacity = Math.min(0.95, baseOpacity + dynamicOpacity);
                        const bgValue = `rgba(0, 0, 0, ${opacity.toFixed(2)})`;
                        subtitleContainer.style.background = bgValue;
                        audioControlsEl.style.background = bgValue;
                    } else {
                        subtitleContainer.style.background = 'rgba(0, 0, 0, 0)';
                        audioControlsEl.style.background = 'rgba(0, 0, 0, 0)';
                    }
                }
            } catch (e) {
                // Canvas-Zugriff kann bei bestimmten Bedingungen fehlschlagen
            }

            requestAnimationFrame(checkBackgroundBrightness);
        }

        // Starte die Hintergrund-Prüfung
        requestAnimationFrame(checkBackgroundBrightness);

        // Global Start Time for Grace Period
        const GAME_START_TIME = Date.now();

        // ============================================
        // LORE PROXIMITY SYSTEM
        // ============================================
        function updateLoreSystem() {
            // Grace Period: 3 Sekunden keine Trigger nach Start
            if (!gameReady || yellowLights.length === 0 || (Date.now() - GAME_START_TIME < 3000)) return;

            const refW = spriteReady ? SPRITE.frameWidth * SPRITE.scale : 16;
            const refH = spriteReady ? SPRITE.frameHeight * SPRITE.scale : 20;
            const offsetY = Math.floor(refH * 0.22);
            const hatOffset = Math.floor(refH * 0.15);

            // Bounding Box des Charakters (synchron mit der visuellen Anzeige)
            // Nur der "Körper" (Hut bis Füße) löst den Trigger aus
            const pLeft = player.x;
            const pRight = player.x + refW;
            const pTop = player.y + offsetY + hatOffset;
            const pBottom = player.y + offsetY + refH;

            // Finde das nächste Licht und die Distanz zur Bounding Box
            let nearestId = null;
            let minDist = Infinity;

            yellowLights.forEach(light => {
                // Finde den nächsten Punkt auf der Bounding Box zum Licht
                const closestX = Math.max(pLeft, Math.min(light.x, pRight));
                const closestY = Math.max(pTop, Math.min(light.y, pBottom));

                const dx = light.x - closestX;
                const dy = light.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    nearestId = light.id;
                }
            });

            const TRIGGER_DIST = 6; // Reduced by ~70% (was 20)
            const EXIT_DIST = 25;

            // SHIMMER SOUND TRIGGER (Unabhängig vom Text)
            if (nearestId && minDist < TRIGGER_DIST) {
                // BUGFIX: Do not play shimmer if already collected!
                if (!window.GameState.isLightCollected(SCENE_NAME, nearestId)) {
                    if (lastShimmerLightId !== nearestId) {
                        shimmerSound.currentTime = 0;
                        shimmerSound.play().catch(() => { });
                        lastShimmerLightId = nearestId;
                    }
                }
            } else if (!nearestId || minDist > EXIT_DIST) {
                // Reset, wenn man den Einflussbereich verlassen hat
                lastShimmerLightId = null;
            }

            // START LORE - ALLE Lichter lösen lore1 aus (vorerst)
            // START LORE - ALLE Lichter lösen lore1 aus (vorerst)
            // START LORE - Dynamic Sequential Unlock
            if (nearestId && minDist < TRIGGER_DIST && !isLoreMode) {
                // Safety Check: Ignore if Player or Light is at (0,0) (Spawn Glitch)
                const light = yellowLights.find(l => l.id === nearestId);
                if ((player.x === 0 && player.y === 0) || (light && light.x === 0 && light.y === 0)) {
                    return;
                }

                // Check if this specific light was already collected
                const sc = (typeof SCENE_NAME !== 'undefined') ? SCENE_NAME : "kapitel1c";
                const alreadyCollected = window.GameState ? window.GameState.isLightCollected(sc, nearestId) : (LoreSystem.state.collectedLights[sc] && LoreSystem.state.collectedLights[sc].includes(nearestId));
                if (alreadyCollected) {
                    return;
                }

                activeLightSourceId = nearestId;

                // Use GameState for unified persistence (syncs with YellowLight.draw check)
                if (window.GameState) {
                    window.GameState.collectLight(sc, nearestId).then(unlockedLoreId => {
                        if (unlockedLoreId) {
                            console.log("[GameState] Collected Light -> Unlocked Lore:", unlockedLoreId);
                            // Refresh archive menu so new lore appears immediately
                            if (typeof renderArchive === 'function') renderArchive();
                            // Start lore mode with the UNLOCKED lore ID (not the light ID!)
                            startLoreMode(unlockedLoreId);
                        } else {
                            console.log("[GameState] Light collected but all lore already unlocked.");
                        }
                    });
                } else {
                    // Fallback to local LoreSystem if GameState not available
                    if (!LoreSystem.state.collectedLights[sc]) LoreSystem.state.collectedLights[sc] = [];
                    LoreSystem.state.collectedLights[sc].push(nearestId);
                    LoreSystem.save();
                    const nextLore = LoreSystem.state.collectedLore.length + 1;
                    if (LoreSystem.unlock(nextLore)) {
                        console.log("[LoreSystem] Unlocked Lore:", nextLore);
                        startLoreMode(nextLore);
                    }
                }
            }
            // STOP LORE (Spieler läuft weg) - NUR wenn NICHT vom Menü gestartet!
            else if (isLoreMode && minDist > EXIT_DIST && !isMenuTriggeredLore) {
                endLoreMode();
            }
        } // End updateLoreSystem

        // NEW: Restore Main Audio Function (Replaces basic endLoreMode logic)
        function restoreMainAudio() {
            if (!isLoreMode) return;

            console.log("Restoring Main Audio...");
            isLoreMode = false;
            // isReadingMode intentionally left as is (User can switch manually)

            // Fade out Lore
            fadeAudio(audioPlayer, 0, 800, () => {
                audioPlayer.pause();

                // Restore Main Track
                audioPlayer.src = window.mainAudioUrl;

                // Restore Tracks
                // Fix: Explicitly reload Chapter 1 text to ensure correctness (like in Liminal Library)
                console.log("Reloading Main Chapter Text (kapitel1.txt)...");
                fetch('assets/kapitel1.txt')
                    .then(r => r.text())
                    .then(text => {
                        parseSubtitles(text);
                        // After parsing, set proper time
                        const resumeTime = Math.max(0, mainAudioState.time - 5);
                        audioPlayer.currentTime = resumeTime;
                        renderSubtitleLines(Math.max(0, currentSubtitleIndex));
                    })
                    .catch(e => {
                        console.error("Failed to restore main text:", e);
                        // Fallback to cached state if fetch fails
                        if (mainAudioState.tracks && mainAudioState.tracks.length > 0) {
                            subtitleTracks = [...mainAudioState.tracks];
                            const resumeTime = Math.max(0, mainAudioState.time - 5);
                            audioPlayer.currentTime = resumeTime;
                            renderSubtitleLines(Math.max(0, currentSubtitleIndex));
                        }
                    });

                // Restore Time (minus 5s rewind)
                const resumeTime = Math.max(0, mainAudioState.time - 5);
                audioPlayer.currentTime = resumeTime;

                // Update UI
                renderSubtitleLines(Math.max(0, currentSubtitleIndex)); // Will re-find index based on time

                // Resume Playback only if it was playing before
                if (mainAudioState.wasPlaying) {
                    audioPlayer.volume = 0;
                    audioPlayer.play().catch(e => console.warn("Resume blocked:", e));
                    fadeAudio(audioPlayer, 1, 800);
                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';
                }

                // Reset Active Lore Flags
                activeLoreId = null;
                activeLightSourceId = null;
                isMenuTriggeredLore = false;

                uiContainer.classList.remove('mode-switching'); // Clean up class
            });
        }

        // Alias for Proximity System (Legacy Name compatibility)
        function endLoreMode() {
            restoreMainAudio();
        }

        function startLoreMode(id, fromMenu = false) {
            if (isLoreMode && activeLoreId === id) return; // Prevent restart of same

            // Wenn wir schon im Lore Mode sind (anderes Lore), erst beenden? 
            // Hier einfacher: Harter Switch erlauben oder ignorieren. 
            // Wir erlauben Switch, aber müssen sauber aufräumen.
            isLoreMode = true;
            // isReadingMode = true; // REMOVED: Respect current mode!
            // uiContainer.classList.add('reading-mode'); // REMOVED: Respect current mode!

            // If we are ALREADY in reading mode, update UI class just in case
            if (isReadingMode) {
                uiContainer.classList.add('reading-mode');
            } else {
                uiContainer.classList.remove('reading-mode');
            }
            moveTarget = null; // Stoppe Bewegung
            activeLoreId = id;
            isMenuTriggeredLore = fromMenu; // Set flag

            if (loreResumeTimeout) clearTimeout(loreResumeTimeout);

            // Haupt-Audio Status sichern (nur wenn wir nicht schon in einer Lore sind)
            // Haupt-Audio Status sichern (nur wenn wir nicht schon in einer Lore sind)
            // Fix: Check if current track is actually MAIN audio before saving
            const isMainAudio = audioPlayer.src.includes(window.mainAudioUrl) || audioPlayer.src.includes('kapitel1.mp3');

            if (!mainAudioState.wasPlaying && !audioPlayer.paused && isMainAudio) {
                mainAudioState.wasPlaying = !audioPlayer.paused;
                mainAudioState.time = audioPlayer.currentTime;
                // mainAudioState.tracks = [...subtitleTracks]; // We will reload from file anyway
            } else if (!isLoreMode && isMainAudio) {
                // First entry or update
                mainAudioState.wasPlaying = !audioPlayer.paused;
                mainAudioState.time = audioPlayer.currentTime;
            }

            // Sanftes Ausblenden (Main Audio) - 2 Sekunden (oder sofort bei Switch?)
            fadeAudio(audioPlayer, 0, 1000, async () => {
                audioPlayer.pause();
                // ... rest of logic stays mostly same, just ensure flag is used
                // ...


                // UI Feedback
                uiContainer.classList.add('mode-switching');

                // Debugging Lore Text Loading
                console.log(`[DEBUG] startLoreMode ID: ${id}`);
                console.log(`[DEBUG] Text in loreData for ID ${id}:`, loreData.text[id] ? loreData.text[id].substring(0, 50) + "..." : "UNDEFINED/NULL");

                // RETRY LOADING TEXT IF MISSING
                // Hardcoded Backup because Fetch might fail on file:// protocol
                if (!loreData.text[id] || loreData.text[id].length < 10) {
                    // Try fetch first
                    try {
                        // Use path from GameState if available
                        const content = window.GameState?.getLore(id);
                        const textPath = content ? content.text : `assets/lore${id}.txt`;
                        console.log(`Loading text from ${textPath} (ID: ${id})...`);

                        const res = await fetch(textPath);
                        if (res.ok) {
                            loreData.text[id] = await res.text();
                            console.log(`Lore ${id} text recovered.`);
                        } else {
                            console.warn(`Fetch failed for ${textPath}: ${res.status}`);
                        }
                    } catch (e) {
                        console.warn("Lore retry failed:", e);
                    }
                }

                setTimeout(() => {
                    // Lore laden
                    audioPlayer.src = loreData.audio[id];

                    // Rewind 5s beim Wiederaufnehmen (User-Wunsch)
                    const lastPos = loreData.resumeTimes[id] || 0;
                    audioPlayer.currentTime = Math.max(0, lastPos - 5);

                    if (loreData.text[id] && loreData.text[id].length > 0) {
                        console.log(`[DEBUG] Parsing Subtitles for ID ${id}...`);
                        parseSubtitles(loreData.text[id]);
                        console.log(`[DEBUG] Subtitle Tracks Found: ${subtitleTracks.length}`);

                        // Force highlight first line immediately
                        currentSubtitleIndex = 0;
                        renderSubtitleLines(0);
                    } else {
                        console.warn(`[DEBUG] No text found for ID ${id}!`);
                        subtitleTracks = [];
                        subtitleContainer.innerHTML = '<div class="subtitle-line subtitle-current">♪ Lore Audio (Warte auf Text...) ♪</div>';
                    }

                    audioPlayer.volume = 0;
                    audioPlayer.play().catch(e => console.error("Lore play error:", e));
                    fadeAudio(audioPlayer, 1.0, 1000); // Sanftes Einblenden - 1 Sekunde (verkürzt)

                    iconPlay.style.display = 'none';
                    iconPause.style.display = 'block';

                    audioPlayer.onended = () => {
                        loreData.resumeTimes[id] = 0; // Reset wenn fertig
                        endLoreMode();
                    };

                    uiContainer.classList.remove('mode-switching');
                    console.log(`Lore ${id} gestartet bei ${audioPlayer.currentTime.toFixed(1)}s`);
                }, 250);
            });
        }

        function endLoreMode() {
            if (!isLoreMode) return;
            isLoreMode = false;
            isMenuTriggeredLore = false; // Reset menu flag

            const id = activeLoreId;
            // Fortschritt speichern
            if (id) loreData.resumeTimes[id] = audioPlayer.currentTime;
            activeLoreId = null;
            activeLightSourceId = null; // Licht zurücksetzen

            fadeAudio(audioPlayer, 0, 2000, () => {
                audioPlayer.pause();
                audioPlayer.onended = null;

                uiContainer.classList.add('mode-switching');
                subtitleContainer.innerHTML = '';

                // ... logic to resume main audio continues below ...

                // 1 Sekunde Pause vor Resume (wie vom User gewünscht)
                loreResumeTimeout = setTimeout(() => {
                    if (window.mainAudioUrl) {
                        audioPlayer.src = window.mainAudioUrl;

                        if (window.mainTextContent) {
                            parseSubtitles(window.mainTextContent);
                        } else {
                            subtitleTracks = [...mainAudioState.tracks];
                        }

                        // Rewind 5s beim Wiederaufnehmen (User-Wunsch)
                        const resumeTime = Math.max(0, mainAudioState.time - 5);
                        audioPlayer.currentTime = resumeTime;

                        if (mainAudioState.wasPlaying) {
                            audioPlayer.volume = 0;
                            audioPlayer.play();
                            fadeAudio(audioPlayer, 1.0, 2000); // 2 Sekunden Einblenden
                            iconPlay.style.display = 'none';
                            iconPause.style.display = 'block';
                        } else {
                            audioPlayer.volume = 1.0;
                            iconPlay.style.display = 'block';
                            iconPause.style.display = 'none';
                        }

                        audioPlayer.onended = () => {
                            iconPlay.style.display = 'block';
                            iconPause.style.display = 'none';
                            renderSubtitleLines(subtitleTracks.length - 1);
                        };

                        console.log(`Haupt-Audio fortgesetzt bei ${resumeTime.toFixed(1)}s`);
                    }
                    uiContainer.classList.remove('mode-switching');
                }, 1000); // 1 Sekunde Pause
            });
        }

        // Hilfsfunktion für Audio-Fading
        function fadeAudio(audio, targetVolume, duration, callback) {
            const startVolume = audio.volume;
            const diff = targetVolume - startVolume;
            const startTime = Date.now();

            function tick() {
                const now = Date.now();
                const progress = Math.min(1, (now - startTime) / duration);
                audio.volume = startVolume + diff * progress;

                if (progress < 1) {
                    requestAnimationFrame(tick);
                } else if (callback) {
                    callback();
                }
            }
            tick();
        }
    </script>
</body>

</html>